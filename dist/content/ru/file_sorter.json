{
	"erlref": {
		"header": {
			"copyright": {
				"year": [
					"2001",
					"2016"
				],
				"holder": "Ericsson AB. All Rights Reserved."
			},
			"legalnotice": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
			"title": "file_sorter",
			"prepared": "Hans Bolinder",
			"responsible": {},
			"docno": {},
			"approved": {},
			"checked": {},
			"date": "2001-03-13",
			"rev": "PA1",
			"file": "file_sorter.xml"
		},
		"module": {
			"since": "",
			"$t": "file_sorter"
		},
		"modulesummary": "File sorter.",
		"description": {
			"p": [
				"This module contains functions for sorting terms on files, merging already sorted files, and checking files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally in memory and written on temporary files, which are merged producing one sorted file as output. Merging is provided as an optimization; it is faster when the files are already sorted, but it always works to sort instead of merge.",
				"On a file, a term is represented by a header and a binary. Two options define the format of terms on files:",
				"Other options are:",
				{
					"c": "read"
				},
				{
					"c": [
						"sort",
						"keysort",
						"close"
					]
				},
				{
					"c": "close"
				},
				{
					"c": [
						"{end_of_input, Value}",
						"{value, Value}"
					]
				},
				"As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.",
				{
					"c": [
						"file_sorter",
						"term"
					]
				},
				{
					"c": "Reason"
				}
			],
			"taglist": [
				{
					"tag": [
						{
							"c": "{header, HeaderLength}"
						},
						{
							"c": "{format, Format}"
						}
					],
					"item": [
						{
							"p": {
								"c": [
									"HeaderLength",
									"B",
									"Size",
									"<<Size:HeaderLength/unit:8>> = B"
								]
							}
						},
						{
							"p": [
								{
									"c": [
										"Format",
										"binary_term",
										"funbinary_to_term/1",
										"binary",
										"fun(X) -> X end",
										"Format",
										"term",
										"io:read/2",
										"header"
									]
								},
								{
									"c": [
										"format",
										"Format",
										"term",
										"io:format/3",
										"Format",
										"io"
									]
								}
							]
						}
					]
				},
				{
					"tag": [
						{
							"c": "{order, Order}"
						},
						{
							"c": "{unique, boolean()}"
						},
						{
							"c": "{tmpdir, TempDirectory}"
						},
						{
							"c": "{compressed, boolean()}"
						},
						{
							"c": "{size, Size}"
						},
						{
							"c": "{no_files, NoFiles}"
						}
					],
					"item": [
						{
							"p": {
								"c": [
									"descending",
									"Fun",
									"Fun(A,B)",
									"true",
									"A",
									"B",
									"false",
									"=</2",
									"keysort",
									"keymerge",
									"keycheck"
								]
							}
						},
						{
							"p": {
								"c": [
									"==",
									"true",
									"false",
									"true"
								]
							}
						},
						{
							"p": {
								"c": [
									"\"\"",
									"file:get_cwd()",
									"node()",
									"os:getpid()",
									"erlang:unique_integer([positive])",
									"fs_mynode@myhost_1763_4711.17",
									"17",
									"EXIT"
								]
							}
						},
						{
							"p": {
								"c": [
									"false",
									"compressed"
								]
							}
						},
						{
							"p": "By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed."
						},
						{
							"p": "By default 16 files are merged at a time. This option is rarely needed."
						}
					]
				}
			],
			"list": [
				{
					"type": "bulleted",
					"item": [
						{
							"p": {
								"c": [
									"end_of_input",
									"{end_of_input, Value}}",
									"Value"
								]
							}
						},
						{
							"p": {
								"c": [
									"{Objects, Fun}",
									"Objects",
									"Fun"
								]
							}
						}
					]
				},
				{
					"type": "bulleted",
					"item": [
						{
							"p": {
								"c": [
									"bad_object",
									"{bad_object, FileName}"
								]
							}
						},
						{
							"p": {
								"c": [
									"{bad_term, FileName}",
									"io:read/2"
								]
							}
						},
						{
							"p": {
								"c": [
									"{file_error, FileName, file:posix()}",
									"file:posix()"
								],
								"seealso": {
									"marker": "kernel:file",
									"c": "file(3)"
								}
							}
						},
						{
							"p": {
								"c": "{premature_eof, FileName}"
							}
						}
					]
				}
			],
			"pre": "sort(Log) -> {ok, _} = disk_log:open([{name,Log}, {mode,read_only}]), Input = input(Log, start), Output = output([]), Reply = file_sorter:sort(Input, Output, {format,term}), ok = disk_log:close(Log), Reply.input(Log, Cont) -> fun(close) -> ok; (read) -> case disk_log:chunk(Log, Cont) of {error, Reason} -> {error, Reason}; {Cont2, Terms} -> {Terms, input(Log, Cont2)}; {Cont2, Terms, _Badbytes} -> {Terms, input(Log, Cont2)}; eof -> end_of_input end end.output(L) -> fun(close) -> lists:append(lists:reverse(L)); (Terms) -> output([Terms | L]) end."
		},
		"datatypes": {
			"datatype": [
				{
					"name": {
						"name": "file_name"
					}
				},
				{
					"name": {
						"name": "file_names"
					}
				},
				{
					"name": {
						"name": "i_command"
					}
				},
				{
					"name": {
						"name": "i_reply"
					}
				},
				{
					"name": {
						"name": "infun"
					}
				},
				{
					"name": {
						"name": "input"
					}
				},
				{
					"name": {
						"name": "input_reply"
					}
				},
				{
					"name": {
						"name": "o_command"
					}
				},
				{
					"name": {
						"name": "o_reply"
					}
				},
				{
					"name": {
						"name": "object"
					}
				},
				{
					"name": {
						"name": "outfun"
					}
				},
				{
					"name": {
						"name": "output"
					}
				},
				{
					"name": {
						"name": "output_reply"
					}
				},
				{
					"name": {
						"name": "value"
					}
				},
				{
					"name": {
						"name": "options"
					}
				},
				{
					"name": {
						"name": "option"
					}
				},
				{
					"name": {
						"name": "format"
					}
				},
				{
					"name": {
						"name": "format_fun"
					}
				},
				{
					"name": {
						"name": "header_length"
					}
				},
				{
					"name": {
						"name": "key_pos"
					}
				},
				{
					"name": {
						"name": "no_files"
					}
				},
				{
					"name": {
						"name": "order"
					}
				},
				{
					"name": {
						"name": "order_fun"
					}
				},
				{
					"name": {
						"name": "size"
					}
				},
				{
					"name": {
						"name": "tmp_directory"
					}
				},
				{
					"name": {
						"name": "reason"
					}
				}
			]
		},
		"funcs": {
			"func": [
				{
					"name": [
						{
							"name": "check",
							"arity": "1",
							"since": ""
						},
						{
							"name": "check",
							"arity": "2",
							"since": ""
						}
					],
					"fsummary": "Check whether terms on files are sorted.",
					"desc": {
						"p": [
							"Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1.",
							{
								"c": [
									"check(FileName)",
									"check([FileName], [])"
								]
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "keycheck",
							"arity": "2",
							"since": ""
						},
						{
							"name": "keycheck",
							"arity": "3",
							"since": ""
						}
					],
					"fsummary": "Check whether terms on files are sorted by key.",
					"desc": {
						"p": [
							"Checks files for sortedness. If a file is not sorted, the first out-of-order element is returned. The first term on a file has position 1.",
							{
								"c": [
									"keycheck(KeyPos, FileName)",
									"keycheck(KeyPos, [FileName], [])"
								]
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "keymerge",
							"arity": "3",
							"since": ""
						},
						{
							"name": "keymerge",
							"arity": "4",
							"since": ""
						}
					],
					"fsummary": "Merge terms on files by key.",
					"desc": {
						"p": [
							"Merges tuples on files. Each input file is assumed to be sorted on key(s).",
							{
								"c": [
									"keymerge(KeyPos, FileNames, Output)",
									"keymerge(KeyPos, FileNames, Output, [])"
								]
							}
						]
					}
				},
				{
					"name": {
						"name": "keysort",
						"arity": "2",
						"since": ""
					},
					"fsummary": "Sort terms on files by key.",
					"desc": {
						"p": [
							"Sorts tuples on files.",
							{
								"c": [
									"keysort(N, FileName)",
									"keysort(N, [FileName], FileName)"
								]
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "keysort",
							"arity": "3",
							"since": ""
						},
						{
							"name": "keysort",
							"arity": "4",
							"since": ""
						}
					],
					"fsummary": "Sort terms on files by key.",
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "KeyPos"
									},
									"==",
									{
										"anno": "KeyPos"
									}
								]
							},
							{
								"c": [
									"keysort(N, Input, Output)",
									"keysort(N, Input, Output, [])"
								]
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "merge",
							"arity": "2",
							"since": ""
						},
						{
							"name": "merge",
							"arity": "3",
							"since": ""
						}
					],
					"fsummary": "Merge terms on files.",
					"desc": {
						"p": [
							"Merges terms on files. Each input file is assumed to be sorted.",
							{
								"c": [
									"merge(FileNames, Output)",
									"merge(FileNames, Output, [])"
								]
							}
						]
					}
				},
				{
					"name": {
						"name": "sort",
						"arity": "1",
						"since": ""
					},
					"fsummary": "Sort terms on files.",
					"desc": {
						"p": [
							"Sorts terms on files.",
							{
								"c": [
									"sort(FileName)",
									"sort([FileName], FileName)"
								]
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "sort",
							"arity": "2",
							"since": ""
						},
						{
							"name": "sort",
							"arity": "3",
							"since": ""
						}
					],
					"fsummary": "Sort terms on files.",
					"desc": {
						"p": [
							"Sorts terms on files.",
							{
								"c": [
									"sort(Input, Output)",
									"sort(Input, Output, [])"
								]
							}
						]
					}
				}
			]
		}
	}
}