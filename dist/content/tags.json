[["alarm_handler","clear_alarm(AlarmId) -> void()get_alarms() -> [alarm()]set_alarm(alarm())"],["app"],["application","ensure_all_started(Application) -> {ok, Started} | {error, Reason}ensure_all_started(Application, Type) -> {ok, Started} | {error, Reason}ensure_started(Application) -> ok | {error, Reason}ensure_started(Application, Type) -> ok | {error, Reason}get_all_env() -> Envget_all_env(Application) -> Envget_all_key() -> [] | {ok, Keys}get_all_key(Application) -> undefined | Keysget_application() -> undefined | {ok, Application}get_application(PidOrModule) -> undefined | {ok, Application}get_env(Par) -> undefined | {ok, Val}get_env(Application, Par) -> undefined | {ok, Val}get_env(Application, Par, Def) -> Valget_key(Key) -> undefined | {ok, Val}get_key(Application, Key) -> undefined | {ok, Val}load(AppDescr) -> ok | {error, Reason}load(AppDescr, Distributed) -> ok | {error, Reason}loaded_applications() -> [{Application, Description, Vsn}]set_env(Config) -> okset_env(Config, Opts) -> okpermit(Application, Permission) -> ok | {error, Reason}set_env(Application, Par, Val) -> okset_env(Application, Par, Val, Opts) -> okstart(Application) -> ok | {error, Reason}start(Application, Type) -> ok | {error, Reason}start_type() -> StartType | undefined | localstop(Application) -> ok | {error, Reason}takeover(Application, Type) -> ok | {error, Reason}unload(Application) -> ok | {error, Reason}unset_env(Application, Par) -> okunset_env(Application, Par, Opts) -> okwhich_applications() -> [{Application, Description, Vsn}]which_applications(Timeout) -> [{Application, Description, Vsn}]","Module:start(StartType, StartArgs) -> {ok, Pid} | {ok, Pid, State} | {error, Reason}Module:start_phase(Phase, StartType, PhaseArgs) -> ok | {error, Reason}Module:prep_stop(State) -> NewStateModule:stop(State)Module:config_change(Changed, New, Removed) -> ok"],["re","version() -> binary()compile(Regexp) -> {ok, MP} | {error, ErrSpec}compile(Regexp, Options) -> {ok, MP} | {error, ErrSpec}inspect(MP, Item) -> {namelist, [binary()]}replace(Subject, RE, Replacement) -> iodata() | unicode:charlist() replace(Subject, RE, Replacement, Options) -> iodata() | unicode:charlist() run(Subject, RE) -> {match, Captured} | nomatchrun(Subject, RE, Options) -> {match, Captured} | match | nomatch | {error, ErrType}split(Subject, RE) -> SplitListsplit(Subject, RE, Options) -> SplitList"],["array","default(Array :: array(Type)) -> Value :: Typefix(Array :: array(Type)) -> array(Type)foldl(Function, InitialAcc :: A, Array :: array(Type)) -> Bfoldr(Function, InitialAcc :: A, Array :: array(Type)) -> Bfrom_list(List :: [Value :: Type]) -> array(Type)from_list(List :: [Value :: Type], Default :: term()) -> array(Type)from_orddict(Orddict :: indx_pairs(Value :: Type)) -> array(Type)from_orddict(Orddict :: indx_pairs(Value :: Type), Default :: Type) -> array(Type)get(I :: array_indx(), Array :: array(Type)) -> Value :: Typeis_array(X :: term()) -> boolean()is_fix(Array :: array()) -> boolean()map(Function, Array :: array(Type1)) -> array(Type2)new() -> array() new(Options :: array_opts()) -> array() new(Size :: integer() >= 0, Options :: array_opts()) -> array() relax(Array :: array(Type)) -> array(Type)reset(I :: array_indx(), Array :: array(Type)) -> array(Type)resize(Array :: array(Type)) -> array(Type)resize(Size :: integer() >= 0, Array :: array(Type)) -> array(Type)set(I :: array_indx(), Value :: Type, Array :: array(Type)) -> array(Type)size(Array :: array()) -> integer() >= 0sparse_foldl(Function, InitialAcc :: A, Array :: array(Type)) -> Bsparse_foldr(Function, InitialAcc :: A, Array :: array(Type)) -> Bsparse_map(Function, Array :: array(Type1)) -> array(Type2)sparse_size(Array :: array()) -> integer() >= 0sparse_to_list(Array :: array(Type)) -> [Value :: Type]sparse_to_orddict(Array :: array(Type)) -> indx_pairs(Value :: Type)to_list(Array :: array(Type)) -> [Value :: Type]to_orddict(Array :: array(Type)) -> indx_pairs(Value :: Type)"]]