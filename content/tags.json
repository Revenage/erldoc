[
  [
    "alarm_handler",
    "clear_alarm(AlarmId) -> void()get_alarms() -> [alarm()]set_alarm(alarm())"
  ],
  ["app"],
  [
    "application",
    "ensure_all_started(Application) -> {ok, Started} | {error, Reason}ensure_all_started(Application, Type) -> {ok, Started} | {error, Reason}ensure_started(Application) -> ok | {error, Reason}ensure_started(Application, Type) -> ok | {error, Reason}get_all_env() -> Envget_all_env(Application) -> Envget_all_key() -> [] | {ok, Keys}get_all_key(Application) -> undefined | Keysget_application() -> undefined | {ok, Application}get_application(PidOrModule) -> undefined | {ok, Application}get_env(Par) -> undefined | {ok, Val}get_env(Application, Par) -> undefined | {ok, Val}get_env(Application, Par, Def) -> Valget_key(Key) -> undefined | {ok, Val}get_key(Application, Key) -> undefined | {ok, Val}load(AppDescr) -> ok | {error, Reason}load(AppDescr, Distributed) -> ok | {error, Reason}loaded_applications() -> [{Application, Description, Vsn}]set_env(Config) -> okset_env(Config, Opts) -> okpermit(Application, Permission) -> ok | {error, Reason}set_env(Application, Par, Val) -> okset_env(Application, Par, Val, Opts) -> okstart(Application) -> ok | {error, Reason}start(Application, Type) -> ok | {error, Reason}start_type() -> StartType | undefined | localstop(Application) -> ok | {error, Reason}takeover(Application, Type) -> ok | {error, Reason}unload(Application) -> ok | {error, Reason}unset_env(Application, Par) -> okunset_env(Application, Par, Opts) -> okwhich_applications() -> [{Application, Description, Vsn}]which_applications(Timeout) -> [{Application, Description, Vsn}]",
    "Module:start(StartType, StartArgs) -> {ok, Pid} | {ok, Pid, State} | {error, Reason}Module:start_phase(Phase, StartType, PhaseArgs) -> ok | {error, Reason}Module:prep_stop(State) -> NewStateModule:stop(State)Module:config_change(Changed, New, Removed) -> ok"
  ],
  ["appup"],
  [
    "array",
    "default(Array :: array(Type)) -> Value :: Typefix(Array :: array(Type)) -> array(Type)foldl(Function, InitialAcc :: A, Array :: array(Type)) -> Bfoldr(Function, InitialAcc :: A, Array :: array(Type)) -> Bfrom_list(List :: [Value :: Type]) -> array(Type)from_list(List :: [Value :: Type], Default :: term()) -> array(Type)from_orddict(Orddict :: indx_pairs(Value :: Type)) -> array(Type)from_orddict(Orddict :: indx_pairs(Value :: Type), Default :: Type) -> array(Type)get(I :: array_indx(), Array :: array(Type)) -> Value :: Typeis_array(X :: term()) -> boolean()is_fix(Array :: array()) -> boolean()map(Function, Array :: array(Type1)) -> array(Type2)new() -> array() new(Options :: array_opts()) -> array() new(Size :: integer() >= 0, Options :: array_opts()) -> array() relax(Array :: array(Type)) -> array(Type)reset(I :: array_indx(), Array :: array(Type)) -> array(Type)resize(Array :: array(Type)) -> array(Type)resize(Size :: integer() >= 0, Array :: array(Type)) -> array(Type)set(I :: array_indx(), Value :: Type, Array :: array(Type)) -> array(Type)size(Array :: array()) -> integer() >= 0sparse_foldl(Function, InitialAcc :: A, Array :: array(Type)) -> Bsparse_foldr(Function, InitialAcc :: A, Array :: array(Type)) -> Bsparse_map(Function, Array :: array(Type1)) -> array(Type2)sparse_size(Array :: array()) -> integer() >= 0sparse_to_list(Array :: array(Type)) -> [Value :: Type]sparse_to_orddict(Array :: array(Type)) -> indx_pairs(Value :: Type)to_list(Array :: array(Type)) -> [Value :: Type]to_orddict(Array :: array(Type)) -> indx_pairs(Value :: Type)"
  ],
  [
    "asn1ct",
    "compile(Asn1module) -> ok | {error, Reason}compile(Asn1module, Options) -> ok | {error, Reason}value(Module, Type) -> {ok, Value} | {error, Reason}test(Module) -> ok | {error, Reason}test(Module, Type | Options) -> ok | {error, Reason}test(Module, Type, Value | Options) -> ok | {error, Reason}"
  ],
  ["assert.hrl"],
  [
    "atomics",
    "new(Arity, Opts) -> atomics_ref() put(Ref, Ix, Value) -> okget(Ref, Ix) -> integer()add(Ref, Ix, Incr) -> okadd_get(Ref, Ix, Incr) -> integer()sub(Ref, Ix, Decr) -> oksub_get(Ref, Ix, Decr) -> integer()exchange(Ref, Ix, Desired) -> integer()compare_exchange(Ref, Ix, Expected, Desired) -> ok | integer()info(Ref) -> Info"
  ],
  [
    "auth",
    "cookie() -> Cookiecookie(TheCookie) -> trueis_auth(Node) -> yes | nonode_cookie(Node, Cookie) -> yes | no",
    "node_cookie([Node, Cookie]) -> yes | no"
  ],
  [
    "base64",
    "decode(Base64) -> Datadecode_to_string(Base64) -> DataStringmime_decode(Base64) -> Datamime_decode_to_string(Base64) -> DataStringencode(Data) -> Base64encode_to_string(Data) -> Base64String"
  ],
  [
    "beam_lib",
    "all_chunks(File :: beam()) -> {ok, beam_lib, [{chunkid(), dataB()}]} | {error, beam_lib, info_rsn()}build_module(Chunks) -> {ok, Binary}chunks(Beam, ChunkRefs) -> {ok, {module(), [chunkdata()]}} | {error, beam_lib, chnk_rsn()}chunks(Beam, ChunkRefs, Options) -> {ok, {module(), [ChunkResult]}} | {error, beam_lib, chnk_rsn()}clear_crypto_key_fun() -> undefined | {ok, Result}cmp(Beam1, Beam2) -> ok | {error, beam_lib, cmp_rsn()}cmp_dirs(Dir1, Dir2) -> {Only1, Only2, Different} | {error, beam_lib, Reason}crypto_key_fun(CryptoKeyFun) -> ok | {error, Reason}diff_dirs(Dir1, Dir2) -> ok | {error, beam_lib, Reason}format_error(Reason) -> io_lib:chars() info(Beam) -> [InfoPair] | {error, beam_lib, info_rsn()}md5(Beam) -> {ok, {module(), MD5}} | {error, beam_lib, chnk_rsn()}strip(Beam1) -> {ok, {module(), Beam2}} | {error, beam_lib, info_rsn()}strip(Beam1, AdditionalChunks) -> {ok, {module(), Beam2}} | {error, beam_lib, info_rsn()}strip_files(Files) -> {ok, [{module(), Beam}]} | {error, beam_lib, info_rsn()}strip_files(Files, AdditionalChunks) -> {ok, [{module(), Beam}]} | {error, beam_lib, info_rsn()}strip_release(Dir) -> {ok, [{module(), file:filename()}]} | {error, beam_lib, Reason}strip_release(Dir, AdditionalChunks) -> {ok, [{module(), file:filename()}]} | {error, beam_lib, Reason}version(Beam) -> {ok, {module(), [Version :: term()]}} | {error, beam_lib, chnk_rsn()}"
  ],
  [
    "binary",
    "at(Subject, Pos) -> byte()bin_to_list(Subject) -> [byte()]bin_to_list(Subject, PosLen) -> [byte()]bin_to_list(Subject, Pos, Len) -> [byte()]compile_pattern(Pattern) -> cp() copy(Subject) -> binary()copy(Subject, N) -> binary()decode_unsigned(Subject) -> Unsigneddecode_unsigned(Subject, Endianness) -> Unsignedencode_unsigned(Unsigned) -> binary()encode_unsigned(Unsigned, Endianness) -> binary()first(Subject) -> byte()last(Subject) -> byte()list_to_bin(ByteList) -> binary()longest_common_prefix(Binaries) -> integer() >= 0longest_common_suffix(Binaries) -> integer() >= 0match(Subject, Pattern) -> Found | nomatchmatch(Subject, Pattern, Options) -> Found | nomatchmatches(Subject, Pattern) -> Foundmatches(Subject, Pattern, Options) -> Foundpart(Subject, PosLen) -> binary()part(Subject, Pos, Len) -> binary()referenced_byte_size(Binary) -> integer() >= 0replace(Subject, Pattern, Replacement) -> Resultreplace(Subject, Pattern, Replacement, Options) -> Resultsplit(Subject, Pattern) -> Partssplit(Subject, Pattern, Options) -> Parts"
  ],
  [
    "c",
    "bt(Pid) -> ok | undefinedc(Module) -> {ok, ModuleName} | errorc(Module, Options) -> {ok, ModuleName} | errorc(Module, Options, Filter) -> {ok, ModuleName} | errorcd(Dir) -> okerlangrc(PathList) -> {ok, file:filename()} | {error, term()}flush() -> okhelp() -> oki() -> okni() -> oki(X, Y, Z) -> [{atom(), term()}]l(Module) -> code:load_ret() lm() -> [code:load_ret()]ls() -> okls(Dir) -> okm() -> okm(Module) -> okmm() -> [module()]memory() -> [{Type, Size}]memory(Type) -> Sizememory(Types) -> [{Type, Size}]nc(File) -> {ok, Module} | errornc(File, Options) -> {ok, Module} | errornl(Module) -> abcast | errorpid(X, Y, Z) -> pid()pwd() -> okq() -> no_return()regs() -> oknregs() -> okuptime() -> ok",
    "lc(Files) -> okxm(ModSpec) -> void()y(File) -> YeccRety(File, Options) -> YeccRet"
  ],
  [
    "calendar",
    "date_to_gregorian_days(Date) -> Daysdate_to_gregorian_days(Year, Month, Day) -> Daysdatetime_to_gregorian_seconds(DateTime) -> Secondsday_of_the_week(Date) -> daynum() day_of_the_week(Year, Month, Day) -> daynum() gregorian_days_to_date(Days) -> date() gregorian_seconds_to_datetime(Seconds) -> datetime() is_leap_year(Year) -> boolean()iso_week_number() -> yearweeknum() iso_week_number(Date) -> yearweeknum() last_day_of_the_month(Year, Month) -> LastDaylocal_time() -> datetime() local_time_to_universal_time(DateTime1) -> DateTime2local_time_to_universal_time_dst(DateTime1) -> [DateTime]now_to_datetime(Now) -> datetime1970() now_to_local_time(Now) -> datetime1970() now_to_universal_time(Now) -> datetime1970() rfc3339_to_system_time(DateTimeString) -> integer()rfc3339_to_system_time(DateTimeString, Options) -> integer()seconds_to_daystime(Seconds) -> {Days, Time}seconds_to_time(Seconds) -> time() system_time_to_local_time(Time, TimeUnit) -> datetime() system_time_to_rfc3339(Time) -> DateTimeStringsystem_time_to_rfc3339(Time, Options) -> DateTimeStringsystem_time_to_universal_time(Time, TimeUnit) -> datetime() time_difference(T1, T2) -> {Days, Time}time_to_seconds(Time) -> secs_per_day()universal_time() -> datetime() universal_time_to_local_time(DateTime) -> datetime() valid_date(Date) -> boolean()valid_date(Year, Month, Day) -> boolean()"
  ],
  ["cdv"],
  [
    "cerl",
    "abstract(Term::term()) -> cerl()add_ann(Annotations::[term()], Node::cerl()) -> cerl()alias_pat(Node::cerl()) -> cerl()alias_var(Node::cerl()) -> cerl()ann_abstract(Annotations::[term()], Term::term()) -> cerl()ann_c_alias(As::[term()], Variable::cerl(), Pattern::cerl()) -> cerl()ann_c_apply(As::[term()], Operator::cerl(), Arguments::[cerl()]) -> cerl()ann_c_atom(As::[term()], Name) -> cerl()ann_c_binary(As::[term()], Segments::[cerl()]) -> cerl()ann_c_bitstr(As::[term()], Value::cerl(), Size::cerl(), Type::cerl(), Flags::cerl()) -> cerl()ann_c_bitstr(As::[term()], Value::cerl(), Size::cerl(), Unit::cerl(), Type::cerl(), Flags::cerl()) -> cerl()ann_c_call(As::[term()], Module::cerl(), Name::cerl(), Arguments::[cerl()]) -> cerl()ann_c_case(As::[term()], Argument::cerl(), Clauses::[cerl()]) -> cerl()ann_c_catch(As::[term()], Body::cerl()) -> cerl()ann_c_char(As::[term()], Value::char()) -> cerl()ann_c_clause(As::[term()], Patterns::[cerl()], Body::cerl()) -> cerl()ann_c_clause(As::[term()], Patterns::[cerl()], Guard::cerl(), Body::cerl()) -> cerl()ann_c_cons(As::[term()], Head::cerl(), Tail::cerl()) -> cerl()ann_c_cons_skel(As::[term()], Head::cerl(), Tail::cerl()) -> cerl()ann_c_float(As::[term()], Value::float()) -> cerl()ann_c_fname(As::[term()], Name::atom(), Arity::arity()) -> cerl()ann_c_fun(As::[term()], Variables::[cerl()], Body::cerl()) -> cerl()ann_c_int(As::[term()], Value::integer()) -> cerl()ann_c_let(As::[term()], Variables::[cerl()], Argument::cerl(), Body::cerl()) -> c_let()ann_c_letrec(As::[term()], Definitions::[{cerl(), cerl()}], Body::cerl()) -> cerl()ann_c_map(As::[term()], Es::[c_map_pair()]) -> c_map() | c_literal()ann_c_map(As::[term()], C_literal::c_map() | c_literal(), Es::[c_map_pair()]) -> c_map() | c_literal()ann_c_map_pair(As::[term()], Op::cerl(), K::cerl(), V::cerl()) -> c_map_pair()ann_c_map_pattern(As::[term()], Pairs::[c_map_pair()]) -> c_map()ann_c_module(As::[term()], Name::cerl(), Exports, Es::Definitions) -> cerl()ann_c_module(As::[term()], Name::cerl(), Exports, Attrs::Attributes, Es::Definitions) -> cerl()ann_c_nil(As::[term()]) -> cerl()ann_c_primop(As::[term()], Name::cerl(), Arguments::[cerl()]) -> cerl()ann_c_receive(As::[term()], Clauses::[cerl()]) -> cerl()ann_c_receive(As::[term()], Clauses::[cerl()], Timeout::cerl(), Action::cerl()) -> cerl()ann_c_seq(As::[term()], Argument::cerl(), Body::cerl()) -> cerl()ann_c_string(As::[term()], Value::string()) -> cerl()ann_c_try(As::[term()], Expression::cerl(), Variables::[cerl()], Body::cerl(), EVars::[cerl()], Handler::cerl()) -> cerl()ann_c_tuple(As::[term()], Elements::[cerl()]) -> cerl()ann_c_tuple_skel(As::[term()], Elements::[cerl()]) -> cerl()ann_c_values(As::[term()], Elements::[cerl()]) -> cerl()ann_c_var(As::[term()], Name::var_name()) -> cerl()ann_make_data(As::[term()], Type::dtype(), Elements::[cerl()]) -> cerl()ann_make_data_skel(As::[term()], Type::dtype(), Elements::[cerl()]) -> cerl()ann_make_list(As::[term()], List::[cerl()]) -> cerl()ann_make_list(As::[term()], List::[cerl()], Tail) -> cerl()ann_make_tree(As::[term()], Type::ctype(), Groups::[[cerl()]]) -> cerl()apply_args(Node::cerl()) -> [cerl()]apply_arity(Node::cerl()) -> arity()apply_op(Node::cerl()) -> cerl()atom_lit(Node::cerl()) -> string()atom_name(Node::cerl()) -> string()atom_val(Node::cerl()) -> atom()binary_segments(Node::cerl()) -> [cerl()]bitstr_bitsize(Node::cerl()) -> any | all | utf | integer()bitstr_flags(Node::cerl()) -> cerl()bitstr_size(Node::cerl()) -> cerl()bitstr_type(Node::cerl()) -> cerl()bitstr_unit(Node::cerl()) -> cerl()bitstr_val(Node::cerl()) -> cerl()c_alias(Variable::cerl(), Pattern::cerl()) -> cerl()c_apply(Operator::cerl(), Arguments::[cerl()]) -> cerl()c_atom(Name) -> cerl()c_binary(Segments::[cerl()]) -> cerl()c_bitstr(Value::cerl(), Type::cerl(), Flags::cerl()) -> cerl()c_bitstr(Value::cerl(), Size::cerl(), Type::cerl(), Flags::cerl()) -> cerl()c_bitstr(Value::cerl(), Size::cerl(), Unit::cerl(), Type::cerl(), Flags::cerl()) -> cerl()c_call(Module::cerl(), Name::cerl(), Arguments::[cerl()]) -> cerl()c_case(Argument::cerl(), Clauses::[cerl()]) -> cerl()c_catch(Body::cerl()) -> cerl()c_char(Value) -> cerl()c_clause(Patterns::[cerl()], Body::cerl()) -> cerl()c_clause(Patterns::[cerl()], Guard::cerl(), Body::cerl()) -> cerl()c_cons(Head::cerl(), Tail::cerl()) -> cerl()c_cons_skel(Head::cerl(), Tail::cerl()) -> cerl()c_float(Value::float()) -> cerl()c_fname(Name::atom(), Arity::arity()) -> cerl()c_fun(Variables::[cerl()], Body::cerl()) -> cerl()c_int(Value::integer()) -> cerl()c_let(Variables::[cerl()], Argument::cerl(), Body::cerl()) -> cerl()c_letrec(Definitions::[{cerl(), cerl()}], Body::cerl()) -> cerl()c_map(Pairs::[c_map_pair()]) -> c_map()c_map_pair(Key::cerl(), Val::cerl()) -> c_map_pair()c_map_pair_exact(Key::cerl(), Val::cerl()) -> c_map_pair()c_map_pattern(Pairs::[c_map_pair()]) -> c_map()c_module(Name::cerl(), Exports, Es::Definitions) -> cerl()c_module(Name::cerl(), Exports, Attrs::Attributes, Es::Definitions) -> cerl()c_nil() -> cerl()c_primop(Name::cerl(), Arguments::[cerl()]) -> cerl()c_receive(Clauses::[cerl()]) -> cerl()c_receive(Clauses::[cerl()], Timeout::cerl(), Action::cerl()) -> cerl()c_seq(Argument::cerl(), Body::cerl()) -> cerl()c_string(Value::string()) -> cerl()c_try(Argument::cerl(), Variables::[cerl()], Body::cerl(), ExceptionVars::[cerl()], Handler::cerl()) -> cerl()c_tuple(Elements::[cerl()]) -> cerl()c_tuple_skel(Elements::[cerl()]) -> cerl()c_values(Elements::[cerl()]) -> cerl()c_var(Name::var_name()) -> cerl()call_args(Node::cerl()) -> [cerl()]call_arity(Node::cerl()) -> arity()call_module(Node::cerl()) -> cerl()call_name(Node::cerl()) -> cerl()case_arg(Node::cerl()) -> cerl()case_arity(Node::cerl()) -> integer()case_clauses(Node::cerl()) -> [cerl()]catch_body(Node::cerl()) -> cerl()char_lit(Node::cerl()) -> string()char_val(Node::cerl()) -> char()clause_arity(Node::cerl()) -> integer()clause_body(Node::cerl()) -> cerl()clause_guard(Node::cerl()) -> cerl()clause_pats(Node::cerl()) -> [cerl()]clause_vars(Clause::cerl()) -> [cerl()]concrete(Node::cerl()) -> term()cons_hd(C_cons::cerl()) -> cerl()cons_tl(C_cons::cerl()) -> cerl()copy_ann(Source::cerl(), Target::cerl()) -> cerl()data_arity(Node::cerl()) -> integer()data_es(Node::cerl()) -> [cerl()]data_type(Node::cerl()) -> dtype()float_lit(Node::cerl()) -> string()float_val(Node::cerl()) -> float()fname_arity(C_var::cerl()) -> arity()fname_id(C_var::cerl()) -> atom()fold_literal(Node::cerl()) -> cerl()from_records(Tree::record(record_types())) -> cerl()fun_arity(Node::cerl()) -> arity()fun_body(Node::cerl()) -> cerl()fun_vars(Node::cerl()) -> [cerl()]get_ann(Node::cerl()) -> [term()]int_lit(Node::cerl()) -> string()int_val(Node::cerl()) -> integer()is_c_alias(Node::cerl()) -> boolean()is_c_apply(Node::cerl()) -> boolean()is_c_atom(Node::cerl()) -> boolean()is_c_binary(Node::cerl()) -> boolean()is_c_bitstr(Node::cerl()) -> boolean()is_c_call(Node::cerl()) -> boolean()is_c_case(C_case::cerl()) -> boolean()is_c_catch(Node::cerl()) -> boolean()is_c_char(Node::cerl()) -> boolean()is_c_clause(Node::cerl()) -> boolean()is_c_cons(Node::cerl()) -> boolean()is_c_float(Node::cerl()) -> boolean()is_c_fname(Node::cerl()) -> boolean()is_c_fun(Node::cerl()) -> boolean()is_c_int(Node::cerl()) -> boolean()is_c_let(Node::cerl()) -> boolean()is_c_letrec(Node::cerl()) -> boolean()is_c_list(Node::cerl()) -> boolean()is_c_map(Node::cerl()) -> boolean()is_c_map_empty(C_map::c_map() | c_literal()) -> boolean()is_c_map_pattern(C_map::c_map()) -> boolean()is_c_module(Node::cerl()) -> boolean()is_c_nil(Node::cerl()) -> boolean()is_c_primop(Node::cerl()) -> boolean()is_c_receive(Node::cerl()) -> boolean()is_c_seq(Node::cerl()) -> boolean()is_c_string(Node::cerl()) -> boolean()is_c_try(Node::cerl()) -> boolean()is_c_tuple(Node::cerl()) -> boolean()is_c_values(Node::cerl()) -> boolean()is_c_var(Node::cerl()) -> boolean()is_data(Node::cerl()) -> boolean()is_leaf(Node::cerl()) -> boolean()is_literal(Node::cerl()) -> boolean()is_literal_term(Term::term()) -> boolean()is_print_char(Node::cerl()) -> boolean()is_print_string(Node::cerl()) -> boolean()let_arg(Node::cerl()) -> cerl()let_arity(Node::cerl()) -> integer()let_body(Node::cerl()) -> cerl()let_vars(Node::cerl()) -> [cerl()]letrec_body(Node::cerl()) -> cerl()letrec_defs(Node::cerl()) -> [{cerl(), cerl()}]letrec_vars(Node::cerl()) -> [cerl()]list_elements(C_cons::cerl()) -> [cerl()]list_length(Node::cerl()) -> integer()make_data(Type::dtype(), Elements::[cerl()]) -> cerl()make_data_skel(Type::dtype(), Elements::[cerl()]) -> cerl()make_list(List) -> Nodemake_list(List::[cerl()], Tail) -> cerl()make_tree(Type::ctype(), Groups::[[cerl()]]) -> cerl()map_arg(C_literal::c_map() | c_literal()) -> c_map() | c_literal()map_es(C_literal::c_map() | c_literal()) -> [c_map_pair()]map_pair_key(C_map_pair::c_map_pair()) -> cerl()map_pair_op(C_map_pair::c_map_pair()) -> map_op()map_pair_val(C_map_pair::c_map_pair()) -> cerl()meta(Tree::cerl()) -> cerl()module_attrs(Node::cerl()) -> [{cerl(), cerl()}]module_defs(Node::cerl()) -> [{cerl(), cerl()}]module_exports(Node::cerl()) -> [cerl()]module_name(Node::cerl()) -> cerl()module_vars(Node::cerl()) -> [cerl()]pat_list_vars(Patterns::[cerl()]) -> [cerl()]pat_vars(Pattern::cerl()) -> [cerl()]primop_args(Node::cerl()) -> [cerl()]primop_arity(Node::cerl()) -> arity()primop_name(Node::cerl()) -> cerl()receive_action(Node::cerl()) -> cerl()receive_clauses(Node::cerl()) -> [cerl()]receive_timeout(Node::cerl()) -> cerl()seq_arg(Node::cerl()) -> cerl()seq_body(Node::cerl()) -> cerl()set_ann(Node::cerl(), Annotations::[term()]) -> cerl()string_lit(Node::cerl()) -> string()string_val(Node::cerl()) -> string()subtrees(Node::cerl()) -> [[cerl()]]to_records(Tree::cerl()) -> record(record_types())try_arg(Node::cerl()) -> cerl()try_body(Node::cerl()) -> cerl()try_evars(Node::cerl()) -> [cerl()]try_handler(Node::cerl()) -> cerl()try_vars(Node::cerl()) -> [cerl()]tuple_arity(Node::cerl()) -> integer()tuple_es(C_tuple::cerl()) -> [cerl()]type(Node::cerl()) -> atom()unfold_literal(Node::cerl()) -> cerl()update_c_alias(Old::cerl(), Variable::cerl(), Pattern::cerl()) -> cerl()update_c_apply(Old::cerl(), Operator::cerl(), Arguments::[cerl()]) -> cerl()update_c_binary(Old::cerl(), Segments::[cerl()]) -> cerl()update_c_bitstr(Old::cerl(), Value::cerl(), Size::cerl(), Type::cerl(), Flags::cerl()) -> cerl()update_c_bitstr(Old::cerl(), Value::cerl(), Size::cerl(), Unit::cerl(), Type::cerl(), Flags::cerl()) -> cerl()update_c_call(Old::cerl(), Module::cerl(), Name::cerl(), Arguments::[cerl()]) -> cerl()update_c_case(Old::cerl(), Argument::cerl(), Clauses::[cerl()]) -> cerl()update_c_catch(Old::cerl(), Body::cerl()) -> cerl()update_c_clause(Old::cerl(), Patterns::[cerl()], Guard::cerl(), Body::cerl()) -> cerl()update_c_cons(Old::cerl(), Head::cerl(), Tail::cerl()) -> cerl()update_c_cons_skel(Old::cerl(), Head::cerl(), Tail::cerl()) -> cerl()update_c_fname(Old::cerl(), Name::atom()) -> cerl()update_c_fname(Old::cerl(), Name::atom(), Arity::arity()) -> cerl()update_c_fun(Old::cerl(), Variables::[cerl()], Body::cerl()) -> cerl()update_c_let(Node::c_let(), Variables::[cerl()], Argument::cerl(), Body::cerl()) -> c_let()update_c_letrec(Old::cerl(), Definitions::[{cerl(), cerl()}], Body::cerl()) -> cerl()update_c_map(C_map::c_map(), M::cerl(), Es::[cerl()]) -> c_map() | c_literal()update_c_map_pair(Old::c_map_pair(), Op::map_op(), K::cerl(), V::cerl()) -> c_map_pair()update_c_module(Old::cerl(), Name::cerl(), Exports, Attrs::Attributes, Es::Definitions) -> cerl()update_c_primop(Old::cerl(), Name::cerl(), Arguments::[cerl()]) -> cerl()update_c_receive(Old::cerl(), Clauses::[cerl()], Timeout::cerl(), Action::cerl()) -> cerl()update_c_seq(Old::cerl(), Argument::cerl(), Body::cerl()) -> cerl()update_c_try(Old::cerl(), Expression::cerl(), Variables::[cerl()], Body::cerl(), EVars::[cerl()], Handler::cerl()) -> cerl()update_c_tuple(Old::cerl(), Elements::[cerl()]) -> cerl()update_c_tuple_skel(Old::cerl(), Elements::[cerl()]) -> cerl()update_c_values(Old::cerl(), Elements::[cerl()]) -> cerl()update_c_var(Old::cerl(), Name::var_name()) -> cerl()update_data(Old::cerl(), Type::dtype(), Elements::[cerl()]) -> cerl()update_data_skel(Old::cerl(), Type::dtype(), Elements::[cerl()]) -> cerl()update_list(Old::cerl(), List::[cerl()]) -> cerl()update_list(Old::cerl(), List::[cerl()], Tail) -> cerl()update_tree(Old::cerl(), Groups::[[cerl()]]) -> cerl()update_tree(Old::cerl(), Type::ctype(), Groups::[[cerl()]]) -> cerl()values_arity(Node::cerl()) -> integer()values_es(Node::cerl()) -> [cerl()]var_name(Node::cerl()) -> var_name()"
  ],
  [
    "cerl_clauses",
    "any_catchall(Clauses::[cerl()]) -> boolean()eval_guard(Expr::cerl()) -> none | {value, term()}is_catchall(Clause::cerl()) -> boolean()match(Pattern::cerl(), E::Expr) -> none | {true, Bindings} | {false, Bindings}match_list(Patterns::[cerl()], Exprs::[Expr]) -> none | {true, Bindings} | {false, Bindings}reduce(Cs::Clauses) -> {true, {Clause, Bindings}} | {false, Clauses}reduce(Clauses::[Clause], Exprs::[Expr]) -> {true, {Clause, Bindings}} | {false, [Clause]}"
  ],
  [
    "cerl_trees",
    "depth(Tree::cerl()) -> integer()fold(F::Function, Unit::term(), Tree::cerl()) -> term()free_variables(Tree::cerl()) -> [var_name()]get_label(T::cerl:cerl()) -> top | integer()label(T::cerl:cerl()) -> {cerl:cerl(), integer()}label(Tree::cerl(), N::integer()) -> {cerl(), integer()}map(F::Function, Tree::cerl()) -> cerl()mapfold(F::Function, Initial::term(), Tree::cerl()) -> {cerl(), term()}mapfold(Pre, Post, Initial::term(), Tree::cerl()) -> {cerl(), term()}next_free_variable_name(Tree::cerl()) -> var_name()size(Tree::cerl()) -> integer()variables(Tree::cerl()) -> [var_name()]"
  ],
  [
    "code",
    "set_path(Path) -> true | {error, What}get_path() -> Pathadd_path(Dir) -> add_path_ret()add_pathz(Dir) -> add_path_ret()add_patha(Dir) -> add_path_ret()add_paths(Dirs) -> okadd_pathsz(Dirs) -> okadd_pathsa(Dirs) -> okdel_path(NameOrDir) -> boolean() | {error, What}replace_path(Name, Dir) -> true | {error, What}load_file(Module) -> load_ret() load_abs(Filename) -> load_ret() ensure_loaded(Module) -> {module, Module} | {error, What}load_binary(Module, Filename, Binary) -> {module, Module} | {error, What}atomic_load(Modules) -> ok | {error, [{Module, What}]}prepare_loading(Modules) -> {ok, Prepared} | {error, [{Module, What}]}finish_loading(Prepared) -> ok | {error, [{Module, What}]}ensure_modules_loaded(Modules :: [Module]) -> ok | {error, [{Module, What}]}delete(Module) -> boolean()purge(Module) -> boolean()soft_purge(Module) -> boolean()is_loaded(Module) -> {file, Loaded} | falseall_loaded() -> [{Module, Loaded}]which(Module) -> Whichget_object_code(Module) -> {Module, Binary, Filename} | errorroot_dir() -> file:filename() lib_dir() -> file:filename() lib_dir(Name) -> file:filename() | {error, bad_name}lib_dir(Name, SubDir) -> file:filename() | {error, bad_name}compiler_dir() -> file:filename() priv_dir(Name) -> file:filename() | {error, bad_name}objfile_extension() -> nonempty_string()stick_dir(Dir) -> ok | errorunstick_dir(Dir) -> ok | erroris_sticky(Module) -> boolean()where_is_file(Filename) -> non_existing | Absnameclash() -> okmodule_status(Module :: module()) -> not_loaded | loaded | modified | removedmodified_modules() -> [module()]is_module_native(Module) -> true | false | undefinedget_mode() -> embedded | interactive"
  ],
  [
    "common_test",
    "Module:all() -> Tests | {skip,Reason} Module:groups() -> GroupDefsModule:suite() -> [Info] Module:init_per_suite(Config) -> NewConfig | {skip,Reason} | {skip_and_save,Reason,SaveConfig}Module:end_per_suite(Config) -> term() | {save_config,SaveConfig}Module:group(GroupName) -> [Info] Module:init_per_group(GroupName, Config) -> NewConfig | {skip,Reason}Module:end_per_group(GroupName, Config) -> term() | {return_group_result,Status}Module:init_per_testcase(TestCase, Config) -> NewConfig | {fail,Reason} | {skip,Reason}Module:end_per_testcase(TestCase, Config) -> term() | {fail,Reason} | {save_config,SaveConfig}Module:Testcase() -> [Info] Module:Testcase(Config) -> term() | {skip,Reason} | {comment,Comment} | {save_config,SaveConfig} | {skip_and_save,Reason,SaveConfig} | exit() "
  ],
  [
    "compile",
    "env_compiler_options()file(File)file(File, Options) -> CompRetforms(Forms)forms(Forms, Options) -> CompRetformat_error(ErrorDescriptor) -> chars()output_generated(Options) -> true | falsenoenv_file(File, Options) -> CompRetnoenv_forms(Forms, Options) -> CompRetnoenv_output_generated(Options) -> true | false"
  ],
  ["config"],
  [
    "counters",
    "new(Size, Opts) -> counters_ref() get(Ref, Ix) -> integer()add(Ref, Ix, Incr) -> oksub(Ref, Ix, Decr) -> okput(Ref, Ix, Value) -> okinfo(Ref) -> Info"
  ],
  [
    "cover",
    "start() -> {ok,Pid} | {error,Reason}local_only() -> ok | {error,too_late}start(Nodes) -> {ok,StartedNodes} | {error,not_main_node} | {error,local_only}compile(ModFiles) -> Result | [Result]compile(ModFiles, Options) -> Result | [Result]compile_module(ModFiles) -> Result | [Result]compile_module(ModFiles, Options) -> Result | [Result]compile_directory() -> [Result] | {error,Reason}compile_directory(Dir) -> [Result] | {error,Reason}compile_directory(Dir, Options) -> [Result] | {error,Reason}compile_beam(ModFiles) -> Result | [Result]compile_beam_directory() -> [Result] | {error,Reason}compile_beam_directory(Dir) -> [Result] | {error,Reason}analyse() -> {result,Ok,Fail} | {error,not_main_node}analyse(Modules) -> OneResult | {result,Ok,Fail} | {error,not_main_node}analyse(Analysis) -> {result,Ok,Fail} | {error,not_main_node}analyse(Level) -> {result,Ok,Fail} | {error,not_main_node}analyse(Modules, Analysis) -> OneResult | {result,Ok,Fail} | {error,not_main_node}analyse(Modules, Level) -> OneResult | {result,Ok,Fail} | {error,not_main_node}analyse(Analysis, Level) -> {result,Ok,Fail} | {error,not_main_node}analyse(Modules, Analysis, Level) -> OneResult | {result,Ok,Fail} | {error,not_main_node}analyse_to_file() -> {result,Ok,Fail} | {error,not_main_node}analyse_to_file(Modules) -> Answer | {result,Ok,Fail} | {error,not_main_node}analyse_to_file(Options) -> {result,Ok,Fail} | {error,not_main_node}analyse_to_file(Modules,Options) -> Answer | {result,Ok,Fail} | {error,not_main_node}async_analyse_to_file(Module) -> async_analyse_to_file(Module,Options) -> async_analyse_to_file(Module, OutFile) -> async_analyse_to_file(Module, OutFile, Options) -> pid()modules() -> [Module] | {error,not_main_node}imported_modules() -> [Module] | {error,not_main_node}imported() -> [File] | {error,not_main_node}which_nodes() -> [Node] | {error,not_main_node}is_compiled(Module) -> {file,File} | false | {error,not_main_node}reset(Module) ->reset() -> ok | {error,not_main_node}export(ExportFile)export(ExportFile,Module) -> ok | {error,Reason}import(ExportFile) -> ok | {error,Reason}stop() -> ok | {error,not_main_node}stop(Nodes) -> ok | {error,not_main_node}flush(Nodes) -> ok | {error,not_main_node}"
  ],
  [
    "cprof",
    "analyse() -> {AllCallCount, ModAnalysisList}analyse(Limit) -> {AllCallCount, ModAnalysisList}analyse(Mod) -> ModAnalysisanalyse(Mod, Limit) -> ModAnalysispause() -> integer()pause(FuncSpec) -> integer()pause(Mod, Func) -> integer()pause(Mod, Func, Arity) -> integer()restart() -> integer()restart(FuncSpec) -> integer()restart(Mod, Func) -> integer()restart(Mod, Func, Arity) -> integer()start() -> integer()start(FuncSpec) -> integer()start(Mod, Func) -> integer()start(Mod, Func, Arity) -> integer()stop() -> integer()stop(FuncSpec) -> integer()stop(Mod, Func) -> integer()stop(Mod, Func, Arity) -> integer()"
  ],
  [
    "cpu_sup",
    "nprocs() -> UnixProcesses | {error, Reason}avg1() -> SystemLoad | {error, Reason}avg5() -> SystemLoad | {error, Reason}avg15() -> SystemLoad | {error, Reason}util() -> CpuUtil | {error, Reason}util(Opts) -> UtilSpec | {error, Reason}"
  ],
  ["crashdump_viewer", "start() -> okstart(File) -> okstop() -> ok"],
  [
    "crypto",
    "crypto_init(Cipher, Key, EncryptFlag) -> State | descriptive_error() crypto_init(Cipher, Key, IV, EncryptFlag) -> State | descriptive_error() crypto_update(State, Data) -> Result | descriptive_error() crypto_dyn_iv_init(Cipher, Key, EncryptFlag) -> State | descriptive_error() crypto_dyn_iv_update(State, Data, IV) -> Result | descriptive_error() crypto_one_time(Cipher, Key, Data, EncryptFlag) -> Result | descriptive_error() crypto_one_time(Cipher, Key, IV, Data, EncryptFlag) -> Result | descriptive_error() crypto_one_time_aead(Cipher, Key, IV, InText, AAD, EncFlag :: true) -> Result | descriptive_error() crypto_one_time_aead(Cipher, Key, IV, InText, AAD, TagOrTagLength, EncFlag) -> Result | descriptive_error() supports(Type) -> Supportmac(Type :: poly1305, Key, Data) -> Mac | descriptive_error() mac(Type, SubType, Key, Data) -> Mac | descriptive_error() macN(Type :: poly1305, Key, Data, MacLength) -> Mac | descriptive_error() macN(Type, SubType, Key, Data, MacLength) -> Mac | descriptive_error() mac_init(Type :: poly1305, Key) -> State | descriptive_error() mac_init(Type, SubType, Key) -> State | descriptive_error() mac_update(State0, Data) -> State | descriptive_error() mac_final(State) -> Mac | descriptive_error() mac_finalN(State, MacLength) -> Mac | descriptive_error() bytes_to_integer(Bin :: binary()) -> integer()compute_key(Type, OthersPublicKey, MyPrivateKey, Params) -> SharedSecretexor(Bin1 :: iodata(), Bin2 :: iodata()) -> binary()generate_key(Type, Params) -> {PublicKey, PrivKeyOut}generate_key(Type, Params, PrivKeyIn) -> {PublicKey, PrivKeyOut}hash(Type, Data) -> Digesthash_init(Type) -> Statehash_update(State, Data) -> NewStatehash_final(State) -> Digestinfo_fips() -> not_supported | not_enabled | enabledenable_fips_mode(Enable) -> Resultinfo_lib() -> [{Name, VerNum, VerStr}]hash_info(Type) -> Result | run_time_error() cipher_info(Type) -> Result | run_time_error() mod_pow(N, P, M) -> Resultnext_iv(Type :: cbc_cipher(), Data) -> NextIVecnext_iv(Type :: des_cfb, Data, IVec) -> NextIVecprivate_decrypt(Algorithm, CipherText, PrivateKey, Options) -> PlainTextprivate_encrypt(Algorithm, PlainText, PrivateKey, Options) -> CipherTextpublic_decrypt(Algorithm, CipherText, PublicKey, Options) -> PlainTextpublic_encrypt(Algorithm, PlainText, PublicKey, Options) -> CipherTextrand_seed(Seed :: binary()) -> okstart() -> ok | {error, Reason :: term()}stop() -> ok | {error, Reason :: term()}strong_rand_bytes(N :: integer() >= 0) -> binary()rand_seed() -> rand:state() rand_seed_s() -> rand:state() ec_curves() -> [EllipticCurve]ec_curve(CurveName) -> ExplicitCurvesign(Algorithm, DigestType, Msg, Key) -> Signaturesign(Algorithm, DigestType, Msg, Key, Options) -> Signatureverify(Algorithm, DigestType, Msg, Signature, Key) -> Resultverify(Algorithm, DigestType, Msg, Signature, Key, Options) -> Resultprivkey_to_pubkey(Type, EnginePrivateKeyRef) -> PublicKeyengine_get_all_methods() -> Resultengine_load(EngineId, PreCmds, PostCmds) -> Resultengine_load(EngineId, PreCmds, PostCmds, EngineMethods) -> Resultengine_unload(Engine) -> Resultengine_by_id(EngineId) -> Resultengine_ctrl_cmd_string(Engine, CmdName, CmdArg) -> Resultengine_ctrl_cmd_string(Engine, CmdName, CmdArg, Optional) -> Resultengine_add(Engine) -> Resultengine_remove(Engine) -> Resultengine_get_id(Engine) -> EngineIdengine_get_name(Engine) -> EngineNameengine_list() -> Resultensure_engine_loaded(EngineId, LibPath) -> Resultensure_engine_loaded(EngineId, LibPath, EngineMethods) -> Resultensure_engine_unloaded(Engine) -> Resultensure_engine_unloaded(Engine, EngineMethods) -> Resultblock_encrypt(Type :: block_cipher_without_iv(), Key :: key(), PlainText :: iodata()) -> binary() | run_time_error() block_decrypt(Type :: block_cipher_without_iv(), Key :: key(), Data :: iodata()) -> binary() | run_time_error() stream_init(Type, Key) -> State | run_time_error() stream_init(Type, Key, IVec) -> State | run_time_error() stream_encrypt(State, PlainText) -> {NewState, CipherText} | run_time_error() stream_decrypt(State, CipherText) -> {NewState, PlainText} | run_time_error() supports() -> [Support]hmac(Type, Key, Data) -> Machmac(Type, Key, Data, MacLength) -> Machmac_init(Type, Key) -> Statehmac_update(State, Data) -> NewStatehmac_final(State) -> Machmac_final_n(State, HashLen) -> Maccmac(Type, Key, Data) -> Maccmac(Type, Key, Data, MacLength) -> Macpoly1305(Key :: iodata(), Data :: iodata()) -> Mac",
    "rand_uniform(Lo, Hi) -> Nrand_seed_alg(Alg) -> rand:state()rand_seed_alg(Alg, Seed) -> rand:state()rand_seed_alg_s(Alg) -> rand:state()rand_seed_alg_s(Alg, Seed) -> rand:state()block_encrypt(Type, Key, Ivec, PlainText) -> CipherText | Errorblock_encrypt(AeadType, Key, Ivec, {AAD, PlainText}) -> {CipherText, CipherTag} | Errorblock_encrypt(aes_gcm | aes_ccm, Key, Ivec, {AAD, PlainText, TagLength}) -> {CipherText, CipherTag} | Error block_decrypt(Type, Key, Ivec, CipherText) -> PlainText | Errorblock_decrypt(AeadType, Key, Ivec, {AAD, CipherText, CipherTag}) -> PlainText | Error"
  ],
  ["crypto_app"],
  [
    "ct",
    "abort_current_testcase(Reason) -> ok | {error, ErrorReason}add_config(Callback, Config) -> ok | {error, Reason}break(Comment) -> ok | {error, Reason}break(TestCase, Comment) -> ok | {error, Reason}capture_get() -> ListOfStringscapture_get(ExclCategories) -> ListOfStringscapture_start() -> okcapture_stop() -> okcomment(Comment) -> okcomment(Format, Args) -> okcontinue() -> okcontinue(TestCase) -> okdecrypt_config_file(EncryptFileName, TargetFileName) -> ok | {error, Reason}decrypt_config_file(EncryptFileName, TargetFileName, KeyOrFile) -> ok | {error, Reason}encrypt_config_file(SrcFileName, EncryptFileName) -> ok | {error, Reason}encrypt_config_file(SrcFileName, EncryptFileName, KeyOrFile) -> ok | {error, Reason}fail(Reason) -> okfail(Format, Args) -> okget_config(Required) -> Valueget_config(Required, Default) -> Valueget_config(Required, Default, Opts) -> ValueOrElementget_event_mgr_ref() -> EvMgrRefget_progname() -> string()get_status() -> TestStatus | {error, Reason} | no_tests_runningget_target_name(Handle) -> {ok, TargetName} | {error, Reason}get_testspec_terms() -> TestSpecTerms | undefinedget_testspec_terms(Tags) -> TestSpecTerms | undefinedget_timetrap_info() -> {Time, {Scaling,ScaleVal}}get_verbosity(Category) -> Level | undefinedinstall(Opts) -> ok | {error, Reason}listenv(Telnet) -> [Env]log(Format) -> oklog(X1, X2) -> oklog(X1, X2, X3) -> oklog(X1, X2, X3, X4) -> oklog(Category, Importance, Format, FormatArgs, Opts) -> okmake_priv_dir() -> ok | {error, Reason}notify(Name, Data) -> okpal(Format) -> okpal(X1, X2) -> okpal(X1, X2, X3) -> okpal(X1, X2, X3, X4) -> okpal(Category, Importance, Format, FormatArgs, Opts) -> okparse_table(Data) -> {Heading, Table}print(Format) -> okprint(X1, X2) -> okprint(X1, X2, X3) -> okprint(X1, X2, X3, X4) -> okprint(Category, Importance, Format, FormatArgs, Opts) -> okreload_config(Required) -> ValueOrElement | {error, Reason}remaining_test_procs() -> {TestProcs,SharedGL,OtherGLs}remove_config(Callback, Config) -> okrequire(Required) -> ok | {error, Reason}require(Name, Required) -> ok | {error, Reason}run(TestDirs) -> Resultrun(TestDir, Suite) -> Resultrun(TestDir, Suite, Cases) -> Resultrun_test(Opts) -> Resultrun_testspec(TestSpec) -> Resultset_verbosity(Category, Level) -> oksleep(Time) -> okstart_interactive() -> okstep(TestDir, Suite, Case) -> Resultstep(TestDir, Suite, Case, Opts) -> Resultstop_interactive() -> oksync_notify(Name, Data) -> oktestcases(TestDir, Suite) -> Testcases | {error, Reason}timetrap(Time) -> okuserdata(TestDir, Suite) -> SuiteUserData | {error, Reason}userdata(TestDir, Suite, Case::GroupOrCase) -> TCUserData | {error, Reason}"
  ],
  [
    "ct_cover",
    "add_nodes(Nodes) -> {ok, StartedNodes} | {error, Reason}cross_cover_analyse(Level, Tests) -> okremove_nodes(Nodes) -> ok | {error, Reason}"
  ],
  [
    "ct_ftp",
    "cd(Connection, Dir) -> ok | {error, Reason}close(Connection) -> ok | {error, Reason}delete(Connection, File) -> ok | {error, Reason}get(KeyOrName, RemoteFile, LocalFile) -> ok | {error, Reason}ls(Connection, Dir) -> {ok, Listing} | {error, Reason}open(KeyOrName) -> {ok, Handle} | {error, Reason}put(KeyOrName, LocalFile, RemoteFile) -> ok | {error, Reason}recv(Connection, RemoteFile) -> ok | {error, Reason}recv(Connection, RemoteFile, LocalFile) -> ok | {error, Reason}send(Connection, LocalFile) -> ok | {error, Reason}send(Connection, LocalFile, RemoteFile) -> ok | {error, Reason}type(Connection, Type) -> ok | {error, Reason}"
  ],
  [
    "ct_hooks",
    "Module:init(Id, Opts) -> {ok, State} | {ok, State, Priority}Module:post_groups(SuiteName, GroupDefs) -> NewGroupDefsModule:post_all(SuiteName, Return, GroupDefs) -> NewReturnModule:pre_init_per_suite(SuiteName, InitData, CTHState) -> ResultModule:post_init_per_suite(SuiteName, Config, Return, CTHState) -> ResultModule:pre_init_per_group(SuiteName, GroupName, InitData, CTHState) -> ResultModule:post_init_per_group(SuiteName, GroupName, Config, Return, CTHState) -> ResultModule:pre_init_per_testcase(SuiteName, TestcaseName, InitData, CTHState) -> ResultModule:post_init_per_testcase(SuiteName, TestcaseName, Config, Return, CTHState) -> ResultModule:pre_end_per_testcase(SuiteName, TestcaseName, EndData, CTHState) -> ResultModule:post_end_per_testcase(SuiteName, TestcaseName, Config, Return, CTHState) -> ResultModule:pre_end_per_group(SuiteName, GroupName, EndData, CTHState) -> ResultModule:post_end_per_group(SuiteName, GroupName, Config, Return, CTHState) -> ResultModule:pre_end_per_suite(SuiteName, EndData, CTHState) -> ResultModule:post_end_per_suite(SuiteName, Config, Return, CTHState) -> ResultModule:on_tc_fail(SuiteName, TestName, Reason, CTHState) -> NewCTHStateModule:on_tc_skip(SuiteName, TestName, Reason, CTHState) -> NewCTHStateModule:terminate(CTHState)Module:id(Opts) -> Id"
  ],
  [
    "ct_master",
    "abort() -> okabort(Nodes) -> okbasic_html(Bool) -> okget_event_mgr_ref() -> MasterEvMgrRefprogress() -> [{Node, Status}]run(TestSpecs) -> okrun(TestSpecs, InclNodes, ExclNodes) -> okrun(TestSpecs, AllowUserTerms, InclNodes, ExclNodes) -> okrun_on_node(TestSpecs, Node) -> okrun_on_node(TestSpecs, AllowUserTerms, Node) -> okrun_test(Node, Opts) -> ok"
  ],
  [
    "ct_netconfc",
    "action(Client, Action) -> Resultaction(Client, Action, Timeout) -> Resultclose_session(Client) -> Resultclose_session(Client, Timeout) -> Resultconnect(Options) -> Resultconnect(KeyOrName, ExtraOptions) -> Resultcopy_config(Client, Target, Source) -> Resultcopy_config(Client, Target, Source, Timeout) -> Resultcreate_subscription(Client, Values) -> Resultcreate_subscription(Client, Values, Timeout) -> Resultdelete_config(Client, Target) -> Resultdelete_config(Client, Target, Timeout) -> Resultdisconnect(Conn) -> ok | {error, error_reason()}edit_config(Client, Target, Config) -> Resultedit_config(Client, Target, Config, OptParams) -> Resultedit_config(Client, Target, Config, Timeout) -> Resultedit_config(Client, Target, Config, OptParams, Timeout) -> Resultget(Client, Filter) -> Resultget(Client, Filter, Timeout) -> Resultget_capabilities(Client) -> Resultget_capabilities(Client, Timeout) -> Resultget_config(Client, Source, Filter) -> Resultget_config(Client, Source, Filter, Timeout) -> Resultget_event_streams(Client) -> Resultget_event_streams(Client, Timeout) -> Resultget_event_streams(Client, Streams) -> Resultget_event_streams(Client, Streams, Timeout) -> Resultget_session_id(Client) -> Resultget_session_id(Client, Timeout) -> Resulthello(Client) -> Resulthello(Client, Timeout) -> Resulthello(Client, Options, Timeout) -> Resultkill_session(Client, SessionId) -> Resultkill_session(Client, SessionId, Timeout) -> Resultlock(Client, Target) -> Resultlock(Client, Target, Timeout) -> Resultonly_open(Options) -> Resultonly_open(KeyOrName, ExtraOptions) -> Resultopen(Options) -> Resultopen(KeyOrName, ExtraOption) -> Resultsend(Client, SimpleXml) -> Resultsend(Client, SimpleXml, Timeout) -> Resultsend_rpc(Client, SimpleXml) -> Resultsend_rpc(Client, SimpleXml, Timeout) -> Resultsession(Conn) -> Resultsession(Conn, Options) -> Resultsession(KeyOrName, Conn) -> Resultsession(KeyOrName, Conn, Options) -> Resultunlock(Client, Target) -> Resultunlock(Client, Target, Timeout) -> Result"
  ],
  [
    "ct_property_test",
    "init_per_suite(Config) -> Config | {skip, Reason}quickcheck(Property, Config) -> true | {fail, Reason}"
  ],
  [
    "ct_rpc",
    "app_node(App, Candidates) -> NodeNameapp_node(App, Candidates, FailOnBadRPC) -> NodeNameapp_node(App, Candidates, FailOnBadRPC, Cookie) -> NodeNamecall(Node, Module, Function, Args) -> term() | {badrpc, Reason}call(Node, Module, Function, Args, TimeOut) -> term() | {badrpc, Reason}call(Node, Module, Function, Args, TimeOut, Cookie) -> term() | {badrpc, Reason}cast(Node, Module, Function, Args) -> okcast(Node, Module, Function, Args, Cookie) -> ok"
  ],
  ["ct_run"],
  [
    "ct_slave",
    "start(Node) -> Resultstart(HostOrNode, NodeOrOpts) -> Resultstart(Host, Node, Opts) -> Resultstop(Node) -> Resultstop(Host, Node) -> Result"
  ],
  [
    "ct_snmp",
    "get_next_values(Agent, Oids, MgrAgentConfName) -> SnmpReplyget_values(Agent, Oids, MgrAgentConfName) -> SnmpReplyload_mibs(Mibs) -> ok | {error, Reason}register_agents(MgrAgentConfName, ManagedAgents) -> ok | {error, Reason}register_users(MgrAgentConfName, Users) -> ok | {error, Reason}register_usm_users(MgrAgentConfName, UsmUsers) -> ok | {error, Reason}set_info(Config) -> [{Agent, OldVarsAndVals, NewVarsAndVals}]set_values(Agent, VarsAndVals, MgrAgentConfName, Config) -> SnmpReplystart(Config, MgrAgentConfName) -> okstart(Config, MgrAgentConfName, SnmpAppConfName) -> okstop(Config) -> okunload_mibs(Mibs) -> ok | {error, Reason}unregister_agents(MgrAgentConfName) -> okunregister_agents(MgrAgentConfName, ManagedAgents) -> okunregister_users(MgrAgentConfName) -> okunregister_users(MgrAgentConfName, Users) -> okunregister_usm_users(MgrAgentConfName) -> okunregister_usm_users(MgrAgentConfName, UsmUsers) -> ok"
  ],
  [
    "ct_ssh",
    "apread(SSH, Handle, Position, Length) -> Resultapread(SSH, Server, Handle, Position, Length) -> Resultapwrite(SSH, Handle, Position, Data) -> Resultapwrite(SSH, Server, Handle, Position, Data) -> Resultaread(SSH, Handle, Len) -> Resultaread(SSH, Server, Handle, Len) -> Resultawrite(SSH, Handle, Data) -> Resultawrite(SSH, Server, Handle, Data) -> Resultclose(SSH, Handle) -> Resultclose(SSH, Server, Handle) -> Resultconnect(KeyOrName) -> {ok, Handle} | {error, Reason}connect(KeyOrName, ConnType) -> {ok, Handle} | {error, Reason}connect(KeyOrName, ConnType, ExtraOpts) -> {ok, Handle} | {error, Reason}del_dir(SSH, Name) -> Resultdel_dir(SSH, Server, Name) -> Resultdelete(SSH, Name) -> Resultdelete(SSH, Server, Name) -> Resultdisconnect(SSH) -> ok | {error, Reason}exec(SSH, Command) -> {ok, Data} | {error, Reason}exec(SSH, Command, Timeout) -> {ok, Data} | {error, Reason}exec(SSH, ChannelId, Command, Timeout) -> {ok, Data} | {error, Reason}get_file_info(SSH, Handle) -> Resultget_file_info(SSH, Server, Handle) -> Resultlist_dir(SSH, Path) -> Resultlist_dir(SSH, Server, Path) -> Resultmake_dir(SSH, Name) -> Resultmake_dir(SSH, Server, Name) -> Resultmake_symlink(SSH, Name, Target) -> Resultmake_symlink(SSH, Server, Name, Target) -> Resultopen(SSH, File, Mode) -> Resultopen(SSH, Server, File, Mode) -> Resultopendir(SSH, Path) -> Resultopendir(SSH, Server, Path) -> Resultposition(SSH, Handle, Location) -> Resultposition(SSH, Server, Handle, Location) -> Resultpread(SSH, Handle, Position, Length) -> Resultpread(SSH, Server, Handle, Position, Length) -> Resultpwrite(SSH, Handle, Position, Data) -> Resultpwrite(SSH, Server, Handle, Position, Data) -> Resultread(SSH, Handle, Len) -> Resultread(SSH, Server, Handle, Len) -> Resultread_file(SSH, File) -> Resultread_file(SSH, Server, File) -> Resultread_file_info(SSH, Name) -> Resultread_file_info(SSH, Server, Name) -> Resultread_link(SSH, Name) -> Resultread_link(SSH, Server, Name) -> Resultread_link_info(SSH, Name) -> Resultread_link_info(SSH, Server, Name) -> Resultreceive_response(SSH, ChannelId) -> {ok, Data} | {error, Reason}receive_response(SSH, ChannelId, End) -> {ok, Data} | {error, Reason}receive_response(SSH, ChannelId, End, Timeout) -> {ok, Data} | {timeout, Data} | {error, Reason}rename(SSH, OldName, NewName) -> Resultrename(SSH, Server, OldName, NewName) -> Resultsend(SSH, ChannelId, Data) -> ok | {error, Reason}send(SSH, ChannelId, Data, Timeout) -> ok | {error, Reason}send(SSH, ChannelId, Type, Data, Timeout) -> ok | {error, Reason}send_and_receive(SSH, ChannelId, Data) -> {ok, Data} | {error, Reason}send_and_receive(SSH, ChannelId, Data, End) -> {ok, Data} | {error, Reason}send_and_receive(SSH, ChannelId, Data, End, Timeout) -> {ok, Data} | {error, Reason}send_and_receive(SSH, ChannelId, Type, Data, End, Timeout) -> {ok, Data} | {error, Reason}session_close(SSH, ChannelId) -> ok | {error, Reason}session_open(SSH) -> {ok, ChannelId} | {error, Reason}session_open(SSH, Timeout) -> {ok, ChannelId} | {error, Reason}sftp_connect(SSH) -> {ok, Server} | {error, Reason}shell(SSH, ChannelId) -> ok | {error, Reason}shell(SSH, ChannelId, Timeout) -> ok | {error, Reason}subsystem(SSH, ChannelId, Subsystem) -> Status | {error, Reason}subsystem(SSH, ChannelId, Subsystem, Timeout) -> Status | {error, Reason}write(SSH, Handle, Data) -> Resultwrite(SSH, Server, Handle, Data) -> Resultwrite_file(SSH, File, Iolist) -> Resultwrite_file(SSH, Server, File, Iolist) -> Resultwrite_file_info(SSH, Name, Info) -> Resultwrite_file_info(SSH, Server, Name, Info) -> Result"
  ],
  [
    "ct_telnet",
    "close(Connection) -> ok | {error, Reason}cmd(Connection, Cmd) -> {ok, Data} | {error, Reason}cmd(Connection, Cmd, Opts) -> {ok, Data} | {error, Reason}cmdf(Connection, CmdFormat, Args) -> {ok, Data} | {error, Reason}cmdf(Connection, CmdFormat, Args, Opts) -> {ok, Data} | {error, Reason}expect(Connection, Patterns) -> term()expect(Connection, Patterns, Opts) -> {ok, Match} | {ok, MatchList, HaltReason} | {error, Reason}get_data(Connection) -> {ok, Data} | {error, Reason}open(Name) -> {ok, Handle} | {error, Reason}open(Name, ConnType) -> {ok, Handle} | {error, Reason}open(KeyOrName, ConnType, TargetMod) -> {ok, Handle} | {error, Reason}open(KeyOrName, ConnType, TargetMod, Extra) -> {ok, Handle} | {error, Reason}send(Connection, Cmd) -> ok | {error, Reason}send(Connection, Cmd, Opts) -> ok | {error, Reason}sendf(Connection, CmdFormat, Args) -> ok | {error, Reason}sendf(Connection, CmdFormat, Args, Opts) -> ok | {error, Reason}"
  ],
  [
    "ct_testspec",
    "get_tests(SpecsIn) -> {ok, [{Specs,Tests}]} | {error, Reason}"
  ],
  [
    "dbg",
    "fun2ms(LiteralFun) -> MatchSpech() -> ok h(Item) -> ok p(Item) -> {ok, MatchDesc} | {error, term()} p(Item, Flags) -> {ok, MatchDesc} | {error, term()}c(Mod, Fun, Args)c(Mod, Fun, Args, Flags)i() -> oktp(Module,MatchSpec)tp(Module,Function,MatchSpec)tp(Module, Function, Arity, MatchSpec)tp({Module, Function, Arity}, MatchSpec) -> {ok, MatchDesc} | {error, term()}tpl(Module,MatchSpec)tpl(Module,Function,MatchSpec)tpl(Module, Function, Arity, MatchSpec)tpl({Module, Function, Arity}, MatchSpec) -> {ok, MatchDesc} | {error, term()}tpe(Event, MatchSpec) -> {ok, MatchDesc} | {error, term()}ctp()ctp(Module)ctp(Module, Function)ctp(Module, Function, Arity)ctp({Module, Function, Arity}) -> {ok, MatchDesc} | {error, term()}ctpl()ctpl(Module)ctpl(Module, Function)ctpl(Module, Function, Arity)ctpl({Module, Function, Arity}) -> {ok, MatchDesc} | {error, term()}ctpg()ctpg(Module)ctpg(Module, Function)ctpg(Module, Function, Arity)ctpg({Module, Function, Arity}) -> {ok, MatchDesc} | {error, term()}ctpe(Event) -> {ok, MatchDesc} | {error, term()}ltp() -> okdtp() -> okdtp(N) -> okwtp(Name) -> ok | {error, IOError}rtp(Name) -> ok | {error, Error}n(Nodename) -> {ok, Nodename} | {error, Reason}cn(Nodename) -> okln() -> oktracer() -> {ok, pid()} | {error, already_started}tracer(Type, Data) -> {ok, pid()} | {error, Error}tracer(Nodename, Type, Data) -> {ok, Nodename} | {error, Reason}trace_port(Type, Parameters) -> fun()flush_trace_port()flush_trace_port(Nodename) -> ok | {error, Reason}trace_port_control(Operation)trace_port_control(Nodename,Operation) -> ok | {ok, Result} | {error, Reason}trace_client(Type, Parameters) -> pid()trace_client(Type, Parameters, HandlerSpec) -> pid()stop_trace_client(Pid) -> okget_tracer()get_tracer(Nodename) -> {ok, Tracer}stop() -> okstop_clear() -> ok"
  ],
  [
    "debugger",
    "start()start(File)start(Mode)start(Mode, File)quick(Module, Name, Args)"
  ],
  [
    "dets",
    "all() -> [tab_name()]bchunk(Name, Continuation) -> {Continuation2, Data} | '$end_of_table' | {error, Reason}close(Name) -> ok | {error, Reason}delete(Name, Key) -> ok | {error, Reason}delete_all_objects(Name) -> ok | {error, Reason}delete_object(Name, Object) -> ok | {error, Reason}first(Name) -> Key | '$end_of_table'foldl(Function, Acc0, Name) -> Acc | {error, Reason}foldr(Function, Acc0, Name) -> Acc | {error, Reason}from_ets(Name, EtsTab) -> ok | {error, Reason}info(Name) -> InfoList | undefinedinfo(Name, Item) -> Value | undefinedinit_table(Name, InitFun) -> ok | {error, Reason}init_table(Name, InitFun, Options) -> ok | {error, Reason}insert(Name, Objects) -> ok | {error, Reason}insert_new(Name, Objects) -> boolean() | {error, Reason}is_compatible_bchunk_format(Name, BchunkFormat) -> boolean()is_dets_file(Filename) -> boolean() | {error, Reason}lookup(Name, Key) -> Objects | {error, Reason}match(Continuation) -> {[Match], Continuation2} | '$end_of_table' | {error, Reason}match(Name, Pattern) -> [Match] | {error, Reason}match(Name, Pattern, N) -> {[Match], Continuation} | '$end_of_table' | {error, Reason}match_delete(Name, Pattern) -> ok | {error, Reason}match_object(Continuation) -> {Objects, Continuation2} | '$end_of_table' | {error, Reason}match_object(Name, Pattern) -> Objects | {error, Reason}match_object(Name, Pattern, N) -> {Objects, Continuation} | '$end_of_table' | {error, Reason}member(Name, Key) -> boolean() | {error, Reason}next(Name, Key1) -> Key2 | '$end_of_table'open_file(Filename) -> {ok, Reference} | {error, Reason}open_file(Name, Args) -> {ok, Name} | {error, Reason}pid2name(Pid) -> {ok, Name} | undefinedrepair_continuation(Continuation, MatchSpec) -> Continuation2safe_fixtable(Name, Fix) -> okselect(Continuation) -> {Selection, Continuation2} | '$end_of_table' | {error, Reason}select(Name, MatchSpec) -> Selection | {error, Reason}select(Name, MatchSpec, N) -> {Selection, Continuation} | '$end_of_table' | {error, Reason}select_delete(Name, MatchSpec) -> N | {error, Reason}slot(Name, I) -> '$end_of_table' | Objects | {error, Reason}sync(Name) -> ok | {error, Reason}table(Name) -> QueryHandletable(Name, Options) -> QueryHandleto_ets(Name, EtsTab) -> EtsTab | {error, Reason}traverse(Name, Fun) -> Return | {error, Reason}update_counter(Name, Key, Increment) -> Result"
  ],
  [
    "dialyzer",
    "format_warning(Msg) -> string()format_warning(Msg, Options) -> string()gui() -> ok | {error, Msg}gui(OptList) -> ok | {error, Msg}plt_info(string()) -> {'ok', [{atom(), any()}]} | {'error', atom()}run(OptList) -> Warnings"
  ],
  [
    "diameter",
    "add_transport(SvcName, {connect|listen, [Opt]}) -> {ok, Ref} | {error, Reason}call(SvcName, App, Request, [Opt]) -> Answer | ok | {error, Reason}origin_state_id() -> Unsigned32()remove_transport(SvcName, Pred) -> ok | {error, Reason}service_info(SvcName, Info) -> term()services() -> [SvcName]session_id(Ident) -> OctetString()start() -> ok | {error, Reason}start_service(SvcName, Options) -> ok | {error, Reason}stop() -> ok | {error, Reason}stop_service(SvcName) -> ok | {error, Reason}subscribe(SvcName) -> trueunsubscribe(SvcName) -> true"
  ],
  [
    "diameter_app",
    "Mod:peer_up(SvcName, Peer, State) -> NewStateMod:peer_down(SvcName, Peer, State) -> NewStateMod:pick_peer(LocalCandidates, RemoteCandidates, SvcName, State) -> Selection | falseMod:prepare_request(Packet, SvcName, Peer) -> ActionMod:prepare_retransmit(Packet, SvcName, Peer) -> ActionMod:handle_answer(Packet, Request, SvcName, Peer) -> ResultMod:handle_error(Reason, Request, SvcName, Peer) -> ResultMod:handle_request(Packet, SvcName, Peer) -> Action"
  ],
  ["diameter_codec", "decode(Mod, Bin) -> Pktencode(Mod, Msg) -> Pkt"],
  ["diameter_dict"],
  [
    "diameter_make",
    "codec(File :: iolist() | binary(), [Opt]) -> ok | {ok, [Out]} | {error, Reason}format(Parsed) -> iolist()flatten(Parsed) -> term()format_error(Reason) -> string()"
  ],
  [
    "diameter_sctp",
    "start({Type, Ref}, Svc, [Opt]) -> {ok, Pid, [LAddr]} | {error, Reason}"
  ],
  [
    "diameter_tcp",
    "start({Type, Ref}, Svc, [Opt]) -> {ok, Pid} | {ok, Pid, [LAddr]} | {error, Reason}"
  ],
  [
    "diameter_transport",
    "Mod:start({Type, Ref}, Svc, Config) -> {ok, Pid} | {ok, Pid, LAddrs} | {error, Reason}"
  ],
  ["diameterc"],
  [
    "dict",
    "append(Key, Value, Dict1) -> Dict2append_list(Key, ValList, Dict1) -> Dict2erase(Key, Dict1) -> Dict2fetch(Key, Dict) -> Valuefetch_keys(Dict) -> Keystake(Key, Dict) -> {Value, Dict1} | errorfilter(Pred, Dict1) -> Dict2find(Key, Dict) -> {ok, Value} | errorfold(Fun, Acc0, Dict) -> Acc1from_list(List) -> Dictis_empty(Dict) -> boolean()is_key(Key, Dict) -> boolean()map(Fun, Dict1) -> Dict2merge(Fun, Dict1, Dict2) -> Dict3new() -> dict() size(Dict) -> integer() >= 0store(Key, Value, Dict1) -> Dict2to_list(Dict) -> Listupdate(Key, Fun, Dict1) -> Dict2update(Key, Fun, Initial, Dict1) -> Dict2update_counter(Key, Increment, Dict1) -> Dict2"
  ],
  [
    "digraph",
    "add_edge(G, V1, V2) -> edge() | {error, add_edge_err_rsn()}add_edge(G, V1, V2, Label) -> edge() | {error, add_edge_err_rsn()}add_edge(G, E, V1, V2, Label) -> edge() | {error, add_edge_err_rsn()}add_vertex(G) -> vertex() add_vertex(G, V) -> vertex() add_vertex(G, V, Label) -> vertex() del_edge(G, E) -> truedel_edges(G, Edges) -> truedel_path(G, V1, V2) -> truedel_vertex(G, V) -> truedel_vertices(G, Vertices) -> truedelete(G) -> trueedge(G, E) -> {E, V1, V2, Label} | falseedges(G) -> Edgesedges(G, V) -> Edgesget_cycle(G, V) -> Vertices | falseget_path(G, V1, V2) -> Vertices | falseget_short_cycle(G, V) -> Vertices | falseget_short_path(G, V1, V2) -> Vertices | falsein_degree(G, V) -> integer() >= 0in_edges(G, V) -> Edgesin_neighbours(G, V) -> Vertexinfo(G) -> InfoListnew() -> graph() new(Type) -> graph() no_edges(G) -> integer() >= 0no_vertices(G) -> integer() >= 0out_degree(G, V) -> integer() >= 0out_edges(G, V) -> Edgesout_neighbours(G, V) -> Verticesvertex(G, V) -> {V, Label} | falsevertices(G) -> Vertices"
  ],
  [
    "digraph_utils",
    "arborescence_root(Digraph) -> no | {yes, Root}components(Digraph) -> [Component]condensation(Digraph) -> CondensedDigraphcyclic_strong_components(Digraph) -> [StrongComponent]is_acyclic(Digraph) -> boolean()is_arborescence(Digraph) -> boolean()is_tree(Digraph) -> boolean()loop_vertices(Digraph) -> Verticespostorder(Digraph) -> Verticespreorder(Digraph) -> Verticesreachable(Vertices, Digraph) -> Reachablereachable_neighbours(Vertices, Digraph) -> Reachablereaching(Vertices, Digraph) -> Reachingreaching_neighbours(Vertices, Digraph) -> Reachingstrong_components(Digraph) -> [StrongComponent]subgraph(Digraph, Vertices) -> SubGraphsubgraph(Digraph, Vertices, Options) -> SubGraphtopsort(Digraph) -> Vertices | false"
  ],
  [
    "disk_log",
    "accessible_logs() -> {[LocalLog], [DistributedLog]}alog(Log, Term) -> notify_ret()balog(Log, Bytes) -> notify_ret()alog_terms(Log, TermList) -> notify_ret()balog_terms(Log, ByteList) -> notify_ret()block(Log) -> ok | {error, block_error_rsn()}block(Log, QueueLogRecords) -> ok | {error, block_error_rsn()}change_header(Log, Header) -> ok | {error, Reason}change_notify(Log, Owner, Notify) -> ok | {error, Reason}change_size(Log, Size) -> ok | {error, Reason}chunk(Log, Continuation) -> chunk_ret()chunk(Log, Continuation, N) -> chunk_ret()bchunk(Log, Continuation) -> bchunk_ret()bchunk(Log, Continuation, N) -> bchunk_ret()chunk_info(Continuation) -> InfoList | {error, Reason}chunk_step(Log, Continuation, Step) -> {ok, any()} | {error, Reason}close(Log) -> ok | {error, close_error_rsn()}format_error(Error) -> io_lib:chars() inc_wrap_file(Log) -> ok | {error, inc_wrap_error_rsn()}info(Log) -> InfoList | {error, no_such_log}lclose(Log) -> ok | {error, lclose_error_rsn()}lclose(Log, Node) -> ok | {error, lclose_error_rsn()}log(Log, Term) -> ok | {error, Reason :: log_error_rsn()}blog(Log, Bytes) -> ok | {error, Reason :: log_error_rsn()}log_terms(Log, TermList) -> ok | {error, Resaon :: log_error_rsn()}blog_terms(Log, BytesList) -> ok | {error, Reason :: log_error_rsn()}open(ArgL) -> open_ret() | dist_open_ret()pid2name(Pid) -> {ok, Log} | undefinedreopen(Log, File) -> ok | {error, reopen_error_rsn()}reopen(Log, File, Head) -> ok | {error, reopen_error_rsn()}breopen(Log, File, BHead) -> ok | {error, reopen_error_rsn()}sync(Log) -> ok | {error, sync_error_rsn()}truncate(Log) -> ok | {error, trunc_error_rsn()}truncate(Log, Head) -> ok | {error, trunc_error_rsn()}btruncate(Log, BHead) -> ok | {error, trunc_error_rsn()}unblock(Log) -> ok | {error, unblock_error_rsn()}"
  ],
  [
    "disksup",
    "get_disk_data() -> [DiskData]get_check_interval() -> MSset_check_interval(Minutes) -> okget_almost_full_threshold() -> Percentset_almost_full_threshold(Float) -> ok"
  ],
  ["driver_entry"],
  [
    "dyntrace",
    "available() -> boolean()p() -> true | false | error | badargp(integer() | string()) -> true | false | error | badargp(integer() | string(), integer() | string()) -> true | false | error | badargp(integer() | string(), integer() | string(), integer() | string()) -> true | false | error | badargp(integer() | string(), integer() | string(), integer() | string(), integer() | string()) -> true | false | error | badargp(integer(), integer() | string(), integer() | string(), integer() | string(), string()) -> true | false | error | badargp(integer(), integer(), integer() | string(), integer() | string(), string(), string()) -> true | false | error | badargp(integer(), integer(), integer(), integer() | string(), string(), string(), string()) -> true | false | error | badargp(integer(), integer(), integer(), integer(), string(), string(), string(), string()) -> true | false | error | badargget_tag() -> binary() | undefinedget_tag() -> binary() | undefinedput_tag(Item) -> binary() | undefined spread_tag(boolean()) -> TagDatarestore_tag(TagData) -> true"
  ],
  [
    "edoc",
    "application(Application::atom()) -> okapplication(Application::atom(), Options::proplist()) -> okapplication(Application::atom(), Dir::filename(), Options::proplist()) -> okfile(Name::filename()) -> okfile(Name::filename(), Options::proplist()) -> okfiles(Files::[filename()]) -> okfiles(Files::[filename()], Options::proplist()) -> okget_doc(File::filename()) -> {ModuleName, edoc_module()}get_doc(File::filename(), Options::proplist()) -> {ModuleName, edoc_module()}get_doc(File::filename(), Env::edoc_lib:edoc_env(), Options::proplist()) -> {ModuleName, edoc_module()}layout(Doc::edoc_module()) -> string()layout(Doc::edoc_module(), Options::proplist()) -> string()read(File::filename()) -> string()read(File::filename(), Options::proplist()) -> string()read_comments(File) -> [comment()]read_comments(File::filename(), Options::proplist()) -> [comment()]read_source(Name::File) -> [syntaxTree()]read_source(File::filename(), Options::proplist()) -> [syntaxTree()]run(Files::[filename()], Options::proplist()) -> ok"
  ],
  [
    "edoc_doclet",
    "run(Command::doclet_gen() | doclet_toc(), Ctxt::edoc_context()) -> ok"
  ],
  [
    "edoc_extract",
    "file(File::filename(), Context, Env::edoc_env(), Options::proplist()) -> {ok, Tags} | {error, Reason}header(File::filename(), Env::edoc_env(), Options::proplist()) -> {ok, Tags} | {error, Reason}header(Forms, File::filename(), Env::edoc_env(), Options::proplist()) -> {ok, Tags} | {error, Reason}header(Forms, Comments::[edoc:comment()], File::filename(), Env::edoc_env(), Options::proplist()) -> {ok, Tags} | {error, Reason}source(File::filename(), Env::edoc_env(), Options::proplist()) -> {ModuleName, edoc:edoc_module()}source(Forms, File::filename(), Env::edoc_env(), Options::proplist()) -> {ModuleName, edoc:edoc_module()}source(Forms, Comments::[edoc:comment()], File::filename(), Env::edoc_env(), Options::proplist()) -> {ModuleName, edoc:edoc_module()}text(Text::string(), Context, Env::edoc_env(), Options::proplist()) -> Tags"
  ],
  [
    "edoc_layout",
    "module(Element, Options) -> term()overview(E, Options) -> term()type(E) -> term()"
  ],
  [
    "edoc_lib",
    "get_doc_env(App, Modules, Options::proplist()) -> edoc_env()write_file(Text, Dir, Name, Options) -> term()"
  ],
  [
    "edoc_run",
    "application(Args::[string()]) -> none()file(Args::[string()]) -> none()files(Args::[string()]) -> none()"
  ],
  [
    "ei",
    "int ei_decode_atom(const char *buf,int *index,char *p)int ei_decode_atom_as(const char *buf,int *index,char *p,int plen,erlang_char_encoding want,erlang_char_encoding* was,erlang_char_encoding* result)int ei_decode_bignum(const char *buf,int *index,mpz_t obj)int ei_decode_binary(const char *buf,int *index,void *p,long *len)int ei_decode_bitstring(const char *buf,int *index,const char **pp,unsigned int *bitoffsp,size_t *nbitsp)int ei_decode_boolean(const char *buf,int *index,int *p)int ei_decode_char(const char *buf,int *index,char *p)int ei_decode_double(const char *buf,int *index,double *p)int ei_decode_ei_term(const char* buf,int* index,ei_term* term)int ei_decode_fun(const char *buf,int *index,erlang_fun *p)void free_fun(erlang_fun* f)int ei_decode_list_header(const char *buf,int *index,int *arity)int ei_decode_long(const char *buf,int *index,long *p)int ei_decode_longlong(const char *buf,int *index,long long *p)int ei_decode_map_header(const char *buf,int *index,int *arity)int ei_decode_pid(const char *buf,int *index,erlang_pid *p)int ei_decode_port(const char *buf,int *index,erlang_port *p)int ei_decode_ref(const char *buf,int *index,erlang_ref *p)int ei_decode_string(const char *buf,int *index,char *p)int ei_decode_term(const char *buf,int *index,void *t)int ei_decode_trace(const char *buf,int *index,erlang_trace *p)int ei_decode_tuple_header(const char *buf,int *index,int *arity)int ei_decode_ulong(const char *buf,int *index,unsigned long *p)int ei_decode_ulonglong(const char *buf,int *index,unsigned long long *p)int ei_decode_version(const char *buf,int *index,int *version)int ei_encode_atom(char *buf,int *index,const char *p)int ei_encode_atom_len(char *buf,int *index,const char *p,int len)int ei_x_encode_atom(ei_x_buff* x,const char *p)int ei_x_encode_atom_len(ei_x_buff* x,const char *p,int len)int ei_encode_atom_as(char *buf,int *index,const char *p,erlang_char_encoding from_enc,erlang_char_encoding to_enc)int ei_encode_atom_len_as(char *buf,int *index,const char *p,int len,erlang_char_encoding from_enc,erlang_char_encoding to_enc)int ei_x_encode_atom_as(ei_x_buff* x,const char *p,erlang_char_encoding from_enc,erlang_char_encoding to_enc)int ei_x_encode_atom_len_as(ei_x_buff* x,const char *p,int len,erlang_char_encoding from_enc,erlang_char_encoding to_enc)int ei_encode_bignum(char *buf,int *index,mpz_t obj)int ei_x_encode_bignum(ei_x_buff *x,mpz_t obj)int ei_encode_binary(char *buf,int *index,const void *p,long len)int ei_x_encode_binary(ei_x_buff* x,const void *p,long len)int ei_encode_bitstring(char *buf,int *index,const char *p,size_t bitoffs,size_t nbits)int ei_x_encode_bitstring(ei_x_buff* x,const char *p,size_t bitoffs,size_t nbits)int ei_encode_boolean(char *buf,int *index,int p)int ei_x_encode_boolean(ei_x_buff* x,int p)int ei_encode_char(char *buf,int *index,char p)int ei_x_encode_char(ei_x_buff* x,char p)int ei_encode_double(char *buf,int *index,double p)int ei_x_encode_double(ei_x_buff* x,double p)int ei_encode_empty_list(char* buf,int* index)int ei_x_encode_empty_list(ei_x_buff* x)int ei_encode_fun(char *buf,int *index,const erlang_fun *p)int ei_x_encode_fun(ei_x_buff* x,const erlang_fun* fun)int ei_encode_list_header(char *buf,int *index,int arity)int ei_x_encode_list_header(ei_x_buff* x,int arity)int ei_encode_long(char *buf,int *index,long p)int ei_x_encode_long(ei_x_buff* x,long p)int ei_encode_longlong(char *buf,int *index,long long p)int ei_x_encode_longlong(ei_x_buff* x,long long p)int ei_encode_map_header(char *buf,int *index,int arity)int ei_x_encode_map_header(ei_x_buff* x,int arity)int ei_encode_pid(char *buf,int *index,const erlang_pid *p)int ei_x_encode_pid(ei_x_buff* x,const erlang_pid *p)int ei_encode_port(char *buf,int *index,const erlang_port *p)int ei_x_encode_port(ei_x_buff* x,const erlang_port *p)int ei_encode_ref(char *buf,int *index,const erlang_ref *p)int ei_x_encode_ref(ei_x_buff* x,const erlang_ref *p)int ei_encode_string(char *buf,int *index,const char *p)int ei_encode_string_len(char *buf,int *index,const char *p,int len)int ei_x_encode_string(ei_x_buff* x,const char *p)int ei_x_encode_string_len(ei_x_buff* x,const char* s,int len)int ei_encode_term(char *buf,int *index,void *t)int ei_x_encode_term(ei_x_buff* x,void *t)int ei_encode_trace(char *buf,int *index,const erlang_trace *p)int ei_x_encode_trace(ei_x_buff* x,const erlang_trace *p)int ei_encode_tuple_header(char *buf,int *index,int arity)int ei_x_encode_tuple_header(ei_x_buff* x,int arity)int ei_encode_ulong(char *buf,int *index,unsigned long p)int ei_x_encode_ulong(ei_x_buff* x,unsigned long p)int ei_encode_ulonglong(char *buf,int *index,unsigned long long p)int ei_x_encode_ulonglong(ei_x_buff* x,unsigned long long p)int ei_encode_version(char *buf,int *index)int ei_x_encode_version(ei_x_buff* x)int ei_get_type(const char *buf,const int *index,int *type,int *size)int ei_init(void)int ei_print_term(FILE* fp,const char* buf,int* index)int ei_s_print_term(char** s,const char* buf,int* index)void ei_set_compat_rel(release_number)int ei_skip_term(const char* buf,int* index)int ei_x_append(ei_x_buff* x,const ei_x_buff* x2)int ei_x_append_buf(ei_x_buff* x,const char* buf,int len)int ei_x_format(ei_x_buff* x,const char* fmt,...)int ei_x_format_wo_ver(ei_x_buff* x,const char *fmt,... )int ei_x_free(ei_x_buff* x)int ei_x_new(ei_x_buff* x)int ei_x_new_with_version(ei_x_buff* x)"
  ],
  [
    "ei_connect",
    "struct hostent *ei_gethostbyaddr(const char *addr,int len,int type)struct hostent *ei_gethostbyaddr_r(const char *addr,int length,int type,struct hostent *hostp,char *buffer,int buflen,int *h_errnop)struct hostent *ei_gethostbyname(const char *name)struct hostent *ei_gethostbyname_r(const char *name,struct hostent *hostp,char *buffer,int buflen,int *h_errnop)int ei_accept(ei_cnode *ec,int listensock,ErlConnect *conp)int ei_accept_tmo(ei_cnode *ec,int listensock,ErlConnect *conp,unsigned timeout_ms)int ei_close_connection(int fd)int ei_connect(ei_cnode* ec,char *nodename)int ei_xconnect(ei_cnode* ec,Erl_IpAddr adr,char *alivename)int ei_connect_init(ei_cnode* ec,const char* this_node_name,const char *cookie,short creation)int ei_connect_init_ussi(ei_cnode* ec,const char* this_node_name,const char *cookie,short creation,ei_socket_callbacks *cbs,int cbs_sz,void *setup_context)int ei_connect_xinit(ei_cnode* ec,const char *thishostname,const char *thisalivename,const char *thisnodename,Erl_IpAddr thisipaddr,const char *cookie,short creation)int ei_connect_xinit_ussi(ei_cnode* ec,const char *thishostname,const char *thisalivename,const char *thisnodename,Erl_IpAddr thisipaddr,const char *cookie,short creation,ei_socket_callbacks *cbs,int cbs_sz,void *setup_context)int ei_connect_tmo(ei_cnode* ec,char *nodename,unsigned timeout_ms)int ei_xconnect_tmo(ei_cnode* ec,Erl_IpAddr adr,char *alivename,unsigned timeout_ms)int ei_get_tracelevel(void)void ei_set_tracelevel(int level)int ei_listen(ei_cnode *ec,int *port,int backlog)int ei_xlisten(ei_cnode *ec,Erl_IpAddr adr,int *port,int backlog)int ei_publish(ei_cnode *ec,int port)int ei_publish_tmo(ei_cnode *ec,int port,unsigned timeout_ms)int ei_receive(int fd,unsigned char* bufp,int bufsize)int ei_receive_encoded(int fd,char **mbufp,int *bufsz,erlang_msg *msg,int *msglen)int ei_receive_encoded_tmo(int fd,char **mbufp,int *bufsz,erlang_msg *msg,int *msglen,unsigned timeout_ms)int ei_receive_msg(int fd,erlang_msg* msg,ei_x_buff* x)int ei_xreceive_msg(int fd,erlang_msg* msg,ei_x_buff* x)int ei_receive_msg_tmo(int fd,erlang_msg* msg,ei_x_buff* x,unsigned imeout_ms)int ei_xreceive_msg_tmo(int fd,erlang_msg* msg,ei_x_buff* x,unsigned timeout_ms)int ei_receive_tmo(int fd,unsigned char* bufp,int bufsize,unsigned timeout_ms)int ei_reg_send(ei_cnode* ec,int fd,char* server_name,char* buf,int len)int ei_reg_send_tmo(ei_cnode* ec,int fd,char* server_name,char* buf,int len,unsigned timeout_ms)int ei_rpc(ei_cnode *ec,int fd,char *mod,char *fun,const char *argbuf,int argbuflen,ei_x_buff *x)int ei_rpc_to(ei_cnode *ec,int fd,char *mod,char *fun,const char *argbuf,int argbuflen)int ei_rpc_from(ei_cnode *ec,int fd,int timeout,erlang_msg *msg,ei_x_buff *x)erlang_pid *ei_self(ei_cnode *ec)int ei_send(int fd,erlang_pid* to,char* buf,int len)int ei_send_encoded(int fd,erlang_pid* to,char* buf,int len)int ei_send_encoded_tmo(int fd,erlang_pid* to,char* buf,int len,unsigned timeout_ms)int ei_send_reg_encoded(int fd,const erlang_pid *from,const char *to,const char *buf,int len)int ei_send_reg_encoded_tmo(int fd,const erlang_pid *from,const char *to,const char *buf,int len)int ei_send_tmo(int fd,erlang_pid* to,char* buf,int len,unsigned timeout_ms)const char *ei_thisnodename(ei_cnode *ec)const char *ei_thishostname(ei_cnode *ec)const char *ei_thisalivename(ei_cnode *ec)int ei_unpublish(ei_cnode *ec)int ei_unpublish_tmo(ei_cnode *ec,unsigned timeout_ms)"
  ],
  [
    "eldap",
    "open([Host]) -> {ok, Handle} | {error, Reason}open([Host], [Option]) -> {ok, Handle} | {error, Reason}close(Handle) -> okstart_tls(Handle, Options) -> return_value()start_tls(Handle, Options, Timeout) -> return_value()simple_bind(Handle, Dn, Password) -> return_value()add(Handle, Dn, [Attribute]) -> return_value()delete(Handle, Dn) -> return_value()mod_add(Type, [Value]) -> modify_op()mod_delete(Type, [Value]) -> modify_op()mod_replace(Type, [Value]) -> modify_op()modify(Handle, Dn, [ModifyOp]) -> return_value()modify_password(Handle, Dn, NewPasswd) -> return_value() | {ok, GenPasswd}modify_password(Handle, Dn, NewPasswd, OldPasswd) -> return_value() | {ok, GenPasswd}modify_dn(Handle, Dn, NewRDN, DeleteOldRDN, NewSupDN) -> return_value()search(Handle, SearchOptions) -> {ok, #eldap_search_result{}} | {ok, {referral,referrals()}} | {error, Reason}baseObject() -> scope()singleLevel() -> scope()wholeSubtree() -> scope()neverDerefAliases() -> dereference()derefAlways() -> dereference()derefInSearching() -> dereference()derefFindingBaseObj() -> dereference()present(Type) -> filter()substrings(Type, [SubString]) -> filter()equalityMatch(Type, Value) -> filter()greaterOrEqual(Type, Value) -> filter()lessOrEqual(Type, Value) -> filter()approxMatch(Type, Value) -> filter()extensibleMatch(MatchValue, OptionalAttrs) -> filter()'and'([Filter]) -> filter()'or'([Filter]) -> filter()'not'(Filter) -> filter()"
  ],
  ["epmd"],
  [
    "epp",
    "close(Epp) -> okdefault_encoding() -> source_encoding() encoding_to_string(Encoding) -> string()format_error(ErrorDescriptor) -> io_lib:chars() open(Options) -> {ok, Epp} | {ok, Epp, Extra} | {error, ErrorDescriptor}open(FileName, IncludePath) -> {ok, Epp} | {error, ErrorDescriptor}open(FileName, IncludePath, PredefMacros) -> {ok, Epp} | {error, ErrorDescriptor}parse_erl_form(Epp) -> {ok, AbsForm} | {error, ErrorInfo} | {warning, WarningInfo} | {eof, Line}parse_file(FileName, Options) -> {ok, [Form]} | {ok, [Form], Extra} | {error, OpenError}parse_file(FileName, IncludePath, PredefMacros) -> {ok, [Form]} | {error, OpenError}read_encoding(FileName) -> source_encoding() | noneread_encoding(FileName, Options) -> source_encoding() | noneread_encoding_from_binary(Binary) -> source_encoding() | noneread_encoding_from_binary(Binary, Options) -> source_encoding() | noneset_encoding(File) -> source_encoding() | noneset_encoding(File, Default) -> source_encoding() | none"
  ],
  [
    "epp_dodger",
    "parse(Dev::IODevice) -> {ok, Forms} | {error, errorinfo()}parse(Dev::IODevice, L::StartLine) -> {ok, Forms} | {error, errorinfo()}parse(Dev::IODevice, L0::StartLine, Options) -> {ok, Forms} | {error, errorinfo()}parse_file(File) -> {ok, Forms} | {error, errorinfo()}parse_file(File, Options) -> {ok, Forms} | {error, errorinfo()}parse_form(Dev::IODevice, L0::StartLine) -> {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}parse_form(Dev::IODevice, L0::StartLine, Options) -> {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}quick_parse(Dev::IODevice) -> {ok, Forms} | {error, errorinfo()}quick_parse(Dev::IODevice, L::StartLine) -> {ok, Forms} | {error, errorinfo()}quick_parse(Dev::IODevice, L0::StartLine, Options) -> {ok, Forms} | {error, errorinfo()}quick_parse_file(File) -> {ok, Forms} | {error, errorinfo()}quick_parse_file(File, Options) -> {ok, Forms} | {error, errorinfo()}quick_parse_form(Dev::IODevice, L0::StartLine) -> {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}quick_parse_form(Dev::IODevice, L0::StartLine, Options) -> {ok, Form, LineNo} | {eof, LineNo} | {error, errorinfo(), LineNo}tokens_to_string(Tokens::[term()]) -> string()"
  ],
  [
    "eprof",
    "start() -> {ok,Pid} | {error,Reason}start_profiling(Rootset) -> profiling | {error, Reason}start_profiling(Rootset,Pattern) -> profiling | {error, Reason}start_profiling(Rootset,Pattern,Options) -> profiling | {error, Reason}stop_profiling() -> profiling_stopped | profiling_already_stoppedprofile(Fun) -> profiling | {error, Reason}profile(Fun, Options) -> profiling | {error, Reason}profile(Rootset) -> profiling | {error, Reason}profile(Rootset,Fun) -> {ok, Value} | {error,Reason}profile(Rootset,Fun,Pattern) -> {ok, Value} | {error, Reason}profile(Rootset,Module,Function,Args) -> {ok, Value} | {error, Reason}profile(Rootset,Module,Function,Args,Pattern) -> {ok, Value} | {error, Reason}profile(Rootset,Module,Function,Args,Pattern,Options) -> {ok, Value} | {error, Reason}analyze() -> okanalyze(Type) -> okanalyze(Type,Options) -> oklog(File) -> okstop() -> stopped"
  ],
  ["erl"],
  [
    "erl_anno",
    "column(Anno) -> column() | undefinedend_location(Anno) -> location() | undefinedfile(Anno) -> filename() | undefinedfrom_term(Term) -> Annogenerated(Anno) -> generated()is_anno(Term) -> boolean()line(Anno) -> line() location(Anno) -> location() new(Location) -> anno() set_file(File, Anno) -> Annoset_generated(Generated, Anno) -> Annoset_line(Line, Anno) -> Annoset_location(Location, Anno) -> Annoset_record(Record, Anno) -> Annoset_text(Text, Anno) -> Annotext(Anno) -> text() | undefinedto_term(Anno) -> anno_term()"
  ],
  [
    "erl_boot_server",
    "add_slave(Slave) -> ok | {error, Reason}delete_slave(Slave) -> ok | {error, Reason}start(Slaves) -> {ok, Pid} | {error, Reason}start_link(Slaves) -> {ok, Pid} | {error, Reason}which_slaves() -> Slaves"
  ],
  ["erl_call"],
  [
    "erl_comment_scan",
    "file(FileName::file:filename()) -> [Comment]join_lines(Lines::[CommentLine]) -> [Comment]scan_lines(Text::string()) -> [CommentLine]string(Text::string()) -> [Comment]"
  ],
  [
    "erl_connect",
    "int erl_accept(listensock,conp)int erl_close_connection(fd)int erl_connect(node)int erl_xconnect(addr,alive)int erl_connect_init(number,cookie,creation)int erl_connect_xinit(host,alive,node,addr,cookie,creation)int erl_publish(port)int erl_receive(fd,bufp,bufsize)int erl_receive_msg(fd,bufp,bufsize,emsg)int erl_reg_send(fd,to,msg)ETERM *erl_rpc(fd,mod,fun,args)int erl_rpc_from(fd,timeout,emsg)int erl_rpc_to(fd,mod,fun,args)int erl_send(fd,to,msg)const char *erl_thisalivename()const char *erl_thiscookie()short erl_thiscreation()const char *erl_thishostname()const char *erl_thisnodename()int erl_unpublish(alive)int erl_xreceive_msg(fd,bufpp,bufsizep,emsg)struct hostent *erl_gethostbyaddr(addr,length,type)struct hostent *erl_gethostbyaddr_r(addr,length,type,hostp,buffer,buflen,h_errnop)struct hostent *erl_gethostbyname(name)struct hostent *erl_gethostbyname_r(name,hostp,buffer,buflen,h_errnop)"
  ],
  [
    "erl_ddll",
    "demonitor(MonitorRef) -> okformat_error(ErrorDesc) -> string()info() -> AllInfoListinfo(Name) -> InfoListinfo(Name, Tag) -> Valueload(Path, Name) -> ok | {error, ErrorDesc}load_driver(Path, Name) -> ok | {error, ErrorDesc}loaded_drivers() -> {ok, Drivers}monitor(Tag, Item) -> MonitorRefreload(Path, Name) -> ok | {error, ErrorDesc}reload_driver(Path, Name) -> ok | {error, ErrorDesc}try_load(Path, Name, OptionList) -> {ok, Status} | {ok, PendingStatus, Ref} | {error, ErrorDesc}try_unload(Name, OptionList) -> {ok, Status} | {ok, PendingStatus, Ref} | {error, ErrorAtom}unload(Name) -> ok | {error, ErrorDesc}unload_driver(Name) -> ok | {error, ErrorDesc}"
  ],
  ["erl_docgen_app"],
  [
    "erl_driver",
    "void add_driver_entry(ErlDrvEntry *de)void * driver_alloc(ErlDrvSizeT size)ErlDrvBinary * driver_alloc_binary(ErlDrvSizeT size)long driver_async(ErlDrvPort port,unsigned int* key,void (*async_invoke)(void*),void* async_data,void (*async_free)(void*))unsigned int driver_async_port_key(ErlDrvPort port)long driver_binary_dec_refc(ErlDrvBinary *bin)long driver_binary_get_refc(ErlDrvBinary *bin)long driver_binary_inc_refc(ErlDrvBinary *bin)ErlDrvTermData driver_caller(ErlDrvPort port)int driver_cancel_timer(ErlDrvPort port)int driver_compare_monitors(const ErlDrvMonitor *monitor1,const ErlDrvMonitor *monitor2)ErlDrvTermData driver_connected(ErlDrvPort port)ErlDrvPort driver_create_port(ErlDrvPort port,ErlDrvTermData owner_pid,char* name,ErlDrvData drv_data)int driver_demonitor_process(ErlDrvPort port,const ErlDrvMonitor *monitor)ErlDrvSizeT driver_deq(ErlDrvPort port,ErlDrvSizeT size)int driver_enq(ErlDrvPort port,char* buf,ErlDrvSizeT len)int driver_enq_bin(ErlDrvPort port,ErlDrvBinary *bin,ErlDrvSizeT offset,ErlDrvSizeT len) int driver_enqv(ErlDrvPort port,ErlIOVec *ev,ErlDrvSizeT skip)int driver_failure(ErlDrvPort port,int error)int driver_failure_atom(ErlDrvPort port,char *string)int driver_failure_posix(ErlDrvPort port,int error)int driver_failure_eof(ErlDrvPort port)void driver_free(void *ptr)void driver_free_binary(ErlDrvBinary *bin)ErlDrvTermData driver_get_monitored_process(ErlDrvPort port,const ErlDrvMonitor *monitor)int driver_get_now(ErlDrvNowData *now)int driver_lock_driver(ErlDrvPort port)ErlDrvTermData driver_mk_atom(char* string)ErlDrvTermData driver_mk_port(ErlDrvPort port)int driver_monitor_process(ErlDrvPort port,ErlDrvTermData process,ErlDrvMonitor *monitor)int driver_output(ErlDrvPort port,char *buf,ErlDrvSizeT len)int driver_output_binary(ErlDrvPort port,char *hbuf,ErlDrvSizeT hlen,ErlDrvBinary* bin,ErlDrvSizeT offset,ErlDrvSizeT len)int driver_output_term(ErlDrvPort port,ErlDrvTermData* term,int n)int driver_output2(ErlDrvPort port,char *hbuf,ErlDrvSizeT hlen,char *buf,ErlDrvSizeT len)int driver_outputv(ErlDrvPort port,char* hbuf,ErlDrvSizeT hlen,ErlIOVec *ev,ErlDrvSizeT skip)ErlDrvPDL driver_pdl_create(ErlDrvPort port)long driver_pdl_dec_refc(ErlDrvPDL pdl)long driver_pdl_get_refc(ErlDrvPDL pdl)long driver_pdl_inc_refc(ErlDrvPDL pdl)void driver_pdl_lock(ErlDrvPDL pdl)void driver_pdl_unlock(ErlDrvPDL pdl)SysIOVec *driver_peekq(ErlDrvPort port,int *vlen)ErlDrvSizeT driver_peekqv(ErlDrvPort port,ErlIOVec *ev)int driver_pushq(ErlDrvPort port,char* buf,ErlDrvSizeT len)int driver_pushq_bin(ErlDrvPort port,ErlDrvBinary *bin,ErlDrvSizeT offset,ErlDrvSizeT len) int driver_pushqv(ErlDrvPort port,ErlIOVec *ev,ErlDrvSizeT skip)int driver_read_timer(ErlDrvPort port,unsigned long *time_left)void * driver_realloc(void *ptr,ErlDrvSizeT size)ErlDrvBinary * driver_realloc_binary(ErlDrvBinary *bin,ErlDrvSizeT size)int driver_select(ErlDrvPort port,ErlDrvEvent event,int mode,int on)int driver_send_term(ErlDrvPort port,ErlDrvTermData receiver,ErlDrvTermData* term,int n)int driver_set_timer(ErlDrvPort port,unsigned long time)ErlDrvSizeT driver_sizeq(ErlDrvPort port)void driver_system_info(ErlDrvSysInfo *sys_info_ptr,size_t size)ErlDrvSizeT driver_vec_to_buf(ErlIOVec *ev,char *buf,ErlDrvSizeT len)void erl_drv_busy_msgq_limits(ErlDrvPort port,ErlDrvSizeT *low,ErlDrvSizeT *high)void erl_drv_cond_broadcast(ErlDrvCond *cnd)ErlDrvCond *erl_drv_cond_create(char *name)void erl_drv_cond_destroy(ErlDrvCond *cnd)char *erl_drv_cond_name(ErlDrvCond *cnd)void erl_drv_cond_signal(ErlDrvCond *cnd)void erl_drv_cond_wait(ErlDrvCond *cnd,ErlDrvMutex *mtx)int erl_drv_consume_timeslice(ErlDrvPort port,int percent)ErlDrvTime erl_drv_convert_time_unit(ErlDrvTime val,ErlDrvTimeUnit from,ErlDrvTimeUnit to)int erl_drv_equal_tids(ErlDrvTid tid1,ErlDrvTid tid2)int erl_drv_getenv(const char *key,char *value,size_t *value_size)void erl_drv_init_ack(ErlDrvPort port,ErlDrvData res)ErlDrvTime erl_drv_monotonic_time(ErlDrvTimeUnit time_unit) ErlDrvMutex *erl_drv_mutex_create(char *name)void erl_drv_mutex_destroy(ErlDrvMutex *mtx)void erl_drv_mutex_lock(ErlDrvMutex *mtx)char *erl_drv_mutex_name(ErlDrvMutex *mtx)int erl_drv_mutex_trylock(ErlDrvMutex *mtx)void erl_drv_mutex_unlock(ErlDrvMutex *mtx)int erl_drv_output_term(ErlDrvTermData port,ErlDrvTermData* term,int n)int erl_drv_putenv(const char *key,char *value)ErlDrvRWLock *erl_drv_rwlock_create(char *name)void erl_drv_rwlock_destroy(ErlDrvRWLock *rwlck)char *erl_drv_rwlock_name(ErlDrvRWLock *rwlck)void erl_drv_rwlock_rlock(ErlDrvRWLock *rwlck)void erl_drv_rwlock_runlock(ErlDrvRWLock *rwlck)void erl_drv_rwlock_rwlock(ErlDrvRWLock *rwlck)void erl_drv_rwlock_rwunlock(ErlDrvRWLock *rwlck)int erl_drv_rwlock_tryrlock(ErlDrvRWLock *rwlck)int erl_drv_rwlock_tryrwlock(ErlDrvRWLock *rwlck)int erl_drv_send_term(ErlDrvTermData port,ErlDrvTermData receiver,ErlDrvTermData* term,int n)void erl_drv_set_os_pid(ErlDrvPort port,ErlDrvSInt pid)int erl_drv_thread_create(char *name,ErlDrvTid *tid,void * (*func)(void *),void *arg,ErlDrvThreadOpts *opts)void erl_drv_thread_exit(void *exit_value)int erl_drv_thread_join(ErlDrvTid tid,void **exit_value)char *erl_drv_thread_name(ErlDrvTid tid)ErlDrvThreadOpts * erl_drv_thread_opts_create(char *name)void erl_drv_thread_opts_destroy(ErlDrvThreadOpts *opts) ErlDrvTid erl_drv_thread_self(void)ErlDrvTime erl_drv_time_offset(ErlDrvTimeUnit time_unit)void *erl_drv_tsd_get(ErlDrvTSDKey key)int erl_drv_tsd_key_create(char *name,ErlDrvTSDKey *key)void erl_drv_tsd_key_destroy(ErlDrvTSDKey key)void erl_drv_tsd_set(ErlDrvTSDKey key,void *data)char *erl_errno_id(int error)int remove_driver_entry(ErlDrvEntry *de)void set_busy_port(ErlDrvPort port,int on)void set_port_control_flags(ErlDrvPort port,int flags)"
  ],
  [
    "erl_epmd",
    "start_link() -> {ok, pid()} | ignore | {error, term()}register_node(Name, Port) -> Resultregister_node(Name, Port, Driver) -> Resultport_please(Name, Host) -> {ok, Port, Version} | noportport_please(Name, Host, Timeout) -> {ok, Port, Version} | noportaddress_please(Name, Host, AddressFamily) -> Success | {error, term()}names(Host) -> {ok, [{Name, Port}]} | {error, Reason}"
  ],
  [
    "erl_error",
    "void erl_err_msg(FormatStr,... )void erl_err_quit(FormatStr,... )void erl_err_ret(FormatStr,... )void erl_err_sys(FormatStr,... )volatile int ("
  ],
  [
    "erl_eterm",
    "ETERM *erl_cons(head,tail)ETERM *erl_copy_term(term)ETERM *erl_element(position,tuple)ETERM *erl_hd(list)void erl_init(NULL,0)int erl_iolist_length(list)ETERM *erl_iolist_to_binary(term)char *erl_iolist_to_string(list)int erl_length(list)ETERM *erl_mk_atom(string)ETERM *erl_mk_binary(bptr,size)ETERM *erl_mk_empty_list()ETERM *erl_mk_estring(string,len)ETERM *erl_mk_float(f)ETERM *erl_mk_int(n)ETERM *erl_mk_list(array,arrsize)ETERM *erl_mk_long_ref(node,n1,n2,n3,creation)ETERM *erl_mk_pid(node,number,serial,creation)ETERM *erl_mk_port(node,number,creation)ETERM *erl_mk_ref(node,number,creation)ETERM *erl_mk_string(string)ETERM *erl_mk_tuple(array,arrsize)ETERM *erl_mk_uint(n)ETERM *erl_mk_var(name)int erl_print_term(stream,term)void erl_set_compat_rel(release_number)int erl_size(term)ETERM *erl_tl(list)ETERM *erl_var_content(term,name)"
  ],
  [
    "erl_eval",
    "add_binding(Name, Value, BindingStruct) -> binding_struct() binding(Name, BindingStruct) -> {value, value()} | unboundbindings(BindingStruct :: binding_struct()) -> bindings() del_binding(Name, BindingStruct) -> binding_struct() expr(Expression, Bindings) -> {value, Value, NewBindings}expr(Expression, Bindings, LocalFunctionHandler) -> {value, Value, NewBindings}expr(Expression, Bindings, LocalFunctionHandler, NonLocalFunctionHandler) -> {value, Value, NewBindings}expr(Expression, Bindings, LocalFunctionHandler, NonLocalFunctionHandler, ReturnFormat) -> {value, Value, NewBindings} | Valueexpr_list(ExpressionList, Bindings) -> {ValueList, NewBindings}expr_list(ExpressionList, Bindings, LocalFunctionHandler) -> {ValueList, NewBindings}expr_list(ExpressionList, Bindings, LocalFunctionHandler, NonLocalFunctionHandler) -> {ValueList, NewBindings}exprs(Expressions, Bindings) -> {value, Value, NewBindings}exprs(Expressions, Bindings, LocalFunctionHandler) -> {value, Value, NewBindings}exprs(Expressions, Bindings, LocalFunctionHandler, NonLocalFunctionHandler) -> {value, Value, NewBindings}new_bindings() -> binding_struct()"
  ],
  ["erl_expand_records", "module(AbsForms, CompileOptions) -> AbsForms2"],
  ["erl_format", "ETERM *erl_format(FormatStr,...)int erl_match(Pattern,Term)"],
  [
    "erl_global",
    "char **erl_global_names(fd,count)int erl_global_register(fd,name,pid)int erl_global_unregister(fd,name)ETERM *erl_global_whereis(fd,name,node)"
  ],
  ["erl_id_trans", "parse_transform(Forms, Options) -> Forms"],
  [
    "erl_internal",
    "add_predefined_functions(Forms) -> UpdatedFormsarith_op(OpName, Arity) -> boolean()bif(Name, Arity) -> boolean()bool_op(OpName, Arity) -> boolean()comp_op(OpName, Arity) -> boolean()guard_bif(Name, Arity) -> boolean()list_op(OpName, Arity) -> boolean()op_type(OpName, Arity) -> Typesend_op(OpName, Arity) -> boolean()type_test(Name, Arity) -> boolean()"
  ],
  [
    "erl_lint",
    "format_error(ErrorDescriptor) -> io_lib:chars() is_guard_test(Expr) -> boolean()module(AbsForms) -> {ok, Warnings} | {error, Errors, Warnings}module(AbsForms, FileName) -> {ok, Warnings} | {error, Errors, Warnings}module(AbsForms, FileName, CompileOptions) -> {ok, Warnings} | {error, Errors, Warnings}"
  ],
  [
    "erl_malloc",
    "ETERM *erl_alloc_eterm(etype)void erl_eterm_release(void)void erl_eterm_statistics(allocated,freed)void erl_free(ptr)void erl_free_array(array,size)void erl_free_compound(t)void erl_free_term(t)void erl_malloc(size)"
  ],
  [
    "erl_marshal",
    "int erl_compare_ext(bufp1,bufp2)ETERM *erl_decode(bufp)ETERM *erl_decode_buf(bufpp)int erl_encode(term,bufp)int erl_encode_buf(term,bufpp)int erl_ext_size(bufp)unsigned char erl_ext_type(bufp)unsigned char *erl_peek_ext(bufp,pos)int erl_term_len(t)"
  ],
  [
    "erl_nif",
    "void *enif_alloc(size_t size)int enif_alloc_binary(size_t size,ErlNifBinary* bin) ErlNifEnv *enif_alloc_env()void *enif_alloc_resource(ErlNifResourceType* type,unsigned size)size_t enif_binary_to_term(ErlNifEnv *env,const unsigned char* data,size_t size,ERL_NIF_TERM *term,ErlNifBinaryToTerm opts)void enif_clear_env(ErlNifEnv* env) int enif_compare(ERL_NIF_TERM lhs,ERL_NIF_TERM rhs) int enif_compare_monitors(const ErlNifMonitor *monitor1,const ErlNifMonitor *monitor2)int enif_compare_pids(const ErlNifPid *pid1,const ErlNifPid *pid2)void enif_cond_broadcast(ErlNifCond *cnd)ErlNifCond * enif_cond_create(char *name)void enif_cond_destroy(ErlNifCond *cnd)char* enif_cond_name(ErlNifCond* cnd)void enif_cond_signal(ErlNifCond *cnd)void enif_cond_wait(ErlNifCond *cnd,ErlNifMutex *mtx) int enif_consume_timeslice(ErlNifEnv *env,int percent) ErlNifTime enif_convert_time_unit(ErlNifTime val,ErlNifTimeUnit from,ErlNifTimeUnit to)ERL_NIF_TERM enif_cpu_time(ErlNifEnv *)int enif_demonitor_process(ErlNifEnv* caller_env,void* obj,const ErlNifMonitor* mon)int enif_equal_tids(ErlNifTid tid1,ErlNifTid tid2) int enif_fprintf(FILE *stream,const char *format,...)void enif_free(void* ptr)void enif_free_env(ErlNifEnv* env)void enif_free_iovec(ErlNifIOVec* iov)int enif_get_atom(ErlNifEnv* env,ERL_NIF_TERM term,char* buf,unsigned size,ErlNifCharEncoding encode) int enif_get_atom_length(ErlNifEnv* env,ERL_NIF_TERM term,unsigned* len,ErlNifCharEncoding encode) int enif_get_double(ErlNifEnv* env,ERL_NIF_TERM term,double* dp)int enif_get_int(ErlNifEnv* env,ERL_NIF_TERM term,int* ip)int enif_get_int64(ErlNifEnv* env,ERL_NIF_TERM term,ErlNifSInt64* ip)int enif_get_local_pid(ErlNifEnv* env,ERL_NIF_TERM term,ErlNifPid* pid)int enif_get_local_port(ErlNifEnv* env,ERL_NIF_TERM term,ErlNifPort* port_id)int enif_get_list_cell(ErlNifEnv* env,ERL_NIF_TERM list,ERL_NIF_TERM* head,ERL_NIF_TERM* tail) int enif_get_list_length(ErlNifEnv* env,ERL_NIF_TERM term,unsigned* len)int enif_get_long(ErlNifEnv* env,ERL_NIF_TERM term,long int* ip)int enif_get_map_size(ErlNifEnv* env,ERL_NIF_TERM term,size_t *size)int enif_get_map_value(ErlNifEnv* env,ERL_NIF_TERM map,ERL_NIF_TERM key,ERL_NIF_TERM* value) int enif_get_resource(ErlNifEnv* env,ERL_NIF_TERM term,ErlNifResourceType* type,void** objp) int enif_get_string(ErlNifEnv* env,ERL_NIF_TERM list,char* buf,unsigned size,ErlNifCharEncoding encode)int enif_get_tuple(ErlNifEnv* env,ERL_NIF_TERM term,int* arity,const ERL_NIF_TERM** array)int enif_get_uint(ErlNifEnv* env,ERL_NIF_TERM term,unsigned int* ip)int enif_get_uint64(ErlNifEnv* env,ERL_NIF_TERM term,ErlNifUInt64* ip)int enif_get_ulong(ErlNifEnv* env,ERL_NIF_TERM term,unsigned long* ip)int enif_getenv(const char* key,char* value,size_t *value_size)int enif_has_pending_exception(ErlNifEnv* env,ERL_NIF_TERM* reason) ErlNifUInt64 enif_hash(ErlNifHash type,ERL_NIF_TERM term,ErlNifUInt64 salt) int enif_inspect_binary(ErlNifEnv* env,ERL_NIF_TERM bin_term,ErlNifBinary* bin)int enif_inspect_iolist_as_binary(ErlNifEnv* env,ERL_NIF_TERM term,ErlNifBinary* bin)int enif_inspect_iovec(ErlNifEnv* env,size_t max_elements,ERL_NIF_TERM iovec_term,ERL_NIF_TERM* tail,ErlNifIOVec** iovec)ErlNifIOQueue * enif_ioq_create(ErlNifIOQueueOpts opts)void enif_ioq_destroy(ErlNifIOQueue *q)int enif_ioq_deq(ErlNifIOQueue *q,size_t count,size_t *size)int enif_ioq_enq_binary(ErlNifIOQueue *q,ErlNifBinary *bin,size_t skip)int enif_ioq_enqv(ErlNifIOQueue *q,ErlNifIOVec *iovec,size_t skip)SysIOVec * enif_ioq_peek(ErlNifIOQueue *q,int *iovlen)int enif_ioq_peek_head(ErlNifEnv *env,ErlNifIOQueue *q,size_t *size,ERL_NIF_TERM *bin_term)size_t enif_ioq_size(ErlNifIOQueue *q)int enif_is_atom(ErlNifEnv* env,ERL_NIF_TERM term) int enif_is_binary(ErlNifEnv* env,ERL_NIF_TERM term) int enif_is_current_process_alive(ErlNifEnv* env) int enif_is_empty_list(ErlNifEnv* env,ERL_NIF_TERM term)int enif_is_exception(ErlNifEnv* env,ERL_NIF_TERM term)int enif_is_fun(ErlNifEnv* env,ERL_NIF_TERM term)int enif_is_identical(ERL_NIF_TERM lhs,ERL_NIF_TERM rhs)int enif_is_list(ErlNifEnv* env,ERL_NIF_TERM term) int enif_is_map(ErlNifEnv* env,ERL_NIF_TERM term)int enif_is_number(ErlNifEnv* env,ERL_NIF_TERM term)int enif_is_pid(ErlNifEnv* env,ERL_NIF_TERM term) int enif_is_pid_undefined(const ErlNifPid* pid)int enif_is_port(ErlNifEnv* env,ERL_NIF_TERM term) int enif_is_port_alive(ErlNifEnv* env,ErlNifPort *port_id)int enif_is_process_alive(ErlNifEnv* env,ErlNifPid *pid)int enif_is_ref(ErlNifEnv* env,ERL_NIF_TERM term) int enif_is_tuple(ErlNifEnv* env,ERL_NIF_TERM term) int enif_keep_resource(void* obj) ERL_NIF_TERM enif_make_atom(ErlNifEnv* env,const char* name) ERL_NIF_TERM enif_make_atom_len(ErlNifEnv* env,const char* name,size_t len)ERL_NIF_TERM enif_make_badarg(ErlNifEnv* env)ERL_NIF_TERM enif_make_binary(ErlNifEnv* env,ErlNifBinary* bin) ERL_NIF_TERM enif_make_copy(ErlNifEnv* dst_env,ERL_NIF_TERM src_term)ERL_NIF_TERM enif_make_double(ErlNifEnv* env,double d)int enif_make_existing_atom(ErlNifEnv* env,const char* name,ERL_NIF_TERM* atom,ErlNifCharEncoding encode)int enif_make_existing_atom_len(ErlNifEnv* env,const char* name,size_t len,ERL_NIF_TERM* atom,ErlNifCharEncoding encoding)ERL_NIF_TERM enif_make_int(ErlNifEnv* env,int i)ERL_NIF_TERM enif_make_int64(ErlNifEnv* env,ErlNifSInt64 i) ERL_NIF_TERM enif_make_list(ErlNifEnv* env,unsigned cnt,...) ERL_NIF_TERM enif_make_list1(ErlNifEnv* env,ERL_NIF_TERM e1) ERL_NIF_TERM enif_make_list2(ErlNifEnv* env,ERL_NIF_TERM e1,ERL_NIF_TERM e2)ERL_NIF_TERM enif_make_list3(ErlNifEnv* env,ERL_NIF_TERM e1,ERL_NIF_TERM e2,ERL_NIF_TERM e3)ERL_NIF_TERM enif_make_list4(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e4)ERL_NIF_TERM enif_make_list5(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e5)ERL_NIF_TERM enif_make_list6(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e6)ERL_NIF_TERM enif_make_list7(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e7)ERL_NIF_TERM enif_make_list8(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e8)ERL_NIF_TERM enif_make_list9(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e9)ERL_NIF_TERM enif_make_list_cell(ErlNifEnv* env,ERL_NIF_TERM head,ERL_NIF_TERM tail)ERL_NIF_TERM enif_make_list_from_array(ErlNifEnv* env,const ERL_NIF_TERM arr[],unsigned cnt)ERL_NIF_TERM enif_make_long(ErlNifEnv* env,long int i)int enif_make_map_put(ErlNifEnv* env,ERL_NIF_TERM map_in,ERL_NIF_TERM key,ERL_NIF_TERM value,ERL_NIF_TERM* map_out)int enif_make_map_remove(ErlNifEnv* env,ERL_NIF_TERM map_in,ERL_NIF_TERM key,ERL_NIF_TERM* map_out) int enif_make_map_update(ErlNifEnv* env,ERL_NIF_TERM map_in,ERL_NIF_TERM key,ERL_NIF_TERM new_value,ERL_NIF_TERM* map_out)int enif_make_map_from_arrays(ErlNifEnv* env,ERL_NIF_TERM keys[],ERL_NIF_TERM values[],size_t cnt,ERL_NIF_TERM *map_out)ERL_NIF_TERM enif_make_monitor_term(ErlNifEnv* env,const ErlNifMonitor* mon)unsigned char *enif_make_new_binary(ErlNifEnv* env,size_t size,ERL_NIF_TERM* termp)ERL_NIF_TERM enif_make_new_map(ErlNifEnv* env)ERL_NIF_TERM enif_make_pid(ErlNifEnv* env,const ErlNifPid* pid) ERL_NIF_TERM enif_make_ref(ErlNifEnv* env)ERL_NIF_TERM enif_make_resource(ErlNifEnv* env,void* obj) ERL_NIF_TERM enif_make_resource_binary(ErlNifEnv* env,void* obj,const void* data,size_t size)int enif_make_reverse_list(ErlNifEnv* env,ERL_NIF_TERM list_in,ERL_NIF_TERM *list_out)ERL_NIF_TERM enif_make_string(ErlNifEnv* env,const char* string,ErlNifCharEncoding encoding)ERL_NIF_TERM enif_make_string_len(ErlNifEnv* env,const char* string,size_t len,ErlNifCharEncoding encoding)ERL_NIF_TERM enif_make_sub_binary(ErlNifEnv* env,ERL_NIF_TERM bin_term,size_t pos,size_t size)ERL_NIF_TERM enif_make_tuple(ErlNifEnv* env,unsigned cnt,...)ERL_NIF_TERM enif_make_tuple1(ErlNifEnv* env,ERL_NIF_TERM e1)ERL_NIF_TERM enif_make_tuple2(ErlNifEnv* env,ERL_NIF_TERM e1,ERL_NIF_TERM e2)ERL_NIF_TERM enif_make_tuple3(ErlNifEnv* env,ERL_NIF_TERM e1,ERL_NIF_TERM e2,ERL_NIF_TERM e3)ERL_NIF_TERM enif_make_tuple4(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e4)ERL_NIF_TERM enif_make_tuple5(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e5)ERL_NIF_TERM enif_make_tuple6(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e6)ERL_NIF_TERM enif_make_tuple7(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e7)ERL_NIF_TERM enif_make_tuple8(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e8)ERL_NIF_TERM enif_make_tuple9(ErlNifEnv* env,ERL_NIF_TERM e1,...,ERL_NIF_TERM e9)ERL_NIF_TERM enif_make_tuple_from_array(ErlNifEnv* env,const ERL_NIF_TERM arr[],unsigned cnt)ERL_NIF_TERM enif_make_uint(ErlNifEnv* env,unsigned int i) ERL_NIF_TERM enif_make_uint64(ErlNifEnv* env,ErlNifUInt64 i) ERL_NIF_TERM enif_make_ulong(ErlNifEnv* env,unsigned long i) ERL_NIF_TERM enif_make_unique_integer(ErlNifEnv *env,ErlNifUniqueInteger properties)int enif_map_iterator_create(ErlNifEnv *env,ERL_NIF_TERM map,ErlNifMapIterator *iter,ErlNifMapIteratorEntry entry)void enif_map_iterator_destroy(ErlNifEnv *env,ErlNifMapIterator *iter)int enif_map_iterator_get_pair(ErlNifEnv *env,ErlNifMapIterator *iter,ERL_NIF_TERM *key,ERL_NIF_TERM *value)int enif_map_iterator_is_head(ErlNifEnv *env,ErlNifMapIterator *iter)int enif_map_iterator_is_tail(ErlNifEnv *env,ErlNifMapIterator *iter)int enif_map_iterator_next(ErlNifEnv *env,ErlNifMapIterator *iter)int enif_map_iterator_prev(ErlNifEnv *env,ErlNifMapIterator *iter)int enif_monitor_process(ErlNifEnv* caller_env,void* obj,const ErlNifPid* target_pid,ErlNifMonitor* mon)ErlNifTime enif_monotonic_time(ErlNifTimeUnit time_unit) ErlNifMutex * enif_mutex_create(char *name)void enif_mutex_destroy(ErlNifMutex *mtx)void enif_mutex_lock(ErlNifMutex *mtx)char* enif_mutex_name(ErlNifMutex* mtx)int enif_mutex_trylock(ErlNifMutex *mtx)void enif_mutex_unlock(ErlNifMutex *mtx)ERL_NIF_TERM enif_now_time(ErlNifEnv *env)ErlNifResourceType * enif_open_resource_type(ErlNifEnv* env,const char* module_str,const char* name,ErlNifResourceDtor* dtor,ErlNifResourceFlags flags,ErlNifResourceFlags* tried) ErlNifResourceType * enif_open_resource_type_x(ErlNifEnv* env,const char* name,const ErlNifResourceTypeInit* init,ErlNifResourceFlags flags,ErlNifResourceFlags* tried) int enif_port_command(ErlNifEnv* env,const ErlNifPort* to_port,ErlNifEnv *msg_env,ERL_NIF_TERM msg) void * enif_priv_data(ErlNifEnv* env)ERL_NIF_TERM enif_raise_exception(ErlNifEnv* env,ERL_NIF_TERM reason)void * enif_realloc(void* ptr,size_t size)int enif_realloc_binary(ErlNifBinary* bin,size_t size) void enif_release_binary(ErlNifBinary* bin)void enif_release_resource(void* obj)ErlNifRWLock * enif_rwlock_create(char *name)void enif_rwlock_destroy(ErlNifRWLock *rwlck)char* enif_rwlock_name(ErlNifRWLock* rwlck)void enif_rwlock_rlock(ErlNifRWLock *rwlck)void enif_rwlock_runlock(ErlNifRWLock *rwlck)void enif_rwlock_rwlock(ErlNifRWLock *rwlck)void enif_rwlock_rwunlock(ErlNifRWLock *rwlck)int enif_rwlock_tryrlock(ErlNifRWLock *rwlck)int enif_rwlock_tryrwlock(ErlNifRWLock *rwlck)ERL_NIF_TERM enif_schedule_nif(ErlNifEnv* env,const char* fun_name,int flags,ERL_NIF_TERM (*fp)(ErlNifEnv* env,int argc,const ERL_NIF_TERM argv[]),int argc,const ERL_NIF_TERM argv[])int enif_select(ErlNifEnv* env,ErlNifEvent event,enum ErlNifSelectFlags mode,void* obj,const ErlNifPid* pid,ERL_NIF_TERM ref) int enif_select_read(ErlNifEnv* env,ErlNifEvent event,void* obj,const ErlNifPid* pid,ERL_NIF_TERM msg,ErlNifEnv* msg_env) int enif_select_write(ErlNifEnv* env,ErlNifEvent event,void* obj,const ErlNifPid* pid,ERL_NIF_TERM msg,ErlNifEnv* msg_env) ErlNifPid * enif_self(ErlNifEnv* caller_env,ErlNifPid* pid) int enif_send(ErlNifEnv* caller_env,ErlNifPid* to_pid,ErlNifEnv* msg_env,ERL_NIF_TERM msg)void enif_set_pid_undefined(ErlNifPid* pid)unsigned enif_sizeof_resource(void* obj)int enif_snprintf(char *str,size_t size,const char *format,...)void enif_system_info(ErlNifSysInfo *sys_info_ptr,size_t size)int enif_term_to_binary(ErlNifEnv *env,ERL_NIF_TERM term,ErlNifBinary *bin)ErlNifTermType enif_term_type(ErlNifEnv *env,ERL_NIF_TERM term) int enif_thread_create(char *name,ErlNifTid *tid,void * (*func)(void *),void *args,ErlNifThreadOpts *opts)void enif_thread_exit(void *resp)int enif_thread_join(ErlNifTid,void **respp)char* enif_thread_name(ErlNifTid tid)ErlNifThreadOpts * enif_thread_opts_create(char *name)void enif_thread_opts_destroy(ErlNifThreadOpts *opts) ErlNifTid enif_thread_self(void)int enif_thread_type(void)ErlNifTime enif_time_offset(ErlNifTimeUnit time_unit)void * enif_tsd_get(ErlNifTSDKey key)int enif_tsd_key_create(char *name,ErlNifTSDKey *key) void enif_tsd_key_destroy(ErlNifTSDKey key)void enif_tsd_set(ErlNifTSDKey key,void *data)int enif_vfprintf(FILE *stream,const char *format,va_list ap)int enif_vsnprintf(char *str,size_t size,const char *format,va_list ap)int enif_whereis_pid(ErlNifEnv *env,ERL_NIF_TERM name,ErlNifPid *pid)int enif_whereis_port(ErlNifEnv *env,ERL_NIF_TERM name,ErlNifPort *port)"
  ],
  [
    "erl_parse",
    "abstract(Data) -> AbsTermabstract(Data, Options) -> AbsTermanno_from_term(Term) -> erl_parse_tree() | form_info() anno_to_term(Abstr) -> term()fold_anno(Fun, Acc0, Abstr) -> Acc1map_anno(Fun, Abstr) -> NewAbstrmapfold_anno(Fun, Acc0, Abstr) -> {NewAbstr, Acc1}new_anno(Term) -> Abstrnormalise(AbsTerm) -> Dataparse_exprs(Tokens) -> {ok, ExprList} | {error, ErrorInfo}parse_form(Tokens) -> {ok, AbsForm} | {error, ErrorInfo}parse_term(Tokens) -> {ok, Term} | {error, ErrorInfo}tokens(AbsTerm) -> Tokenstokens(AbsTerm, MoreTokens) -> Tokens",
    "format_error(ErrorDescriptor) -> Chars"
  ],
  [
    "erl_pp",
    "attribute(Attribute) -> io_lib:chars() attribute(Attribute, Options) -> io_lib:chars() expr(Expression) -> io_lib:chars() expr(Expression, Options) -> io_lib:chars() expr(Expression, Indent, Options) -> io_lib:chars() expr(Expression, Indent, Precedence, Options) -> io_lib:chars() exprs(Expressions) -> io_lib:chars() exprs(Expressions, Options) -> io_lib:chars() exprs(Expressions, Indent, Options) -> io_lib:chars() form(Form) -> io_lib:chars() form(Form, Options) -> io_lib:chars() function(Function) -> io_lib:chars() function(Function, Options) -> io_lib:chars() guard(Guard) -> io_lib:chars() guard(Guard, Options) -> io_lib:chars()"
  ],
  [
    "erl_prettypr",
    "best(Tree::syntaxTree()) -> empty | prettypr:document()best(Tree::syntaxTree(), Options::[term()]) -> empty | prettypr:document()format(Tree::syntaxTree()) -> string()format(Tree::syntaxTree(), Options::[term()]) -> string()get_ctxt_hook(Ctxt::context()) -> hook()get_ctxt_linewidth(Ctxt::context()) -> integer()get_ctxt_paperwidth(Ctxt::context()) -> integer()get_ctxt_precedence(Ctxt::context()) -> integer()get_ctxt_user(Ctxt::context()) -> term()layout(Tree::syntaxTree()) -> prettypr:document()layout(Tree::syntaxTree(), Options::[term()]) -> prettypr:document()set_ctxt_hook(Ctxt::context(), Hook::hook()) -> context()set_ctxt_linewidth(Ctxt::context(), W::integer()) -> context()set_ctxt_paperwidth(Ctxt::context(), W::integer()) -> context()set_ctxt_precedence(Ctxt::context(), Prec::integer()) -> context()set_ctxt_user(Ctxt::context(), X::term()) -> context()"
  ],
  [
    "erl_prim_loader",
    "get_file(Filename) -> {ok, Bin, FullName} | errorget_path() -> {ok, Path}list_dir(Dir) -> {ok, Filenames} | errorread_file_info(Filename) -> {ok, FileInfo} | errorread_link_info(Filename) -> {ok, FileInfo} | errorset_path(Path) -> ok"
  ],
  [
    "erl_recomment",
    "quick_recomment_forms(Tree::Forms, Comments::[Comment]) -> syntaxTree()recomment_forms(Tree::Forms, Comments::[Comment]) -> syntaxTree()recomment_tree(Tree::syntaxTree(), Comments::[Comment]) -> {syntaxTree(), [Comment]}"
  ],
  [
    "erl_scan",
    "category(Token) -> category() column(Token) -> erl_anno:column() | undefinedend_location(Token) -> erl_anno:location() | undefinedformat_error(ErrorDescriptor) -> string()line(Token) -> erl_anno:line() location(Token) -> erl_anno:location() reserved_word(Atom :: atom()) -> boolean()string(String) -> Returnstring(String, StartLocation) -> Returnstring(String, StartLocation, Options) -> Returnsymbol(Token) -> symbol() text(Token) -> erl_anno:text() | undefinedtokens(Continuation, CharSpec, StartLocation) -> Returntokens(Continuation, CharSpec, StartLocation, Options) -> Return"
  ],
  [
    "erl_syntax",
    "abstract(T::term()) -> syntaxTree()add_ann(A::term(), Node::syntaxTree()) -> syntaxTree()add_postcomments(Cs::[syntaxTree()], Node::syntaxTree()) -> syntaxTree()add_precomments(Cs::[syntaxTree()], Node::syntaxTree()) -> syntaxTree()annotated_type(Name::syntaxTree(), Type::syntaxTree()) -> syntaxTree()annotated_type_body(Node::syntaxTree()) -> syntaxTree()annotated_type_name(Node::syntaxTree()) -> syntaxTree()application(Operator::syntaxTree(), Arguments::[syntaxTree()]) -> syntaxTree()application(Module::none | syntaxTree(), Name::syntaxTree(), Arguments::[syntaxTree()]) -> syntaxTree()application_arguments(Node::syntaxTree()) -> [syntaxTree()]application_operator(Node::syntaxTree()) -> syntaxTree()arity_qualifier(Body::syntaxTree(), Arity::syntaxTree()) -> syntaxTree()arity_qualifier_argument(Node::syntaxTree()) -> syntaxTree()arity_qualifier_body(Node::syntaxTree()) -> syntaxTree()atom(Name::atom() | string()) -> syntaxTree()atom_literal(Node::syntaxTree()) -> string()atom_literal(Node, X2) -> term()atom_name(Node::syntaxTree()) -> string()atom_value(Node::syntaxTree()) -> atom()attribute(Name::syntaxTree()) -> syntaxTree()attribute(Name::syntaxTree(), Args::none | [syntaxTree()]) -> syntaxTree()attribute_arguments(Node::syntaxTree()) -> none | [syntaxTree()]attribute_name(Node::syntaxTree()) -> syntaxTree()binary(List::[syntaxTree()]) -> syntaxTree()binary_comp(Template::syntaxTree(), Body::[syntaxTree()]) -> syntaxTree()binary_comp_body(Node::syntaxTree()) -> [syntaxTree()]binary_comp_template(Node::syntaxTree()) -> syntaxTree()binary_field(Body::syntaxTree()) -> syntaxTree()binary_field(Body::syntaxTree(), Types::[syntaxTree()]) -> syntaxTree()binary_field(Body::syntaxTree(), Size::none | syntaxTree(), Types::[syntaxTree()]) -> syntaxTree()binary_field_body(Node::syntaxTree()) -> syntaxTree()binary_field_size(Node::syntaxTree()) -> none | syntaxTree()binary_field_types(Node::syntaxTree()) -> [syntaxTree()]binary_fields(Node::syntaxTree()) -> [syntaxTree()]binary_generator(Pattern::syntaxTree(), Body::syntaxTree()) -> syntaxTree()binary_generator_body(Node::syntaxTree()) -> syntaxTree()binary_generator_pattern(Node::syntaxTree()) -> syntaxTree()bitstring_type(M::syntaxTree(), N::syntaxTree()) -> syntaxTree()bitstring_type_m(Node::syntaxTree()) -> syntaxTree()bitstring_type_n(Node::syntaxTree()) -> syntaxTree()block_expr(Body::[syntaxTree()]) -> syntaxTree()block_expr_body(Node::syntaxTree()) -> [syntaxTree()]case_expr(Argument::syntaxTree(), Clauses::[syntaxTree()]) -> syntaxTree()case_expr_argument(Node::syntaxTree()) -> syntaxTree()case_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]catch_expr(Expr::syntaxTree()) -> syntaxTree()catch_expr_body(Node::syntaxTree()) -> syntaxTree()char(Char::char()) -> syntaxTree()char_literal(Node::syntaxTree()) -> nonempty_string()char_literal(Node::syntaxTree(), X2::encoding()) -> nonempty_string()char_value(Node::syntaxTree()) -> char()class_qualifier(Class::syntaxTree(), Body::syntaxTree()) -> syntaxTree()class_qualifier(Class::syntaxTree(), Body::syntaxTree(), Stacktrace::syntaxTree()) -> syntaxTree()class_qualifier_argument(Node::syntaxTree()) -> syntaxTree()class_qualifier_body(Node::syntaxTree()) -> syntaxTree()class_qualifier_stacktrace(Node::syntaxTree()) -> syntaxTree()clause(Guard::guard(), Body::[syntaxTree()]) -> syntaxTree()clause(Patterns::[syntaxTree()], Guard::guard(), Body::[syntaxTree()]) -> syntaxTree()clause_body(Node::syntaxTree()) -> [syntaxTree()]clause_guard(Node::syntaxTree()) -> none | syntaxTree()clause_patterns(Node::syntaxTree()) -> [syntaxTree()]comment(Strings::[string()]) -> syntaxTree()comment(Pad::padding(), Strings::[string()]) -> syntaxTree()comment_padding(Node::syntaxTree()) -> padding()comment_text(Node::syntaxTree()) -> [string()]compact_list(Node::syntaxTree()) -> syntaxTree()concrete(Node::syntaxTree()) -> term()cond_expr(Clauses::[syntaxTree()]) -> syntaxTree()cond_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]conjunction(Tests::[syntaxTree()]) -> syntaxTree()conjunction_body(Node::syntaxTree()) -> [syntaxTree()]cons(Head::syntaxTree(), Tail::syntaxTree()) -> syntaxTree()constrained_function_type(FunctionType::syntaxTree(), FunctionConstraint::[syntaxTree()]) -> syntaxTree()constrained_function_type_argument(Node::syntaxTree()) -> syntaxTree()constrained_function_type_body(Node::syntaxTree()) -> syntaxTree()constraint(Name::syntaxTree(), Types::[syntaxTree()]) -> syntaxTree()constraint_argument(Node::syntaxTree()) -> syntaxTree()constraint_body(Node::syntaxTree()) -> [syntaxTree()]copy_ann(Source::syntaxTree(), Target::syntaxTree()) -> syntaxTree()copy_attrs(S::syntaxTree(), T::syntaxTree()) -> syntaxTree()copy_comments(Source::syntaxTree(), Target::syntaxTree()) -> syntaxTree()copy_pos(Source::syntaxTree(), Target::syntaxTree()) -> syntaxTree()data(Tree::syntaxTree()) -> term()disjunction(Tests::[syntaxTree()]) -> syntaxTree()disjunction_body(Node::syntaxTree()) -> [syntaxTree()]eof_marker() -> syntaxTree()error_marker(Error::term()) -> syntaxTree()error_marker_info(Node::syntaxTree()) -> term()flatten_form_list(Node::syntaxTree()) -> syntaxTree()float(Value::float()) -> syntaxTree()float_literal(Node::syntaxTree()) -> string()float_value(Node::syntaxTree()) -> float()form_list(Forms::[syntaxTree()]) -> syntaxTree()form_list_elements(Node::syntaxTree()) -> [syntaxTree()]fun_expr(Clauses::[syntaxTree()]) -> syntaxTree()fun_expr_arity(Node::syntaxTree()) -> arity()fun_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]fun_type() -> syntaxTree()function(Name::syntaxTree(), Clauses::[syntaxTree()]) -> syntaxTree()function_arity(Node::syntaxTree()) -> arity()function_clauses(Node::syntaxTree()) -> [syntaxTree()]function_name(Node::syntaxTree()) -> syntaxTree()function_type(Type) -> term()function_type(Arguments::any_arity | syntaxTree(), Return::syntaxTree()) -> syntaxTree()function_type_arguments(Node::syntaxTree()) -> any_arity | [syntaxTree()]function_type_return(Node::syntaxTree()) -> syntaxTree()generator(Pattern::syntaxTree(), Body::syntaxTree()) -> syntaxTree()generator_body(Node::syntaxTree()) -> syntaxTree()generator_pattern(Node::syntaxTree()) -> syntaxTree()get_ann(Tree::syntaxTree()) -> [term()]get_attrs(Tree::syntaxTree()) -> syntaxTreeAttributes()get_pos(Tree::syntaxTree()) -> term()get_postcomments(Tree::syntaxTree()) -> [syntaxTree()]get_precomments(Tree::syntaxTree()) -> [syntaxTree()]has_comments(Tree::syntaxTree()) -> boolean()if_expr(Clauses::[syntaxTree()]) -> syntaxTree()if_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]implicit_fun(Name::syntaxTree()) -> syntaxTree()implicit_fun(Name::syntaxTree(), Arity::none | syntaxTree()) -> syntaxTree()implicit_fun(Module::none | syntaxTree(), Name::syntaxTree(), Arity::syntaxTree()) -> syntaxTree()implicit_fun_name(Node::syntaxTree()) -> syntaxTree()infix_expr(Left::syntaxTree(), Operator::syntaxTree(), Right::syntaxTree()) -> syntaxTree()infix_expr_left(Node::syntaxTree()) -> syntaxTree()infix_expr_operator(Node::syntaxTree()) -> syntaxTree()infix_expr_right(Node::syntaxTree()) -> syntaxTree()integer(Value::integer()) -> syntaxTree()integer_literal(Node::syntaxTree()) -> string()integer_range_type(Low::syntaxTree(), High::syntaxTree()) -> syntaxTree()integer_range_type_high(Node::syntaxTree()) -> syntaxTree()integer_range_type_low(Node::syntaxTree()) -> syntaxTree()integer_value(Node::syntaxTree()) -> integer()is_atom(Node::syntaxTree(), Value::atom()) -> boolean()is_char(Node::syntaxTree(), Value::char()) -> boolean()is_form(Node::syntaxTree()) -> boolean()is_integer(Node::syntaxTree(), Value::integer()) -> boolean()is_leaf(Node::syntaxTree()) -> boolean()is_list_skeleton(Node::syntaxTree()) -> boolean()is_literal(T::syntaxTree()) -> boolean()is_proper_list(Node::syntaxTree()) -> boolean()is_string(Node::syntaxTree(), Value::string()) -> boolean()is_tree(Tree::syntaxTree()) -> boolean()join_comments(Source::syntaxTree(), Target::syntaxTree()) -> syntaxTree()list(List::[syntaxTree()]) -> syntaxTree()list(Elements::[syntaxTree()], Tail::none | syntaxTree()) -> syntaxTree()list_comp(Template::syntaxTree(), Body::[syntaxTree()]) -> syntaxTree()list_comp_body(Node::syntaxTree()) -> [syntaxTree()]list_comp_template(Node::syntaxTree()) -> syntaxTree()list_elements(Node::syntaxTree()) -> [syntaxTree()]list_head(Node::syntaxTree()) -> syntaxTree()list_length(Node::syntaxTree()) -> non_neg_integer()list_prefix(Node::syntaxTree()) -> [syntaxTree()]list_suffix(Node::syntaxTree()) -> none | syntaxTree()list_tail(Node::syntaxTree()) -> syntaxTree()macro(Name::syntaxTree()) -> syntaxTree()macro(Name::syntaxTree(), Arguments::none | [syntaxTree()]) -> syntaxTree()macro_arguments(Node::syntaxTree()) -> none | [syntaxTree()]macro_name(Node::syntaxTree()) -> syntaxTree()make_tree(X1::atom(), X2::[[syntaxTree()]]) -> syntaxTree()map_expr(Fields::[syntaxTree()]) -> syntaxTree()map_expr(Argument::none | syntaxTree(), Fields::[syntaxTree()]) -> syntaxTree()map_expr_argument(Node::syntaxTree()) -> none | syntaxTree()map_expr_fields(Node::syntaxTree()) -> [syntaxTree()]map_field_assoc(Name::syntaxTree(), Value::syntaxTree()) -> syntaxTree()map_field_assoc_name(Node::syntaxTree()) -> syntaxTree()map_field_assoc_value(Node::syntaxTree()) -> syntaxTree()map_field_exact(Name::syntaxTree(), Value::syntaxTree()) -> syntaxTree()map_field_exact_name(Node::syntaxTree()) -> syntaxTree()map_field_exact_value(Node::syntaxTree()) -> syntaxTree()map_type() -> term()map_type(Fields::any_size | [syntaxTree()]) -> syntaxTree()map_type_assoc(Name::syntaxTree(), Value::syntaxTree()) -> syntaxTree()map_type_assoc_name(Node::syntaxTree()) -> syntaxTree()map_type_assoc_value(Node::syntaxTree()) -> syntaxTree()map_type_exact(Name::syntaxTree(), Value::syntaxTree()) -> syntaxTree()map_type_exact_name(Node::syntaxTree()) -> syntaxTree()map_type_exact_value(Node::syntaxTree()) -> syntaxTree()map_type_fields(Node::syntaxTree()) -> any_size | [syntaxTree()]match_expr(Pattern::syntaxTree(), Body::syntaxTree()) -> syntaxTree()match_expr_body(Node::syntaxTree()) -> syntaxTree()match_expr_pattern(Node::syntaxTree()) -> syntaxTree()meta(T::syntaxTree()) -> syntaxTree()module_qualifier(Module::syntaxTree(), Body::syntaxTree()) -> syntaxTree()module_qualifier_argument(Node::syntaxTree()) -> syntaxTree()module_qualifier_body(Node::syntaxTree()) -> syntaxTree()named_fun_expr(Name::syntaxTree(), Clauses::[syntaxTree()]) -> syntaxTree()named_fun_expr_arity(Node::syntaxTree()) -> arity()named_fun_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]named_fun_expr_name(Node::syntaxTree()) -> syntaxTree()nil() -> syntaxTree()normalize_list(Node::syntaxTree()) -> syntaxTree()operator(Name::atom() | string()) -> syntaxTree()operator_literal(Node::syntaxTree()) -> string()operator_name(Node::syntaxTree()) -> atom()parentheses(Expr::syntaxTree()) -> syntaxTree()parentheses_body(Node::syntaxTree()) -> syntaxTree()prefix_expr(Operator::syntaxTree(), Argument::syntaxTree()) -> syntaxTree()prefix_expr_argument(Node::syntaxTree()) -> syntaxTree()prefix_expr_operator(Node::syntaxTree()) -> syntaxTree()receive_expr(Clauses::[syntaxTree()]) -> syntaxTree()receive_expr(Clauses::[syntaxTree()], Timeout::none | syntaxTree(), Action::[syntaxTree()]) -> syntaxTree()receive_expr_action(Node::syntaxTree()) -> [syntaxTree()]receive_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]receive_expr_timeout(Node::syntaxTree()) -> none | syntaxTree()record_access(Argument::syntaxTree(), Type::syntaxTree(), Field::syntaxTree()) -> syntaxTree()record_access_argument(Node::syntaxTree()) -> syntaxTree()record_access_field(Node::syntaxTree()) -> syntaxTree()record_access_type(Node::syntaxTree()) -> syntaxTree()record_expr(Type::syntaxTree(), Fields::[syntaxTree()]) -> syntaxTree()record_expr(Argument::none | syntaxTree(), Type::syntaxTree(), Fields::[syntaxTree()]) -> syntaxTree()record_expr_argument(Node::syntaxTree()) -> none | syntaxTree()record_expr_fields(Node::syntaxTree()) -> [syntaxTree()]record_expr_type(Node::syntaxTree()) -> syntaxTree()record_field(Name::syntaxTree()) -> syntaxTree()record_field(Name::syntaxTree(), Value::none | syntaxTree()) -> syntaxTree()record_field_name(Node::syntaxTree()) -> syntaxTree()record_field_value(Node::syntaxTree()) -> none | syntaxTree()record_index_expr(Type::syntaxTree(), Field::syntaxTree()) -> syntaxTree()record_index_expr_field(Node::syntaxTree()) -> syntaxTree()record_index_expr_type(Node::syntaxTree()) -> syntaxTree()record_type(Name::syntaxTree(), Fields::[syntaxTree()]) -> syntaxTree()record_type_field(Name::syntaxTree(), Type::syntaxTree()) -> syntaxTree()record_type_field_name(Node::syntaxTree()) -> syntaxTree()record_type_field_type(Node::syntaxTree()) -> syntaxTree()record_type_fields(Node::syntaxTree()) -> [syntaxTree()]record_type_name(Node::syntaxTree()) -> syntaxTree()remove_comments(Node::syntaxTree()) -> syntaxTree()revert(Node::syntaxTree()) -> syntaxTree()revert_forms(Forms::forms()) -> [erl_parse()]set_ann(Node::syntaxTree(), As::[term()]) -> syntaxTree()set_attrs(Node::syntaxTree(), Attr::syntaxTreeAttributes()) -> syntaxTree()set_pos(Node::syntaxTree(), Pos::term()) -> syntaxTree()set_postcomments(Node::syntaxTree(), Cs::[syntaxTree()]) -> syntaxTree()set_precomments(Node::syntaxTree(), Cs::[syntaxTree()]) -> syntaxTree()size_qualifier(Body::syntaxTree(), Size::syntaxTree()) -> syntaxTree()size_qualifier_argument(Node::syntaxTree()) -> syntaxTree()size_qualifier_body(Node::syntaxTree()) -> syntaxTree()string(String::string()) -> syntaxTree()string_literal(Node::syntaxTree()) -> nonempty_string()string_literal(Node::syntaxTree(), X2::encoding()) -> nonempty_string()string_value(Node::syntaxTree()) -> string()subtrees(T::syntaxTree()) -> [[syntaxTree()]]text(String::string()) -> syntaxTree()text_string(Node::syntaxTree()) -> string()tree(Type::atom()) -> #tree{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[syntaxTree()], post=[syntaxTree()]}}, data=term()}tree(Type::atom(), Data::term()) -> #tree{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[syntaxTree()], post=[syntaxTree()]}}, data=term()}try_after_expr(Body::[syntaxTree()], After::[syntaxTree()]) -> syntaxTree()try_expr(Body::[syntaxTree()], Handlers::[syntaxTree()]) -> syntaxTree()try_expr(Body::[syntaxTree()], Clauses::[syntaxTree()], Handlers::[syntaxTree()]) -> syntaxTree()try_expr(Body::[syntaxTree()], Clauses::[syntaxTree()], Handlers::[syntaxTree()], After::[syntaxTree()]) -> syntaxTree()try_expr_after(Node::syntaxTree()) -> [syntaxTree()]try_expr_body(Node::syntaxTree()) -> [syntaxTree()]try_expr_clauses(Node::syntaxTree()) -> [syntaxTree()]try_expr_handlers(Node::syntaxTree()) -> [syntaxTree()]tuple(List::[syntaxTree()]) -> syntaxTree()tuple_elements(Node::syntaxTree()) -> [syntaxTree()]tuple_size(Node::syntaxTree()) -> non_neg_integer()tuple_type() -> term()tuple_type(Elements::any_size | [syntaxTree()]) -> syntaxTree()tuple_type_elements(Node::syntaxTree()) -> any_size | [syntaxTree()]type(Tree::syntaxTree()) -> atom()type_application(TypeName::syntaxTree(), Arguments::[syntaxTree()]) -> syntaxTree()type_application(Module::none | syntaxTree(), TypeName::syntaxTree(), Arguments::[syntaxTree()]) -> syntaxTree()type_application_arguments(Node::syntaxTree()) -> [syntaxTree()]type_application_name(Node::syntaxTree()) -> syntaxTree()type_union(Types::[syntaxTree()]) -> syntaxTree()type_union_types(Node::syntaxTree()) -> [syntaxTree()]typed_record_field(Field::syntaxTree(), Type::syntaxTree()) -> syntaxTree()typed_record_field_body(Node::syntaxTree()) -> syntaxTree()typed_record_field_type(Node::syntaxTree()) -> syntaxTree()underscore() -> syntaxTree()update_tree(Node::syntaxTree(), Groups::[[syntaxTree()]]) -> syntaxTree()user_type_application(TypeName::syntaxTree(), Arguments::[syntaxTree()]) -> syntaxTree()user_type_application_arguments(Node::syntaxTree()) -> [syntaxTree()]user_type_application_name(Node::syntaxTree()) -> syntaxTree()variable(Name::atom() | string()) -> syntaxTree()variable_literal(Node::syntaxTree()) -> string()variable_name(Node::syntaxTree()) -> atom()warning_marker(Warning::term()) -> syntaxTree()warning_marker_info(Node::syntaxTree()) -> term()"
  ],
  [
    "erl_syntax_lib",
    "analyze_application(Node::syntaxTree()) -> FunctionName | Arityanalyze_attribute(Node::syntaxTree()) -> preprocessor | {atom(), atom()}analyze_export_attribute(Node::syntaxTree()) -> [FunctionName]analyze_file_attribute(Node::syntaxTree()) -> {string(), integer()}analyze_form(Node::syntaxTree()) -> {atom(), term()} | atom()analyze_forms(Forms) -> [{Key, term()}]analyze_function(Node::syntaxTree()) -> {atom(), integer()}analyze_function_name(Node::syntaxTree()) -> FunctionNameanalyze_implicit_fun(Node::syntaxTree()) -> FunctionNameanalyze_import_attribute(Node::syntaxTree()) -> {atom(), [FunctionName]} | atom()analyze_module_attribute(Node::syntaxTree()) -> Name::atom() | {Name::atom(), Variables::[atom()]}analyze_record_attribute(Node::syntaxTree()) -> {atom(), Fields}analyze_record_expr(Node::syntaxTree()) -> {atom(), Info} | atom()analyze_record_field(Node::syntaxTree()) -> {atom(), {Default, Type}}analyze_type_application(Node::syntaxTree()) -> TypeNameanalyze_type_name(Node::syntaxTree()) -> TypeNameanalyze_wild_attribute(Node::syntaxTree()) -> {atom(), term()}annotate_bindings(Tree::syntaxTree()) -> syntaxTree()annotate_bindings(Tree::syntaxTree(), Bindings::ordset(atom())) -> syntaxTree()fold(F::Function, Start::term(), Tree::syntaxTree()) -> term()fold_subtrees(F::Function, Start::term(), Tree::syntaxTree()) -> term()foldl_listlist(F::Function, Start::term(), Ls::[[term()]]) -> term()function_name_expansions(Names::[Name]) -> [{ShortName, Name}]is_fail_expr(Tree::syntaxTree()) -> boolean()limit(Tree, Depth) -> syntaxTree()limit(Tree::syntaxTree(), Depth::integer(), Node::syntaxTree()) -> syntaxTree()map(F::Function, Tree::syntaxTree()) -> syntaxTree()map_subtrees(F::Function, Tree::syntaxTree()) -> syntaxTree()mapfold(F::Function, Start::term(), Tree::syntaxTree()) -> {syntaxTree(), term()}mapfold_subtrees(F::Function, Start::term(), Tree::syntaxTree()) -> {syntaxTree(), term()}mapfoldl_listlist(F::Function, S::State, Ls::[[term()]]) -> {[[term()]], term()}new_variable_name(Used::set(atom())) -> atom()new_variable_name(F::Function, Used::set(atom())) -> atom()new_variable_names(N::integer(), Used::set(atom())) -> [atom()]new_variable_names(N::integer(), F::Function, Used::set(atom())) -> [atom()]strip_comments(Tree::syntaxTree()) -> syntaxTree()to_comment(Tree) -> syntaxTree()to_comment(Tree::syntaxTree(), Prefix::string()) -> syntaxTree()to_comment(Tree::syntaxTree(), Prefix::string(), F::Printer) -> syntaxTree()variables(Tree::syntaxTree()) -> set(atom())"
  ],
  [
    "erl_tar",
    "add(TarDescriptor, AddType, Options) -> ok | {error, term()}add(TarDescriptor, Filename, NameInArchive, Options) -> ok | {error, term()}close(TarDescriptor :: tar_descriptor()) -> ok | {error, term()}create(Name :: file:filename_all(), FileList :: filelist()) -> ok | {error, {string(), term()}}create(Name :: file:filename_all(), FileList :: filelist(), Options :: [create_opt()]) -> ok | {error, term()} | {error, {string(), term()}}extract(Open :: open_type()) -> ok | {error, term()}extract(Open :: open_type(), Opts :: [extract_opt()]) -> {ok, [{string(), binary()}]} | {error, term()} | okformat_error(Atom :: term()) -> string()init(UserData :: user_data(), AccessMode :: write | read, Fun :: file_op()) -> {ok, tar_descriptor()} | {error, badarg}open(Open :: open_type(), Mode :: [write | compressed | cooked]) -> {ok, tar_descriptor()} | {error, term()}table(Open :: open_type()) -> {ok, [name_in_archive()]} | {error, term()}table(Open :: open_type(), Opts :: [compressed | verbose | cooked]) -> {ok, [name_in_archive() | tar_entry()]} | {error, term()}t(Name :: file:filename()) -> ok | {error, term()}tt(Name :: open_type()) -> ok | {error, term()}"
  ],
  [
    "erl_tidy",
    "dir() -> okdir(Dir) -> okdir(Directory::filename(), Options::[term()]) -> okfile(Name) -> okfile(Name::filename(), Options::[term()]) -> okmodule(Forms) -> syntaxTree()module(Forms, Options::[term()]) -> syntaxTree()"
  ],
  [
    "erl_tracer",
    "Module:enabled(TraceTag, TracerState, Tracee) -> ResultModule:enabled_call(TraceTag, TracerState, Tracee) -> ResultModule:enabled_garbage_collection(TraceTag, TracerState, Tracee) -> ResultModule:enabled_ports(TraceTag, TracerState, Tracee) -> ResultModule:enabled_procs(TraceTag, TracerState, Tracee) -> ResultModule:enabled_receive(TraceTag, TracerState, Tracee) -> Result Module:enabled_running_ports(TraceTag, TracerState, Tracee) -> ResultModule:enabled_running_procs(TraceTag, TracerState, Tracee) -> ResultModule:enabled_send(TraceTag, TracerState, Tracee) -> ResultModule:trace(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace(seq_trace, TracerState, Label, SeqTraceInfo, Opts) -> ResultModule:trace_call(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_garbage_collection(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_ports(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_procs(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_receive(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_running_ports(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_running_procs(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> ResultModule:trace_send(TraceTag, TracerState, Tracee, TraceTerm, Opts) -> Result"
  ],
  [
    "erlang",
    "abs(Float) -> float()abs(Int) -> integer() >= 0erlang:adler32(Data) -> integer() >= 0erlang:adler32(OldAdler, Data) -> integer() >= 0erlang:adler32_combine(FirstAdler, SecondAdler, SecondSize) -> integer() >= 0erlang:append_element(Tuple1, Term) -> Tuple2apply(Fun, Args) -> term()apply(Module, Function, Args) -> term()atom_to_binary(Atom, Encoding) -> binary()atom_to_list(Atom) -> string()binary_part(Subject, PosLen) -> binary()binary_part(Subject, Start, Length) -> binary()binary_to_atom(Binary, Encoding) -> atom()binary_to_existing_atom(Binary, Encoding) -> atom()binary_to_float(Binary) -> float()binary_to_integer(Binary) -> integer()binary_to_integer(Binary, Base) -> integer()binary_to_list(Binary) -> [byte()]binary_to_list(Binary, Start, Stop) -> [byte()]binary_to_term(Binary) -> term()binary_to_term(Binary, Opts) -> term() | {term(), Used}bit_size(Bitstring) -> integer() >= 0bitstring_to_list(Bitstring) -> [byte() | bitstring()]erlang:bump_reductions(Reductions) -> truebyte_size(Bitstring) -> integer() >= 0erlang:cancel_timer(TimerRef) -> Resulterlang:cancel_timer(TimerRef, Options) -> Result | okceil(Number) -> integer()check_old_code(Module) -> boolean()check_process_code(Pid, Module) -> CheckResultcheck_process_code(Pid, Module, OptionList) -> CheckResult | asyncerlang:convert_time_unit(Time, FromUnit, ToUnit) -> ConvertedTimeerlang:crc32(Data) -> integer() >= 0erlang:crc32(OldCrc, Data) -> integer() >= 0erlang:crc32_combine(FirstCrc, SecondCrc, SecondSize) -> integer() >= 0date() -> Dateerlang:decode_packet(Type, Bin, Options) -> {ok, Packet, Rest} | {more, Length} | {error, Reason}erlang:delete_element(Index, Tuple1) -> Tuple2delete_module(Module) -> true | undefineddemonitor(MonitorRef) -> truedemonitor(MonitorRef, OptionList) -> boolean()disconnect_node(Node) -> boolean() | ignorederlang:display(Term) -> trueerlang:dist_ctrl_get_data(DHandle) -> {Size, Data} | Data | noneerlang:dist_ctrl_get_opt(DHandle, Opt :: get_size) -> Valueerlang:dist_ctrl_get_data_notification(DHandle) -> okerlang:dist_ctrl_input_handler(DHandle, InputHandler) -> okerlang:dist_ctrl_put_data(DHandle, Data) -> okerlang:dist_ctrl_set_opt(DHandle, Opt :: get_size, Value) -> OldValueelement(N, Tuple) -> term()erase() -> [{Key, Val}]erase(Key) -> Val | undefinederror(Reason) -> no_return()error(Reason, Args) -> no_return()exit(Reason) -> no_return()exit(Pid, Reason) -> trueerlang:external_size(Term) -> integer() >= 0erlang:external_size(Term, Options) -> integer() >= 0float(Number) -> float()float_to_binary(Float) -> binary()float_to_binary(Float, Options) -> binary()float_to_list(Float) -> string()float_to_list(Float, Options) -> string()floor(Number) -> integer()erlang:fun_info(Fun) -> [{Item, Info}]erlang:fun_info(Fun, Item) -> {Item, Info}erlang:fun_to_list(Fun) -> string()erlang:function_exported(Module, Function, Arity) -> boolean()garbage_collect() -> truegarbage_collect(Pid) -> GCResultgarbage_collect(Pid, OptionList) -> GCResult | asyncget() -> [{Key, Val}]get(Key) -> Val | undefinederlang:get_cookie() -> Cookie | nocookieget_keys() -> [Key]get_keys(Val) -> [Key]erlang:get_stacktrace() -> [stack_item()]group_leader() -> pid()group_leader(GroupLeader, Pid) -> truehalt() -> no_return()halt(Status) -> no_return()halt(Status, Options) -> no_return()hd(List) -> term()erlang:hibernate(Module, Function, Args) -> no_return()erlang:insert_element(Index, Tuple1, Term) -> Tuple2integer_to_binary(Integer) -> binary()integer_to_binary(Integer, Base) -> binary()integer_to_list(Integer) -> string()integer_to_list(Integer, Base) -> string()iolist_size(Item) -> integer() >= 0iolist_to_binary(IoListOrBinary) -> binary()erlang:iolist_to_iovec(IoListOrBinary) -> iovec() is_alive() -> boolean()is_atom(Term) -> boolean()is_binary(Term) -> boolean()is_bitstring(Term) -> boolean()is_boolean(Term) -> boolean()erlang:is_builtin(Module, Function, Arity) -> boolean()is_float(Term) -> boolean()is_function(Term) -> boolean()is_function(Term, Arity) -> boolean()is_integer(Term) -> boolean()is_list(Term) -> boolean()is_map(Term) -> boolean()is_map_key(Key, Map) -> boolean()is_number(Term) -> boolean()is_pid(Term) -> boolean()is_port(Term) -> boolean()is_process_alive(Pid) -> boolean()is_record(Term, RecordTag) -> boolean()is_record(Term, RecordTag, Size) -> boolean()is_reference(Term) -> boolean()is_tuple(Term) -> boolean()length(List) -> integer() >= 0link(PidOrPort) -> truelist_to_atom(String) -> atom()list_to_binary(IoList) -> binary()list_to_bitstring(BitstringList) -> bitstring()list_to_existing_atom(String) -> atom()list_to_float(String) -> float()list_to_integer(String) -> integer()list_to_integer(String, Base) -> integer()list_to_pid(String) -> pid()list_to_port(String) -> port()list_to_ref(String) -> reference()list_to_tuple(List) -> tuple()load_module(Module, Binary) -> {module, Module} | {error, Reason}erlang:load_nif(Path, LoadInfo) -> ok | Errorerlang:loaded() -> [Module]erlang:localtime() -> DateTimeerlang:localtime_to_universaltime(Localtime) -> Universaltimeerlang:localtime_to_universaltime(Localtime, IsDst) -> Universaltimemake_ref() -> reference()erlang:make_tuple(Arity, InitialValue) -> tuple()erlang:make_tuple(Arity, DefaultValue, InitList) -> tuple()map_get(Key, Map) -> Valuemap_size(Map) -> integer() >= 0erlang:match_spec_test(MatchAgainst, MatchSpec, Type) -> TestResultmax(Term1, Term2) -> Maximumerlang:md5(Data) -> Digesterlang:md5_final(Context) -> Digesterlang:md5_init() -> Contexterlang:md5_update(Context, Data) -> NewContexterlang:memory() -> [{Type, Size}]erlang:memory(Type :: memory_type()) -> integer() >= 0erlang:memory(TypeList :: [memory_type()]) -> [{memory_type(), integer() >= 0}]min(Term1, Term2) -> Minimummodule_loaded(Module) -> boolean()monitor(Type :: process, Item :: monitor_process_identifier()) -> MonitorRefmonitor(Type :: port, Item :: monitor_port_identifier()) -> MonitorRefmonitor(Type :: time_offset, Item :: clock_service) -> MonitorRefmonitor_node(Node, Flag) -> trueerlang:monitor_node(Node, Flag, Options) -> trueerlang:monotonic_time() -> integer()erlang:monotonic_time(Unit) -> integer()erlang:nif_error(Reason) -> no_return()erlang:nif_error(Reason, Args) -> no_return()node() -> Nodenode(Arg) -> Nodenodes() -> Nodesnodes(Arg) -> Nodesnow() -> Timestampopen_port(PortName, PortSettings) -> port()erlang:phash(Term, Range) -> Hasherlang:phash2(Term) -> Hasherlang:phash2(Term, Range) -> Hashpid_to_list(Pid) -> string()erlang:port_call(Port, Operation, Data) -> term()port_close(Port) -> trueport_command(Port, Data) -> trueport_command(Port, Data, OptionList) -> boolean()port_connect(Port, Pid) -> trueport_control(Port, Operation, Data) -> iodata() | binary()erlang:port_info(Port) -> Resulterlang:port_info(Port, Item :: connected) -> {connected, Pid} | undefinederlang:port_info(Port, Item :: id) -> {id, Index} | undefinederlang:port_info(Port, Item :: input) -> {input, Bytes} | undefinederlang:port_info(Port, Item :: links) -> {links, Pids} | undefinederlang:port_info(Port, Item :: locking) -> {locking, Locking} | undefinederlang:port_info(Port, Item :: memory) -> {memory, Bytes} | undefinederlang:port_info(Port, Item :: monitors) -> {monitors, Monitors} | undefinederlang:port_info(Port, Item :: monitored_by) -> {monitored_by, MonitoredBy} | undefinederlang:port_info(Port, Item :: name) -> {name, Name} | undefinederlang:port_info(Port, Item :: os_pid) -> {os_pid, OsPid} | undefinederlang:port_info(Port, Item :: output) -> {output, Bytes} | undefinederlang:port_info(Port, Item :: parallelism) -> {parallelism, Boolean} | undefinederlang:port_info(Port, Item :: queue_size) -> {queue_size, Bytes} | undefinederlang:port_info(Port, Item :: registered_name) -> {registered_name, RegisteredName} | [] | undefinedport_to_list(Port) -> string()erlang:ports() -> [port()]pre_loaded() -> [module()]erlang:process_display(Pid, Type) -> trueprocess_flag(Flag :: trap_exit, Boolean) -> OldBooleanprocess_flag(Flag :: error_handler, Module) -> OldModuleprocess_flag(Flag :: min_heap_size, MinHeapSize) -> OldMinHeapSizeprocess_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) -> OldMinBinVHeapSizeprocess_flag(Flag :: max_heap_size, MaxHeapSize) -> OldMaxHeapSizeprocess_flag(Flag :: message_queue_data, MQD) -> OldMQDprocess_flag(Flag :: priority, Level) -> OldLevelprocess_flag(Flag :: save_calls, N) -> OldNprocess_flag(Flag :: sensitive, Boolean) -> OldBooleanprocess_flag(Pid, Flag, Value) -> OldValueprocess_info(Pid) -> Infoprocess_info(Pid, Item) -> InfoTuple | [] | undefinedprocess_info(Pid, ItemList) -> InfoTupleList | [] | undefinedprocesses() -> [pid()]purge_module(Module) -> trueput(Key, Val) -> term()erlang:raise(Class, Reason, Stacktrace) -> no_return()erlang:read_timer(TimerRef) -> Resulterlang:read_timer(TimerRef, Options) -> Result | okref_to_list(Ref) -> string()register(RegName, PidOrPort) -> trueregistered() -> [RegName]erlang:resume_process(Suspendee) -> trueround(Number) -> integer()self() -> pid()erlang:send(Dest, Msg) -> Msgerlang:send(Dest, Msg, Options) -> Reserlang:send_after(Time, Dest, Msg) -> TimerReferlang:send_after(Time, Dest, Msg, Options) -> TimerReferlang:send_nosuspend(Dest, Msg) -> boolean()erlang:send_nosuspend(Dest, Msg, Options) -> boolean()erlang:set_cookie(Node, Cookie) -> truesetelement(Index, Tuple1, Value) -> Tuple2size(Item) -> integer() >= 0spawn(Fun) -> pid()spawn(Node, Fun) -> pid()spawn(Module, Function, Args) -> pid()spawn(Node, Module, Function, Args) -> pid()spawn_link(Fun) -> pid()spawn_link(Node, Fun) -> pid()spawn_link(Module, Function, Args) -> pid()spawn_link(Node, Module, Function, Args) -> pid()spawn_monitor(Fun) -> {pid(), reference()}spawn_monitor(Module, Function, Args) -> {pid(), reference()}spawn_opt(Fun, Options) -> pid() | {pid(), reference()}spawn_opt(Node, Fun, Options) -> pid() | {pid(), reference()}spawn_opt(Module, Function, Args, Options) -> pid() | {pid(), reference()}spawn_opt(Node, Module, Function, Args, Options) -> pid() | {pid(), reference()}split_binary(Bin, Pos) -> {binary(), binary()}erlang:start_timer(Time, Dest, Msg) -> TimerReferlang:start_timer(Time, Dest, Msg, Options) -> TimerRefstatistics(Item :: active_tasks) -> [ActiveTasks]statistics(Item :: active_tasks_all) -> [ActiveTasks]statistics(Item :: context_switches) -> {ContextSwitches, 0}statistics(Item :: exact_reductions) -> {Total_Exact_Reductions, Exact_Reductions_Since_Last_Call}statistics(Item :: garbage_collection) -> {Number_of_GCs, Words_Reclaimed, 0}statistics(Item :: io) -> {{input, Input}, {output, Output}}statistics(Item :: microstate_accounting) -> [MSAcc_Thread] | undefinedstatistics(Item :: reductions) -> {Total_Reductions, Reductions_Since_Last_Call}statistics(Item :: run_queue) -> integer() >= 0statistics(Item :: run_queue_lengths) -> [RunQueueLength]statistics(Item :: run_queue_lengths_all) -> [RunQueueLength]statistics(Item :: runtime) -> {Total_Run_Time, Time_Since_Last_Call}statistics(Item :: scheduler_wall_time) -> [{SchedulerId, ActiveTime, TotalTime}] | undefinedstatistics(Item :: scheduler_wall_time_all) -> [{SchedulerId, ActiveTime, TotalTime}] | undefinedstatistics(Item :: total_active_tasks) -> ActiveTasksstatistics(Item :: total_active_tasks_all) -> ActiveTasksstatistics(Item :: total_run_queue_lengths) -> TotalRunQueueLengthsstatistics(Item :: total_run_queue_lengths_all) -> TotalRunQueueLengthsstatistics(Item :: wall_clock) -> {Total_Wallclock_Time, Wallclock_Time_Since_Last_Call}erlang:suspend_process(Suspendee) -> trueerlang:suspend_process(Suspendee, OptList) -> boolean()erlang:system_flag(Flag :: backtrace_depth, Depth) -> OldDeptherlang:system_flag(Flag :: cpu_topology, CpuTopology) -> OldCpuTopologyerlang:system_flag(Flag :: dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline) -> OldDirtyCPUSchedulersOnlineerlang:system_flag(Flag :: erts_alloc, Value :: {Alloc, F, V}) -> ok | notsuperlang:system_flag(Flag :: fullsweep_after, Number) -> OldNumbererlang:system_flag(Flag :: microstate_accounting, Action) -> OldStateerlang:system_flag(Flag :: min_heap_size, MinHeapSize) -> OldMinHeapSizeerlang:system_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) -> OldMinBinVHeapSizeerlang:system_flag(Flag :: max_heap_size, MaxHeapSize) -> OldMaxHeapSizeerlang:system_flag(Flag :: multi_scheduling, BlockState) -> OldBlockStateerlang:system_flag(Flag :: scheduler_bind_type, How) -> OldBindTypeerlang:system_flag(Flag :: scheduler_wall_time, Boolean) -> OldBooleanerlang:system_flag(Flag :: schedulers_online, SchedulersOnline) -> OldSchedulersOnlineerlang:system_flag(Flag :: system_logger, Logger) -> PrevLoggererlang:system_flag(Flag :: trace_control_word, TCW) -> OldTCWerlang:system_flag(Flag :: time_offset, Value :: finalize) -> OldStateerlang:system_info(Item :: wordsize | {wordsize, internal} | {wordsize, external}) -> 4 | 8erlang:system_info(Item :: allocated_areas) -> [tuple()]erlang:system_info(Item :: allocator) -> {Allocator, Version, Features, Settings}erlang:system_info(Item :: {allocator, Alloc}) -> [term()]erlang:system_info(Item :: alloc_util_allocators) -> [Alloc]erlang:system_info(Item :: {allocator_sizes, Alloc}) -> [term()]erlang:system_info(Item :: elib_malloc) -> falseerlang:system_info(Item :: cpu_topology) -> CpuTopologyerlang:system_info(Item :: {cpu_topology, defined | detected | used}) -> CpuTopologyerlang:system_info(Item :: logical_processors | logical_processors_available | logical_processors_online) -> unknown | integer() >= 1erlang:system_info(Item :: update_cpu_info) -> changed | unchangederlang:system_info(Item :: fullsweep_after) -> {fullsweep_after, integer() >= 0}erlang:system_info(Item :: garbage_collection) -> [{atom(), integer()}]erlang:system_info(Item :: heap_sizes) -> [integer() >= 0]erlang:system_info(Item :: heap_type) -> privateerlang:system_info(Item :: max_heap_size) -> {max_heap_size, MaxHeapSize :: max_heap_size()}erlang:system_info(Item :: message_queue_data) -> message_queue_data() erlang:system_info(Item :: min_heap_size) -> {min_heap_size, MinHeapSize :: integer() >= 1}erlang:system_info(Item :: min_bin_vheap_size) -> {min_bin_vheap_size, MinBinVHeapSize :: integer() >= 1}erlang:system_info(Item :: procs) -> binary()erlang:system_info(Item :: atom_count) -> integer() >= 1erlang:system_info(Item :: atom_limit) -> integer() >= 1erlang:system_info(Item :: ets_count) -> integer() >= 1erlang:system_info(Item :: ets_limit) -> integer() >= 1erlang:system_info(Item :: port_count) -> integer() >= 0erlang:system_info(Item :: port_limit) -> integer() >= 1erlang:system_info(Item :: process_count) -> integer() >= 1erlang:system_info(Item :: process_limit) -> integer() >= 1erlang:system_info(Item :: end_time) -> integer() >= 0erlang:system_info(Item :: os_monotonic_time_source) -> [{atom(), term()}]erlang:system_info(Item :: os_system_time_source) -> [{atom(), term()}]erlang:system_info(Item :: start_time) -> integer()erlang:system_info(Item :: time_correction) -> true | falseerlang:system_info(Item :: time_offset) -> preliminary | final | volatileerlang:system_info(Item :: time_warp_mode) -> no_time_warp | single_time_warp | multi_time_warperlang:system_info(Item :: tolerant_timeofday) -> enabled | disablederlang:system_info(Item :: dirty_cpu_schedulers) -> integer() >= 0erlang:system_info(Item :: dirty_cpu_schedulers_online) -> integer() >= 0erlang:system_info(Item :: dirty_io_schedulers) -> integer() >= 0erlang:system_info(Item :: multi_scheduling) -> disabled | blocked | blocked_normal | enablederlang:system_info(Item :: multi_scheduling_blockers) -> [Pid :: pid()]erlang:system_info(Item :: otp_release) -> string()erlang:system_info(Item :: scheduler_bind_type) -> spread | processor_spread | thread_spread | thread_no_node_processor_spread | no_node_processor_spread | no_node_thread_spread | no_spread | unbounderlang:system_info(Item :: scheduler_bindings) -> tuple()erlang:system_info(Item :: scheduler_id) -> SchedulerId :: integer() >= 1erlang:system_info(Item :: schedulers | schedulers_online) -> integer() >= 1erlang:system_info(Item :: smp_support) -> boolean()erlang:system_info(Item :: threads) -> boolean()erlang:system_info(Item :: thread_pool_size) -> integer() >= 0erlang:system_info(Item :: creation) -> integer()erlang:system_info(Item :: delayed_node_table_gc) -> infinity | integer() >= 0erlang:system_info(Item :: dist) -> binary()erlang:system_info(Item :: dist_buf_busy_limit) -> integer() >= 0erlang:system_info(Item :: dist_ctrl) -> {Node :: node(), ControllingEntity :: port() | pid()}erlang:system_info(Item :: build_type) -> opt | debug | purify | quantify | purecov | gcov | valgrind | gprof | lcnt | frmptrerlang:system_info(Item :: c_compiler_used) -> {atom(), term()}erlang:system_info(Item :: check_io) -> [term()]erlang:system_info(Item :: compat_rel) -> integer()erlang:system_info(Item :: debug_compiled) -> boolean()erlang:system_info(Item :: driver_version) -> string()erlang:system_info(Item :: dynamic_trace) -> none | dtrace | systemtaperlang:system_info(Item :: dynamic_trace_probes) -> boolean()erlang:system_info(Item :: info) -> binary()erlang:system_info(Item :: kernel_poll) -> boolean()erlang:system_info(Item :: loaded) -> binary()erlang:system_info(Item :: machine) -> string()erlang:system_info(Item :: modified_timing_level) -> integer() | undefinederlang:system_info(Item :: nif_version) -> string()erlang:system_info(Item :: otp_release) -> string()erlang:system_info(Item :: port_parallelism) -> boolean()erlang:system_info(Item :: system_architecture) -> string()erlang:system_info(Item :: system_logger) -> logger | undefined | pid()erlang:system_info(Item :: system_version) -> string()erlang:system_info(Item :: trace_control_word) -> integer() >= 0erlang:system_info(Item :: version) -> string()erlang:system_info(Item :: wordsize | {wordsize, internal} | {wordsize, external}) -> 4 | 8erlang:system_monitor() -> MonSettingserlang:system_monitor(Arg) -> MonSettingserlang:system_monitor(MonitorPid, Options) -> MonSettingserlang:system_profile() -> ProfilerSettingserlang:system_profile(ProfilerPid, Options) -> ProfilerSettingserlang:system_time() -> integer()erlang:system_time(Unit) -> integer()term_to_binary(Term) -> ext_binary() term_to_binary(Term, Options) -> ext_binary() throw(Any) -> no_return()time() -> Timeerlang:time_offset() -> integer()erlang:time_offset(Unit) -> integer()erlang:timestamp() -> Timestamptl(List) -> term()erlang:trace(PidPortSpec, How, FlagList) -> integer()erlang:trace_delivered(Tracee) -> Referlang:trace_info(PidPortFuncEvent, Item) -> Reserlang:trace_pattern(MFA, MatchSpec) -> integer() >= 0erlang:trace_pattern(MFA :: send, MatchSpec, FlagList :: []) -> integer() >= 0erlang:trace_pattern(MFA :: 'receive', MatchSpec, FlagList :: []) -> integer() >= 0erlang:trace_pattern(MFA, MatchSpec, FlagList) -> integer() >= 0trunc(Number) -> integer()tuple_size(Tuple) -> integer() >= 0tuple_to_list(Tuple) -> [term()]erlang:unique_integer() -> integer()erlang:unique_integer(ModifierList) -> integer()erlang:universaltime() -> DateTimeerlang:universaltime_to_localtime(Universaltime) -> Localtimeunlink(Id) -> trueunregister(RegName) -> truewhereis(RegName) -> pid() | port() | undefinederlang:yield() -> true"
  ],
  [
    "erlang",
    "abs(Float) -> float()abs(Int) -> integer() >= 0erlang:adler32(Data) -> integer() >= 0erlang:adler32(OldAdler, Data) -> integer() >= 0erlang:adler32_combine(FirstAdler, SecondAdler, SecondSize) -> integer() >= 0erlang:append_element(Tuple1, Term) -> Tuple2apply(Fun, Args) -> term()apply(Module, Function, Args) -> term()atom_to_binary(Atom, Encoding) -> binary()atom_to_list(Atom) -> string()binary_part(Subject, PosLen) -> binary()binary_part(Subject, Start, Length) -> binary()binary_to_atom(Binary, Encoding) -> atom()binary_to_existing_atom(Binary, Encoding) -> atom()binary_to_float(Binary) -> float()binary_to_integer(Binary) -> integer()binary_to_integer(Binary, Base) -> integer()binary_to_list(Binary) -> [byte()]binary_to_list(Binary, Start, Stop) -> [byte()]binary_to_term(Binary) -> term()binary_to_term(Binary, Opts) -> term() | {term(), Used}bit_size(Bitstring) -> integer() >= 0bitstring_to_list(Bitstring) -> [byte() | bitstring()]erlang:bump_reductions(Reductions) -> truebyte_size(Bitstring) -> integer() >= 0erlang:cancel_timer(TimerRef) -> Resulterlang:cancel_timer(TimerRef, Options) -> Result | okceil(Number) -> integer()check_old_code(Module) -> boolean()check_process_code(Pid, Module) -> CheckResultcheck_process_code(Pid, Module, OptionList) -> CheckResult | asyncerlang:convert_time_unit(Time, FromUnit, ToUnit) -> ConvertedTimeerlang:crc32(Data) -> integer() >= 0erlang:crc32(OldCrc, Data) -> integer() >= 0erlang:crc32_combine(FirstCrc, SecondCrc, SecondSize) -> integer() >= 0date() -> Dateerlang:decode_packet(Type, Bin, Options) -> {ok, Packet, Rest} | {more, Length} | {error, Reason}erlang:delete_element(Index, Tuple1) -> Tuple2delete_module(Module) -> true | undefineddemonitor(MonitorRef) -> truedemonitor(MonitorRef, OptionList) -> boolean()disconnect_node(Node) -> boolean() | ignorederlang:display(Term) -> trueerlang:dist_ctrl_get_data(DHandle) -> {Size, Data} | Data | noneerlang:dist_ctrl_get_opt(DHandle, Opt :: get_size) -> Valueerlang:dist_ctrl_get_data_notification(DHandle) -> okerlang:dist_ctrl_input_handler(DHandle, InputHandler) -> okerlang:dist_ctrl_put_data(DHandle, Data) -> okerlang:dist_ctrl_set_opt(DHandle, Opt :: get_size, Value) -> OldValueelement(N, Tuple) -> term()erase() -> [{Key, Val}]erase(Key) -> Val | undefinederror(Reason) -> no_return()error(Reason, Args) -> no_return()exit(Reason) -> no_return()exit(Pid, Reason) -> trueerlang:external_size(Term) -> integer() >= 0erlang:external_size(Term, Options) -> integer() >= 0float(Number) -> float()float_to_binary(Float) -> binary()float_to_binary(Float, Options) -> binary()float_to_list(Float) -> string()float_to_list(Float, Options) -> string()floor(Number) -> integer()erlang:fun_info(Fun) -> [{Item, Info}]erlang:fun_info(Fun, Item) -> {Item, Info}erlang:fun_to_list(Fun) -> string()erlang:function_exported(Module, Function, Arity) -> boolean()garbage_collect() -> truegarbage_collect(Pid) -> GCResultgarbage_collect(Pid, OptionList) -> GCResult | asyncget() -> [{Key, Val}]get(Key) -> Val | undefinederlang:get_cookie() -> Cookie | nocookieget_keys() -> [Key]get_keys(Val) -> [Key]erlang:get_stacktrace() -> [stack_item()]group_leader() -> pid()group_leader(GroupLeader, Pid) -> truehalt() -> no_return()halt(Status) -> no_return()halt(Status, Options) -> no_return()hd(List) -> term()erlang:hibernate(Module, Function, Args) -> no_return()erlang:insert_element(Index, Tuple1, Term) -> Tuple2integer_to_binary(Integer) -> binary()integer_to_binary(Integer, Base) -> binary()integer_to_list(Integer) -> string()integer_to_list(Integer, Base) -> string()iolist_size(Item) -> integer() >= 0iolist_to_binary(IoListOrBinary) -> binary()erlang:iolist_to_iovec(IoListOrBinary) -> iovec() is_alive() -> boolean()is_atom(Term) -> boolean()is_binary(Term) -> boolean()is_bitstring(Term) -> boolean()is_boolean(Term) -> boolean()erlang:is_builtin(Module, Function, Arity) -> boolean()is_float(Term) -> boolean()is_function(Term) -> boolean()is_function(Term, Arity) -> boolean()is_integer(Term) -> boolean()is_list(Term) -> boolean()is_map(Term) -> boolean()is_map_key(Key, Map) -> boolean()is_number(Term) -> boolean()is_pid(Term) -> boolean()is_port(Term) -> boolean()is_process_alive(Pid) -> boolean()is_record(Term, RecordTag) -> boolean()is_record(Term, RecordTag, Size) -> boolean()is_reference(Term) -> boolean()is_tuple(Term) -> boolean()length(List) -> integer() >= 0link(PidOrPort) -> truelist_to_atom(String) -> atom()list_to_binary(IoList) -> binary()list_to_bitstring(BitstringList) -> bitstring()list_to_existing_atom(String) -> atom()list_to_float(String) -> float()list_to_integer(String) -> integer()list_to_integer(String, Base) -> integer()list_to_pid(String) -> pid()list_to_port(String) -> port()list_to_ref(String) -> reference()list_to_tuple(List) -> tuple()load_module(Module, Binary) -> {module, Module} | {error, Reason}erlang:load_nif(Path, LoadInfo) -> ok | Errorerlang:loaded() -> [Module]erlang:localtime() -> DateTimeerlang:localtime_to_universaltime(Localtime) -> Universaltimeerlang:localtime_to_universaltime(Localtime, IsDst) -> Universaltimemake_ref() -> reference()erlang:make_tuple(Arity, InitialValue) -> tuple()erlang:make_tuple(Arity, DefaultValue, InitList) -> tuple()map_get(Key, Map) -> Valuemap_size(Map) -> integer() >= 0erlang:match_spec_test(MatchAgainst, MatchSpec, Type) -> TestResultmax(Term1, Term2) -> Maximumerlang:md5(Data) -> Digesterlang:md5_final(Context) -> Digesterlang:md5_init() -> Contexterlang:md5_update(Context, Data) -> NewContexterlang:memory() -> [{Type, Size}]erlang:memory(Type :: memory_type()) -> integer() >= 0erlang:memory(TypeList :: [memory_type()]) -> [{memory_type(), integer() >= 0}]min(Term1, Term2) -> Minimummodule_loaded(Module) -> boolean()monitor(Type :: process, Item :: monitor_process_identifier()) -> MonitorRefmonitor(Type :: port, Item :: monitor_port_identifier()) -> MonitorRefmonitor(Type :: time_offset, Item :: clock_service) -> MonitorRefmonitor_node(Node, Flag) -> trueerlang:monitor_node(Node, Flag, Options) -> trueerlang:monotonic_time() -> integer()erlang:monotonic_time(Unit) -> integer()erlang:nif_error(Reason) -> no_return()erlang:nif_error(Reason, Args) -> no_return()node() -> Nodenode(Arg) -> Nodenodes() -> Nodesnodes(Arg) -> Nodesnow() -> Timestampopen_port(PortName, PortSettings) -> port()erlang:phash(Term, Range) -> Hasherlang:phash2(Term) -> Hasherlang:phash2(Term, Range) -> Hashpid_to_list(Pid) -> string()erlang:port_call(Port, Operation, Data) -> term()port_close(Port) -> trueport_command(Port, Data) -> trueport_command(Port, Data, OptionList) -> boolean()port_connect(Port, Pid) -> trueport_control(Port, Operation, Data) -> iodata() | binary()erlang:port_info(Port) -> Resulterlang:port_info(Port, Item :: connected) -> {connected, Pid} | undefinederlang:port_info(Port, Item :: id) -> {id, Index} | undefinederlang:port_info(Port, Item :: input) -> {input, Bytes} | undefinederlang:port_info(Port, Item :: links) -> {links, Pids} | undefinederlang:port_info(Port, Item :: locking) -> {locking, Locking} | undefinederlang:port_info(Port, Item :: memory) -> {memory, Bytes} | undefinederlang:port_info(Port, Item :: monitors) -> {monitors, Monitors} | undefinederlang:port_info(Port, Item :: monitored_by) -> {monitored_by, MonitoredBy} | undefinederlang:port_info(Port, Item :: name) -> {name, Name} | undefinederlang:port_info(Port, Item :: os_pid) -> {os_pid, OsPid} | undefinederlang:port_info(Port, Item :: output) -> {output, Bytes} | undefinederlang:port_info(Port, Item :: parallelism) -> {parallelism, Boolean} | undefinederlang:port_info(Port, Item :: queue_size) -> {queue_size, Bytes} | undefinederlang:port_info(Port, Item :: registered_name) -> {registered_name, RegisteredName} | [] | undefinedport_to_list(Port) -> string()erlang:ports() -> [port()]pre_loaded() -> [module()]erlang:process_display(Pid, Type) -> trueprocess_flag(Flag :: trap_exit, Boolean) -> OldBooleanprocess_flag(Flag :: error_handler, Module) -> OldModuleprocess_flag(Flag :: min_heap_size, MinHeapSize) -> OldMinHeapSizeprocess_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) -> OldMinBinVHeapSizeprocess_flag(Flag :: max_heap_size, MaxHeapSize) -> OldMaxHeapSizeprocess_flag(Flag :: message_queue_data, MQD) -> OldMQDprocess_flag(Flag :: priority, Level) -> OldLevelprocess_flag(Flag :: save_calls, N) -> OldNprocess_flag(Flag :: sensitive, Boolean) -> OldBooleanprocess_flag(Pid, Flag, Value) -> OldValueprocess_info(Pid) -> Infoprocess_info(Pid, Item) -> InfoTuple | [] | undefinedprocess_info(Pid, ItemList) -> InfoTupleList | [] | undefinedprocesses() -> [pid()]purge_module(Module) -> trueput(Key, Val) -> term()erlang:raise(Class, Reason, Stacktrace) -> no_return()erlang:read_timer(TimerRef) -> Resulterlang:read_timer(TimerRef, Options) -> Result | okref_to_list(Ref) -> string()register(RegName, PidOrPort) -> trueregistered() -> [RegName]erlang:resume_process(Suspendee) -> trueround(Number) -> integer()self() -> pid()erlang:send(Dest, Msg) -> Msgerlang:send(Dest, Msg, Options) -> Reserlang:send_after(Time, Dest, Msg) -> TimerReferlang:send_after(Time, Dest, Msg, Options) -> TimerReferlang:send_nosuspend(Dest, Msg) -> boolean()erlang:send_nosuspend(Dest, Msg, Options) -> boolean()erlang:set_cookie(Node, Cookie) -> truesetelement(Index, Tuple1, Value) -> Tuple2size(Item) -> integer() >= 0spawn(Fun) -> pid()spawn(Node, Fun) -> pid()spawn(Module, Function, Args) -> pid()spawn(Node, Module, Function, Args) -> pid()spawn_link(Fun) -> pid()spawn_link(Node, Fun) -> pid()spawn_link(Module, Function, Args) -> pid()spawn_link(Node, Module, Function, Args) -> pid()spawn_monitor(Fun) -> {pid(), reference()}spawn_monitor(Module, Function, Args) -> {pid(), reference()}spawn_opt(Fun, Options) -> pid() | {pid(), reference()}spawn_opt(Node, Fun, Options) -> pid() | {pid(), reference()}spawn_opt(Module, Function, Args, Options) -> pid() | {pid(), reference()}spawn_opt(Node, Module, Function, Args, Options) -> pid() | {pid(), reference()}split_binary(Bin, Pos) -> {binary(), binary()}erlang:start_timer(Time, Dest, Msg) -> TimerReferlang:start_timer(Time, Dest, Msg, Options) -> TimerRefstatistics(Item :: active_tasks) -> [ActiveTasks]statistics(Item :: active_tasks_all) -> [ActiveTasks]statistics(Item :: context_switches) -> {ContextSwitches, 0}statistics(Item :: exact_reductions) -> {Total_Exact_Reductions, Exact_Reductions_Since_Last_Call}statistics(Item :: garbage_collection) -> {Number_of_GCs, Words_Reclaimed, 0}statistics(Item :: io) -> {{input, Input}, {output, Output}}statistics(Item :: microstate_accounting) -> [MSAcc_Thread] | undefinedstatistics(Item :: reductions) -> {Total_Reductions, Reductions_Since_Last_Call}statistics(Item :: run_queue) -> integer() >= 0statistics(Item :: run_queue_lengths) -> [RunQueueLength]statistics(Item :: run_queue_lengths_all) -> [RunQueueLength]statistics(Item :: runtime) -> {Total_Run_Time, Time_Since_Last_Call}statistics(Item :: scheduler_wall_time) -> [{SchedulerId, ActiveTime, TotalTime}] | undefinedstatistics(Item :: scheduler_wall_time_all) -> [{SchedulerId, ActiveTime, TotalTime}] | undefinedstatistics(Item :: total_active_tasks) -> ActiveTasksstatistics(Item :: total_active_tasks_all) -> ActiveTasksstatistics(Item :: total_run_queue_lengths) -> TotalRunQueueLengthsstatistics(Item :: total_run_queue_lengths_all) -> TotalRunQueueLengthsstatistics(Item :: wall_clock) -> {Total_Wallclock_Time, Wallclock_Time_Since_Last_Call}erlang:suspend_process(Suspendee) -> trueerlang:suspend_process(Suspendee, OptList) -> boolean()erlang:system_flag(Flag :: backtrace_depth, Depth) -> OldDeptherlang:system_flag(Flag :: cpu_topology, CpuTopology) -> OldCpuTopologyerlang:system_flag(Flag :: dirty_cpu_schedulers_online, DirtyCPUSchedulersOnline) -> OldDirtyCPUSchedulersOnlineerlang:system_flag(Flag :: erts_alloc, Value :: {Alloc, F, V}) -> ok | notsuperlang:system_flag(Flag :: fullsweep_after, Number) -> OldNumbererlang:system_flag(Flag :: microstate_accounting, Action) -> OldStateerlang:system_flag(Flag :: min_heap_size, MinHeapSize) -> OldMinHeapSizeerlang:system_flag(Flag :: min_bin_vheap_size, MinBinVHeapSize) -> OldMinBinVHeapSizeerlang:system_flag(Flag :: max_heap_size, MaxHeapSize) -> OldMaxHeapSizeerlang:system_flag(Flag :: multi_scheduling, BlockState) -> OldBlockStateerlang:system_flag(Flag :: scheduler_bind_type, How) -> OldBindTypeerlang:system_flag(Flag :: scheduler_wall_time, Boolean) -> OldBooleanerlang:system_flag(Flag :: schedulers_online, SchedulersOnline) -> OldSchedulersOnlineerlang:system_flag(Flag :: system_logger, Logger) -> PrevLoggererlang:system_flag(Flag :: trace_control_word, TCW) -> OldTCWerlang:system_flag(Flag :: time_offset, Value :: finalize) -> OldStateerlang:system_info(Item :: wordsize | {wordsize, internal} | {wordsize, external}) -> 4 | 8erlang:system_info(Item :: allocated_areas) -> [tuple()]erlang:system_info(Item :: allocator) -> {Allocator, Version, Features, Settings}erlang:system_info(Item :: {allocator, Alloc}) -> [term()]erlang:system_info(Item :: alloc_util_allocators) -> [Alloc]erlang:system_info(Item :: {allocator_sizes, Alloc}) -> [term()]erlang:system_info(Item :: elib_malloc) -> falseerlang:system_info(Item :: cpu_topology) -> CpuTopologyerlang:system_info(Item :: {cpu_topology, defined | detected | used}) -> CpuTopologyerlang:system_info(Item :: logical_processors | logical_processors_available | logical_processors_online) -> unknown | integer() >= 1erlang:system_info(Item :: update_cpu_info) -> changed | unchangederlang:system_info(Item :: fullsweep_after) -> {fullsweep_after, integer() >= 0}erlang:system_info(Item :: garbage_collection) -> [{atom(), integer()}]erlang:system_info(Item :: heap_sizes) -> [integer() >= 0]erlang:system_info(Item :: heap_type) -> privateerlang:system_info(Item :: max_heap_size) -> {max_heap_size, MaxHeapSize :: max_heap_size()}erlang:system_info(Item :: message_queue_data) -> message_queue_data() erlang:system_info(Item :: min_heap_size) -> {min_heap_size, MinHeapSize :: integer() >= 1}erlang:system_info(Item :: min_bin_vheap_size) -> {min_bin_vheap_size, MinBinVHeapSize :: integer() >= 1}erlang:system_info(Item :: procs) -> binary()erlang:system_info(Item :: atom_count) -> integer() >= 1erlang:system_info(Item :: atom_limit) -> integer() >= 1erlang:system_info(Item :: ets_count) -> integer() >= 1erlang:system_info(Item :: ets_limit) -> integer() >= 1erlang:system_info(Item :: port_count) -> integer() >= 0erlang:system_info(Item :: port_limit) -> integer() >= 1erlang:system_info(Item :: process_count) -> integer() >= 1erlang:system_info(Item :: process_limit) -> integer() >= 1erlang:system_info(Item :: end_time) -> integer() >= 0erlang:system_info(Item :: os_monotonic_time_source) -> [{atom(), term()}]erlang:system_info(Item :: os_system_time_source) -> [{atom(), term()}]erlang:system_info(Item :: start_time) -> integer()erlang:system_info(Item :: time_correction) -> true | falseerlang:system_info(Item :: time_offset) -> preliminary | final | volatileerlang:system_info(Item :: time_warp_mode) -> no_time_warp | single_time_warp | multi_time_warperlang:system_info(Item :: tolerant_timeofday) -> enabled | disablederlang:system_info(Item :: dirty_cpu_schedulers) -> integer() >= 0erlang:system_info(Item :: dirty_cpu_schedulers_online) -> integer() >= 0erlang:system_info(Item :: dirty_io_schedulers) -> integer() >= 0erlang:system_info(Item :: multi_scheduling) -> disabled | blocked | blocked_normal | enablederlang:system_info(Item :: multi_scheduling_blockers) -> [Pid :: pid()]erlang:system_info(Item :: otp_release) -> string()erlang:system_info(Item :: scheduler_bind_type) -> spread | processor_spread | thread_spread | thread_no_node_processor_spread | no_node_processor_spread | no_node_thread_spread | no_spread | unbounderlang:system_info(Item :: scheduler_bindings) -> tuple()erlang:system_info(Item :: scheduler_id) -> SchedulerId :: integer() >= 1erlang:system_info(Item :: schedulers | schedulers_online) -> integer() >= 1erlang:system_info(Item :: smp_support) -> boolean()erlang:system_info(Item :: threads) -> boolean()erlang:system_info(Item :: thread_pool_size) -> integer() >= 0erlang:system_info(Item :: creation) -> integer()erlang:system_info(Item :: delayed_node_table_gc) -> infinity | integer() >= 0erlang:system_info(Item :: dist) -> binary()erlang:system_info(Item :: dist_buf_busy_limit) -> integer() >= 0erlang:system_info(Item :: dist_ctrl) -> {Node :: node(), ControllingEntity :: port() | pid()}erlang:system_info(Item :: build_type) -> opt | debug | purify | quantify | purecov | gcov | valgrind | gprof | lcnt | frmptrerlang:system_info(Item :: c_compiler_used) -> {atom(), term()}erlang:system_info(Item :: check_io) -> [term()]erlang:system_info(Item :: compat_rel) -> integer()erlang:system_info(Item :: debug_compiled) -> boolean()erlang:system_info(Item :: driver_version) -> string()erlang:system_info(Item :: dynamic_trace) -> none | dtrace | systemtaperlang:system_info(Item :: dynamic_trace_probes) -> boolean()erlang:system_info(Item :: info) -> binary()erlang:system_info(Item :: kernel_poll) -> boolean()erlang:system_info(Item :: loaded) -> binary()erlang:system_info(Item :: machine) -> string()erlang:system_info(Item :: modified_timing_level) -> integer() | undefinederlang:system_info(Item :: nif_version) -> string()erlang:system_info(Item :: otp_release) -> string()erlang:system_info(Item :: port_parallelism) -> boolean()erlang:system_info(Item :: system_architecture) -> string()erlang:system_info(Item :: system_logger) -> logger | undefined | pid()erlang:system_info(Item :: system_version) -> string()erlang:system_info(Item :: trace_control_word) -> integer() >= 0erlang:system_info(Item :: version) -> string()erlang:system_info(Item :: wordsize | {wordsize, internal} | {wordsize, external}) -> 4 | 8erlang:system_monitor() -> MonSettingserlang:system_monitor(Arg) -> MonSettingserlang:system_monitor(MonitorPid, Options) -> MonSettingserlang:system_profile() -> ProfilerSettingserlang:system_profile(ProfilerPid, Options) -> ProfilerSettingserlang:system_time() -> integer()erlang:system_time(Unit) -> integer()term_to_binary(Term) -> ext_binary() term_to_binary(Term, Options) -> ext_binary() throw(Any) -> no_return()time() -> Timeerlang:time_offset() -> integer()erlang:time_offset(Unit) -> integer()erlang:timestamp() -> Timestamptl(List) -> term()erlang:trace(PidPortSpec, How, FlagList) -> integer()erlang:trace_delivered(Tracee) -> Referlang:trace_info(PidPortFuncEvent, Item) -> Reserlang:trace_pattern(MFA, MatchSpec) -> integer() >= 0erlang:trace_pattern(MFA :: send, MatchSpec, FlagList :: []) -> integer() >= 0erlang:trace_pattern(MFA :: 'receive', MatchSpec, FlagList :: []) -> integer() >= 0erlang:trace_pattern(MFA, MatchSpec, FlagList) -> integer() >= 0trunc(Number) -> integer()tuple_size(Tuple) -> integer() >= 0tuple_to_list(Tuple) -> [term()]erlang:unique_integer() -> integer()erlang:unique_integer(ModifierList) -> integer()erlang:universaltime() -> DateTimeerlang:universaltime_to_localtime(Universaltime) -> Localtimeunlink(Id) -> trueunregister(RegName) -> truewhereis(RegName) -> pid() | port() | undefinederlang:yield() -> true"
  ],
  ["erlang.el"],
  ["erlc"],
  ["erlsrv"],
  [
    "error_handler",
    "raise_undef_exception(Module, Function, Args) -> no_return()undefined_function(Module, Function, Args) -> any()undefined_lambda(Module, Fun, Args) -> term()"
  ],
  [
    "error_logger",
    "add_report_handler(Handler) -> any()add_report_handler(Handler, Args) -> Resultdelete_report_handler(Handler) -> Resulterror_msg(Format) -> okerror_msg(Format, Data) -> okformat(Format, Data) -> okerror_report(Report) -> okerror_report(Type, Report) -> okget_format_depth() -> unlimited | integer() >= 1info_msg(Format) -> okinfo_msg(Format, Data) -> okinfo_report(Report) -> okinfo_report(Type, Report) -> oklogfile(Request :: {open, Filename}) -> ok | {error, OpenReason}logfile(Request :: close) -> ok | {error, CloseReason}logfile(Request :: filename) -> Filename | {error, FilenameReason}tty(Flag) -> okwarning_map() -> Tagwarning_msg(Format) -> okwarning_msg(Format, Data) -> okwarning_report(Report) -> okwarning_report(Type, Report) -> ok"
  ],
  ["erts_alloc"],
  [
    "erts_alloc_config",
    "save_scenario() -> ok | {error, Error}make_config() -> ok | {error, Error}make_config(FileNameOrIODev) -> ok | {error, Error}stop() -> ok | {error, Error}"
  ],
  ["escript"],
  [
    "et",
    "trace_me(DetailLevel, From, To, Label, Contents) -> hopefully_tracedtrace_me(DetailLevel, FromTo, Label, Contents) -> hopefully_tracedphone_home(DetailLevel, FromTo, Label, Contents) -> hopefully_tracedphone_home(DetailLevel, From, To, Label, Contents) -> hopefully_tracedreport_event(DetailLevel, FromTo, Label, Contents) -> hopefully_tracedreport_event(DetailLevel, From, To, Label, Contents) -> hopefully_traced"
  ],
  [
    "et_collector",
    "start_link(Options) -> {ok, CollectorPid} | {error, Reason}stop(CollectorPid) -> oksave_event_file(CollectorPid, FileName, Options) -> ok | {error, Reason}load_event_file(CollectorPid, FileName) -> {ok, BadBytes} | exit(Reason)report(Handle, TraceOrEvent) -> {ok, Continuation} | exit(Reason)report_event(Handle, DetailLevel, FromTo, Label, Contents) -> {ok, Continuation} | exit(Reason)report_event(Handle, DetailLevel, From, To, Label, Contents) -> {ok, Continuation} | exit(Reason)make_key(Type, Stuff) -> Keyget_table_handle(CollectorPid) -> Handleget_global_pid() -> CollectorPid | exit(Reason)change_pattern(CollectorPid, RawPattern) -> {old_pattern, TracePattern}dict_insert(CollectorPid, {filter, collector}, FilterFun) -> okdict_insert(CollectorPid, {subscriber, SubscriberPid}, Void) -> okdict_insert(CollectorPid, Key, Val) -> okdict_lookup(CollectorPid, Key) -> [Val]dict_delete(CollectorPid, Key) -> okdict_match(CollectorPid, Pattern) -> [Match]multicast(_CollectorPid, Msg) -> okstart_trace_client(CollectorPid, Type, Parameters) -> file_loaded | {trace_client_pid, pid()} | exit(Reason)iterate(Handle, Prev, Limit) -> NewAcciterate(Handle, Prev, Limit, Fun, Acc) -> NewAccclear_table(Handle) -> ok"
  ],
  [
    "et_selector",
    "make_pattern(RawPattern) -> TracePatternchange_pattern(Pattern) -> okparse_event(Mod, ValidTraceData) -> false | true | {true, Event}"
  ],
  [
    "et_viewer",
    "file(FileName) -> {ok, ViewerPid} | {error, Reason}start() -> okstart(Options) -> okstart_link(Options) -> {ok, ViewerPid} | {error, Reason}get_collector_pid(ViewerPid) -> CollectorPidstop(ViewerPid) -> ok"
  ],
  [
    "etop",
    "start() -> okstart(Options) -> okhelp() -> okconfig(Key,Value) -> Resultdump(File) -> Resultstop() -> stop"
  ],
  [
    "ets",
    "all() -> [Tab]delete(Tab) -> truedelete(Tab, Key) -> truedelete_all_objects(Tab) -> truedelete_object(Tab, Object) -> truefile2tab(Filename) -> {ok, Tab} | {error, Reason}file2tab(Filename, Options) -> {ok, Tab} | {error, Reason}first(Tab) -> Key | '$end_of_table'foldl(Function, Acc0, Tab) -> Acc1foldr(Function, Acc0, Tab) -> Acc1from_dets(Tab, DetsTab) -> truefun2ms(LiteralFun) -> MatchSpecgive_away(Tab, Pid, GiftData) -> truei() -> oki(Tab) -> okinfo(Tab) -> InfoList | undefinedinfo(Tab, Item) -> Value | undefinedinit_table(Tab, InitFun) -> trueinsert(Tab, ObjectOrObjects) -> trueinsert_new(Tab, ObjectOrObjects) -> boolean()is_compiled_ms(Term) -> boolean()last(Tab) -> Key | '$end_of_table'lookup(Tab, Key) -> [Object]lookup_element(Tab, Key, Pos) -> Elemmatch(Continuation) -> {[Match], Continuation} | '$end_of_table'match(Tab, Pattern) -> [Match]match(Tab, Pattern, Limit) -> {[Match], Continuation} | '$end_of_table'match_delete(Tab, Pattern) -> truematch_object(Continuation) -> {[Object], Continuation} | '$end_of_table'match_object(Tab, Pattern) -> [Object]match_object(Tab, Pattern, Limit) -> {[Object], Continuation} | '$end_of_table'match_spec_compile(MatchSpec) -> CompiledMatchSpecmatch_spec_run(List, CompiledMatchSpec) -> list()member(Tab, Key) -> boolean()new(Name, Options) -> tid() | atom()next(Tab, Key1) -> Key2 | '$end_of_table'prev(Tab, Key1) -> Key2 | '$end_of_table'rename(Tab, Name) -> Namerepair_continuation(Continuation, MatchSpec) -> Continuationsafe_fixtable(Tab, Fix) -> trueselect(Continuation) -> {[Match], Continuation} | '$end_of_table'select(Tab, MatchSpec) -> [Match]select(Tab, MatchSpec, Limit) -> {[Match], Continuation} | '$end_of_table'select_count(Tab, MatchSpec) -> NumMatchedselect_delete(Tab, MatchSpec) -> NumDeletedselect_replace(Tab, MatchSpec) -> NumReplacedselect_reverse(Continuation) -> {[Match], Continuation} | '$end_of_table'select_reverse(Tab, MatchSpec) -> [Match]select_reverse(Tab, MatchSpec, Limit) -> {[Match], Continuation} | '$end_of_table'setopts(Tab, Opts) -> trueslot(Tab, I) -> [Object] | '$end_of_table'tab2file(Tab, Filename) -> ok | {error, Reason}tab2file(Tab, Filename, Options) -> ok | {error, Reason}tab2list(Tab) -> [Object]tabfile_info(Filename) -> {ok, TableInfo} | {error, Reason}table(Tab) -> QueryHandletable(Tab, Options) -> QueryHandletake(Tab, Key) -> [Object]test_ms(Tuple, MatchSpec) -> {ok, Result} | {error, Errors}to_dets(Tab, DetsTab) -> DetsTabupdate_counter(Tab, Key, UpdateOp) -> Resultupdate_counter(Tab, Key, UpdateOp, Default) -> Resultupdate_counter(Tab, Key, X3 :: [UpdateOp]) -> [Result]update_counter(Tab, Key, X3 :: [UpdateOp], Default) -> [Result]update_counter(Tab, Key, Incr) -> Resultupdate_counter(Tab, Key, Incr, Default) -> Resultupdate_element(Tab, Key, ElementSpec :: {Pos, Value}) -> boolean()update_element(Tab, Key, ElementSpec :: [{Pos, Value}]) -> boolean()whereis(TableName) -> tid() | undefined"
  ],
  [
    "eunit",
    "start() -> term()stop() -> term()test(Tests) -> term()test(Tests::term(), Options::[term()]) -> ok | {error, term()}"
  ],
  [
    "eunit_surefire",
    "handle_begin(Kind, Data, St) -> term()handle_cancel(X1, Data, St) -> term()handle_end(X1, Data, St) -> term()init(Options) -> term()start() -> term()start(Options) -> term()terminate(X1, St) -> term()"
  ],
  [
    "file",
    "advise(IoDevice, Offset, Length, Advise) -> ok | {error, Reason}allocate(File, Offset, Length) -> ok | {error, posix()}change_group(Filename, Gid) -> ok | {error, Reason}change_mode(Filename, Mode) -> ok | {error, Reason}change_owner(Filename, Uid) -> ok | {error, Reason}change_owner(Filename, Uid, Gid) -> ok | {error, Reason}change_time(Filename, Mtime) -> ok | {error, Reason}change_time(Filename, Atime, Mtime) -> ok | {error, Reason}close(IoDevice) -> ok | {error, Reason}consult(Filename) -> {ok, Terms} | {error, Reason}copy(Source, Destination) -> {ok, BytesCopied} | {error, Reason}copy(Source, Destination, ByteCount) -> {ok, BytesCopied} | {error, Reason}datasync(IoDevice) -> ok | {error, Reason}del_dir(Dir) -> ok | {error, Reason}delete(Filename) -> ok | {error, Reason}eval(Filename) -> ok | {error, Reason}eval(Filename, Bindings) -> ok | {error, Reason}format_error(Reason) -> Charsget_cwd() -> {ok, Dir} | {error, Reason}get_cwd(Drive) -> {ok, Dir} | {error, Reason}list_dir(Dir) -> {ok, Filenames} | {error, Reason}list_dir_all(Dir) -> {ok, Filenames} | {error, Reason}make_dir(Dir) -> ok | {error, Reason}make_link(Existing, New) -> ok | {error, Reason}make_symlink(Existing, New) -> ok | {error, Reason}native_name_encoding() -> latin1 | utf8open(File, Modes) -> {ok, IoDevice} | {error, Reason}path_consult(Path, Filename) -> {ok, Terms, FullName} | {error, Reason}path_eval(Path, Filename) -> {ok, FullName} | {error, Reason}path_open(Path, Filename, Modes) -> {ok, IoDevice, FullName} | {error, Reason}path_script(Path, Filename) -> {ok, Value, FullName} | {error, Reason}path_script(Path, Filename, Bindings) -> {ok, Value, FullName} | {error, Reason}pid2name(Pid) -> {ok, Filename} | undefinedposition(IoDevice, Location) -> {ok, NewPosition} | {error, Reason}pread(IoDevice, LocNums) -> {ok, DataL} | eof | {error, Reason}pread(IoDevice, Location, Number) -> {ok, Data} | eof | {error, Reason}pwrite(IoDevice, LocBytes) -> ok | {error, {N, Reason}}pwrite(IoDevice, Location, Bytes) -> ok | {error, Reason}read(IoDevice, Number) -> {ok, Data} | eof | {error, Reason}read_file(Filename) -> {ok, Binary} | {error, Reason}read_file_info(Filename) -> {ok, FileInfo} | {error, Reason}read_file_info(Filename, Opts) -> {ok, FileInfo} | {error, Reason}read_line(IoDevice) -> {ok, Data} | eof | {error, Reason}read_link(Name) -> {ok, Filename} | {error, Reason}read_link_all(Name) -> {ok, Filename} | {error, Reason}read_link_info(Name) -> {ok, FileInfo} | {error, Reason}read_link_info(Name, Opts) -> {ok, FileInfo} | {error, Reason}rename(Source, Destination) -> ok | {error, Reason}script(Filename) -> {ok, Value} | {error, Reason}script(Filename, Bindings) -> {ok, Value} | {error, Reason}sendfile(Filename, Socket) -> {ok, integer() >= 0} | {error, inet:posix() | closed | badarg | not_owner}sendfile(RawFile, Socket, Offset, Bytes, Opts) -> {ok, integer() >= 0} | {error, inet:posix() | closed | badarg | not_owner}set_cwd(Dir) -> ok | {error, Reason}sync(IoDevice) -> ok | {error, Reason}truncate(IoDevice) -> ok | {error, Reason}write(IoDevice, Bytes) -> ok | {error, Reason}write_file(Filename, Bytes) -> ok | {error, Reason}write_file(Filename, Bytes, Modes) -> ok | {error, Reason}write_file_info(Filename, FileInfo) -> ok | {error, Reason}write_file_info(Filename, FileInfo, Opts) -> ok | {error, Reason}"
  ],
  [
    "file_sorter",
    "check(FileName) -> Replycheck(FileNames, Options) -> Replykeycheck(KeyPos, FileName) -> Replykeycheck(KeyPos, FileNames, Options) -> Replykeymerge(KeyPos, FileNames, Output) -> Replykeymerge(KeyPos, FileNames, Output, Options) -> Replykeysort(KeyPos, FileName) -> Replykeysort(KeyPos, Input, Output) -> Replykeysort(KeyPos, Input, Output, Options) -> Replymerge(FileNames, Output) -> Replymerge(FileNames, Output, Options) -> Replysort(FileName) -> Replysort(Input, Output) -> Replysort(Input, Output, Options) -> Reply"
  ],
  [
    "filelib",
    "ensure_dir(Name) -> ok | {error, Reason}file_size(Filename) -> integer() >= 0fold_files(Dir, RegExp, Recursive, Fun, AccIn) -> AccOutis_dir(Name) -> boolean()is_file(Name) -> boolean()is_regular(Name) -> boolean()last_modified(Name) -> file:date_time() | 0wildcard(Wildcard) -> [file:filename()]wildcard(Wildcard, Cwd) -> [file:filename()]find_file(Filename :: filename(), Dir :: filename()) -> {ok, filename()} | {error, not_found}find_file(Filename :: filename(), Dir :: filename(), Rules :: [find_file_rule()]) -> {ok, filename()} | {error, not_found}find_source(FilePath :: filename()) -> {ok, filename()} | {error, not_found}find_source(Filename :: filename(), Dir :: filename()) -> {ok, filename()} | {error, not_found}find_source(Filename :: filename(), Dir :: filename(), Rules :: [find_source_rule()]) -> {ok, filename()} | {error, not_found}"
  ],
  [
    "filename",
    "absname(Filename) -> file:filename_all() absname(Filename, Dir) -> file:filename_all() absname_join(Dir, Filename) -> file:filename_all() basedir(PathType, Application) -> file:filename_all() basedir(PathsType, Application) -> [file:filename_all()]basedir(PathType, Application, Opts) -> file:filename_all() basedir(PathsType, Application, Opts) -> [file:filename_all()]basename(Filename) -> file:filename_all() basename(Filename, Ext) -> file:filename_all() dirname(Filename) -> file:filename_all() extension(Filename) -> file:filename_all() find_src(Beam) -> {SourceFile, Options} | {error, {ErrorReason, Module}}find_src(Beam, Rules) -> {SourceFile, Options} | {error, {ErrorReason, Module}}flatten(Filename) -> file:filename_all() join(Components) -> file:filename_all() join(Name1, Name2) -> file:filename_all() nativename(Path) -> file:filename_all() pathtype(Path) -> absolute | relative | volumerelativerootname(Filename) -> file:filename_all() rootname(Filename, Ext) -> file:filename_all() safe_relative_path(Filename) -> unsafe | SafeFilenamesplit(Filename) -> Components"
  ],
  [
    "fprof",
    "start() -> {ok, Pid} | {error, {already_started, Pid}}stop() -> okstop(Reason) -> okapply(Func, Args) -> term()apply(Module, Function, Args) -> term()apply(Func, Args, OptionList) -> term()apply(Module, Function, Args, OptionList) -> term()trace(start, Filename) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}trace(verbose, Filename) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}trace(OptionName, OptionValue) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}trace(verbose) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}trace(OptionName) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}trace({OptionName, OptionValue}) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}trace([Option]) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}profile() -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}profile(OptionName, OptionValue) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}profile(OptionName) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}profile({OptionName, OptionValue}) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}profile([Option]) -> ok | {ok, Tracer} | {error, Reason} | {'EXIT', ServerPid, Reason}analyse() -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}analyse(OptionName, OptionValue) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}analyse(OptionName) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}analyse({OptionName, OptionValue}) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}analyse([Option]) -> ok | {error, Reason} | {'EXIT', ServerPid, Reason}"
  ],
  [
    "ftp",
    "account(Pid, Account) -> ok | {error, Reason}append(Pid, LocalFile) -> append(Pid, LocalFile, RemoteFile) -> ok | {error, Reason}append_bin(Pid, Bin, RemoteFile) -> ok | {error, Reason}append_chunk(Pid, Bin) -> ok | {error, Reason}append_chunk_start(Pid, File) -> ok | {error, Reason}append_chunk_end(Pid) -> ok | {error, Reason}cd(Pid, Dir) -> ok | {error, Reason}close(Pid) -> okdelete(Pid, File) -> ok | {error, Reason}formaterror(Tag) -> string()lcd(Pid, Dir) -> ok | {error, Reason}lpwd(Pid) -> {ok, Dir}ls(Pid) -> ls(Pid, Pathname) -> {ok, Listing} | {error, Reason}mkdir(Pid, Dir) -> ok | {error, Reason}nlist(Pid) -> nlist(Pid, Pathname) -> {ok, Listing} | {error, Reason}open(Host) -> {ok, Pid} | {error, Reason}open(Host, Opts) -> {ok, Pid} | {error, Reason}pwd(Pid) -> {ok, Dir} | {error, Reason}recv(Pid, RemoteFile) -> recv(Pid, RemoteFile, LocalFile) -> ok | {error, Reason}recv_bin(Pid, RemoteFile) -> {ok, Bin} | {error, Reason}recv_chunk_start(Pid, RemoteFile) -> ok | {error, Reason}recv_chunk(Pid) -> ok | {ok, Bin} | {error, Reason}rename(Pid, Old, New) -> ok | {error, Reason}rmdir(Pid, Dir) -> ok | {error, Reason}send(Pid, LocalFile) ->send(Pid, LocalFile, RemoteFile) -> ok | {error, Reason}send_bin(Pid, Bin, RemoteFile) -> ok | {error, Reason}send_chunk(Pid, Bin) -> ok | {error, Reason}send_chunk_start(Pid, File) -> ok | {error, Reason}send_chunk_end(Pid) -> ok | {error, Reason}start_service(ServiceConfig) -> {ok, Pid} | {error, Reason}stop_service(Reference) -> ok | {error, Reason} type(Pid, Type) -> ok | {error, Reason}user(Pid, User, Password) -> ok | {error, Reason}user(Pid, User, Password, Account) -> ok | {error, Reason}quote(Pid, Command) -> [FTPLine]"
  ],
  [
    "gb_sets",
    "add(Element, Set1) -> Set2add_element(Element, Set1) -> Set2balance(Set1) -> Set2del_element(Element, Set1) -> Set2delete(Element, Set1) -> Set2delete_any(Element, Set1) -> Set2difference(Set1, Set2) -> Set3empty() -> Setfilter(Pred, Set1) -> Set2fold(Function, Acc0, Set) -> Acc1from_list(List) -> Setfrom_ordset(List) -> Setinsert(Element, Set1) -> Set2intersection(SetList) -> Setintersection(Set1, Set2) -> Set3is_disjoint(Set1, Set2) -> boolean()is_element(Element, Set) -> boolean()is_empty(Set) -> boolean()is_member(Element, Set) -> boolean()is_set(Term) -> boolean()is_subset(Set1, Set2) -> boolean()iterator(Set) -> Iteriterator_from(Element, Set) -> Iterlargest(Set) -> Elementnew() -> Setnext(Iter1) -> {Element, Iter2} | nonesingleton(Element) -> set(Element)size(Set) -> integer() >= 0smallest(Set) -> Elementsubtract(Set1, Set2) -> Set3take_largest(Set1) -> {Element, Set2}take_smallest(Set1) -> {Element, Set2}to_list(Set) -> Listunion(SetList) -> Setunion(Set1, Set2) -> Set3"
  ],
  [
    "gb_trees",
    "balance(Tree1) -> Tree2delete(Key, Tree1) -> Tree2delete_any(Key, Tree1) -> Tree2take(Key, Tree1) -> {Value, Tree2}take_any(Key, Tree1) -> {Value, Tree2} | errorempty() -> tree() enter(Key, Value, Tree1) -> Tree2from_orddict(List) -> Treeget(Key, Tree) -> Valueinsert(Key, Value, Tree1) -> Tree2is_defined(Key, Tree) -> boolean()is_empty(Tree) -> boolean()iterator(Tree) -> Iteriterator_from(Key, Tree) -> Iterkeys(Tree) -> [Key]largest(Tree) -> {Key, Value}lookup(Key, Tree) -> none | {value, Value}map(Function, Tree1) -> Tree2next(Iter1) -> none | {Key, Value, Iter2}size(Tree) -> integer() >= 0smallest(Tree) -> {Key, Value}take_largest(Tree1) -> {Key, Value, Tree2}take_smallest(Tree1) -> {Key, Value, Tree2}to_list(Tree) -> [{Key, Value}]update(Key, Value, Tree1) -> Tree2values(Tree) -> [Value]"
  ],
  [
    "gen_event",
    "add_handler(EventMgrRef, Handler, Args) -> Resultadd_sup_handler(EventMgrRef, Handler, Args) -> Resultcall(EventMgrRef, Handler, Request) -> Resultcall(EventMgrRef, Handler, Request, Timeout) -> Resultdelete_handler(EventMgrRef, Handler, Args) -> Resultnotify(EventMgrRef, Event) -> oksync_notify(EventMgrRef, Event) -> okstart() -> Resultstart(EventMgrName | Options) -> Resultstart(EventMgrName, Options) -> Resultstart_link() -> Resultstart_link(EventMgrName | Options) -> Resultstart_link(EventMgrName, Options) -> Resultstop(EventMgrRef) -> okstop(EventMgrRef, Reason, Timeout) -> okswap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -> Resultswap_sup_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -> Resultwhich_handlers(EventMgrRef) -> [Handler]Module:code_change(OldVsn, State, Extra) -> {ok, NewState}Module:format_status(Opt, [PDict, State]) -> StatusModule:handle_call(Request, State) -> ResultModule:handle_event(Event, State) -> ResultModule:handle_info(Info, State) -> ResultModule:init(InitArgs) -> {ok,State} | {ok,State,hibernate} | {error,Reason}Module:terminate(Arg, State) -> term()"
  ],
  ["gen_fsm"],
  [
    "gen_sctp",
    "abort(Socket, Assoc) -> ok | {error, inet:posix()}close(Socket) -> ok | {error, inet:posix()}connect(Socket, Addr, Port, Opts) -> {ok, #sctp_assoc_change{state = comm_up}} | {error, #sctp_assoc_change{state = cant_assoc}} | {error, inet:posix()}connect(Socket, Addr, Port, Opts, Timeout) -> {ok, #sctp_assoc_change{state = comm_up}} | {error, #sctp_assoc_change{state = cant_assoc}} | {error, inet:posix()}connect_init(Socket, Addr, Port, Opts) -> ok | {error, inet:posix()}connect_init(Socket, Addr, Port, Opts, Timeout) -> ok | {error, inet:posix()}controlling_process(Socket, Pid) -> ok | {error, Reason}eof(Socket, Assoc) -> ok | {error, Reason}error_string(ErrorNumber) -> ok | string() | unknown_errorlisten(Socket, IsServer) -> ok | {error, Reason}listen(Socket, Backlog) -> ok | {error, Reason}open() -> {ok, Socket} | {error, inet:posix()}open(Port) -> {ok, Socket} | {error, inet:posix()}open(Opts) -> {ok, Socket} | {error, inet:posix()}open(Port, Opts) -> {ok, Socket} | {error, inet:posix()}peeloff(Socket, Assoc) -> {ok, NewSocket} | {error, Reason}recv(Socket) -> {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}recv(Socket, Timeout) -> {ok, {FromIP, FromPort, AncData, Data}} | {error, Reason}send(Socket, SndRcvInfo, Data) -> ok | {error, Reason}send(Socket, Assoc, Stream, Data) -> ok | {error, Reason}"
  ],
  [
    "gen_server",
    "abcast(Name, Request) -> abcastabcast(Nodes, Name, Request) -> abcastcall(ServerRef, Request) -> Replycall(ServerRef, Request, Timeout) -> Replycast(ServerRef, Request) -> okenter_loop(Module, Options, State)enter_loop(Module, Options, State, ServerName)enter_loop(Module, Options, State, Timeout)enter_loop(Module, Options, State, ServerName, Timeout)multi_call(Name, Request) -> Resultmulti_call(Nodes, Name, Request) -> Resultmulti_call(Nodes, Name, Request, Timeout) -> Resultreply(Client, Reply) -> Resultstart(Module, Args, Options) -> Resultstart(ServerName, Module, Args, Options) -> Resultstart_link(Module, Args, Options) -> Resultstart_link(ServerName, Module, Args, Options) -> Resultstop(ServerRef) -> okstop(ServerRef, Reason, Timeout) -> okModule:code_change(OldVsn, State, Extra) -> {ok, NewState} | {error, Reason}Module:format_status(Opt, [PDict, State]) -> StatusModule:handle_call(Request, From, State) -> ResultModule:handle_cast(Request, State) -> ResultModule:handle_continue(Continue, State) -> ResultModule:handle_info(Info, State) -> ResultModule:init(Args) -> ResultModule:terminate(Reason, State)"
  ],
  [
    "gen_statem",
    "call(ServerRef :: server_ref(), Request :: term()) -> Reply :: term()call(ServerRef :: server_ref(), Request :: term(), Timeout :: timeout() | {clean_timeout, T :: timeout()} | {dirty_timeout, T :: timeout()}) -> Reply :: term()cast(ServerRef :: server_ref(), Msg :: term()) -> okenter_loop(Module :: module(), Opts :: [enter_loop_opt()], State :: state(), Data :: data()) -> no_return()enter_loop(Module :: module(), Opts :: [enter_loop_opt()], State :: state(), Data :: data(), Server_or_Actions :: server_name() | pid() | [action()]) -> no_return()enter_loop(Module :: module(), Opts :: [enter_loop_opt()], State :: state(), Data :: data(), Server :: server_name() | pid(), Actions :: [action()] | action()) -> no_return()reply(Replies :: [reply_action()] | reply_action()) -> okreply(From :: from(), Reply :: term()) -> okstart(Module :: module(), Args :: term(), Opts :: [start_opt()]) -> start_ret() start(ServerName :: server_name(), Module :: module(), Args :: term(), Opts :: [start_opt()]) -> start_ret() start_link(Module :: module(), Args :: term(), Opts :: [start_opt()]) -> start_ret() start_link(ServerName :: server_name(), Module :: module(), Args :: term(), Opts :: [start_opt()]) -> start_ret() stop(ServerRef :: server_ref()) -> okstop(ServerRef :: server_ref(), Reason :: term(), Timeout :: timeout()) -> ok",
    "Module:callback_mode() -> CallbackModeModule:code_change(OldVsn, OldState, OldData, Extra) -> Result Module:init(Args) -> Result(StateType)Module:format_status(Opt, [PDict,State,Data]) -> Status Module:StateName(enter, OldState, Data) -> StateEnterResult(StateName) Module:StateName(EventType, EventContent, Data) -> StateFunctionResult Module:handle_event(enter, OldState, State, Data) -> StateEnterResult(State) Module:handle_event(EventType, EventContent, State, Data) -> HandleEventResult Module:terminate(Reason, State, Data) -> Ignored"
  ],
  [
    "gen_tcp",
    "accept(ListenSocket) -> {ok, Socket} | {error, Reason}accept(ListenSocket, Timeout) -> {ok, Socket} | {error, Reason}close(Socket) -> okconnect(Address, Port, Options) -> {ok, Socket} | {error, Reason}connect(Address, Port, Options, Timeout) -> {ok, Socket} | {error, Reason}controlling_process(Socket, Pid) -> ok | {error, Reason}listen(Port, Options) -> {ok, ListenSocket} | {error, Reason}recv(Socket, Length) -> {ok, Packet} | {error, Reason}recv(Socket, Length, Timeout) -> {ok, Packet} | {error, Reason}send(Socket, Packet) -> ok | {error, Reason}shutdown(Socket, How) -> ok | {error, Reason}"
  ],
  [
    "gen_udp",
    "close(Socket) -> okcontrolling_process(Socket, Pid) -> ok | {error, Reason}open(Port) -> {ok, Socket} | {error, Reason}open(Port, Opts) -> {ok, Socket} | {error, Reason}recv(Socket, Length) -> {ok, RecvData} | {error, Reason}recv(Socket, Length, Timeout) -> {ok, RecvData} | {error, Reason}send(Socket, Destination, Packet) -> ok | {error, Reason}send(Socket, Host, Port, Packet) -> ok | {error, Reason}send(Socket, Destination, AncData, Packet) -> ok | {error, Reason}send(Socket, Destination, PortZero, Packet) -> ok | {error, Reason}send(Socket, Host, Port, AncData, Packet) -> ok | {error, Reason}"
  ],
  [
    "gl",
    "clearIndex(C) -> okclearColor(Red, Green, Blue, Alpha) -> okclear(Mask) -> okindexMask(Mask) -> okcolorMask(Red, Green, Blue, Alpha) -> okalphaFunc(Func, Ref) -> okblendFunc(Sfactor, Dfactor) -> oklogicOp(Opcode) -> okcullFace(Mode) -> okfrontFace(Mode) -> okpointSize(Size) -> oklineWidth(Width) -> oklineStipple(Factor, Pattern) -> okpolygonMode(Face, Mode) -> okpolygonOffset(Factor, Units) -> okpolygonStipple(Mask) -> okgetPolygonStipple() -> binary()edgeFlag(Flag) -> okedgeFlagv(Flag) -> okscissor(X, Y, Width, Height) -> okclipPlane(Plane, Equation) -> okgetClipPlane(Plane) -> {float(), float(), float(), float()}drawBuffer(Mode) -> okreadBuffer(Mode) -> okenable(Cap) -> okdisable(Cap) -> okisEnabled(Cap) -> 0 | 1enableClientState(Cap) -> okdisableClientState(Cap) -> okgetBooleanv(Pname) -> [0 | 1]getDoublev(Pname) -> [float()]getFloatv(Pname) -> [float()]getIntegerv(Pname) -> [integer()]pushAttrib(Mask) -> okpopAttrib() -> okpushClientAttrib(Mask) -> okpopClientAttrib() -> okrenderMode(Mode) -> integer()getError() -> enum()getString(Name) -> string()finish() -> okflush() -> okhint(Target, Mode) -> okclearDepth(Depth) -> okdepthFunc(Func) -> okdepthMask(Flag) -> okdepthRange(Near_val, Far_val) -> okclearAccum(Red, Green, Blue, Alpha) -> okaccum(Op, Value) -> okmatrixMode(Mode) -> okortho(Left, Right, Bottom, Top, Near_val, Far_val) -> okfrustum(Left, Right, Bottom, Top, Near_val, Far_val) -> okviewport(X, Y, Width, Height) -> okpushMatrix() -> okpopMatrix() -> okloadIdentity() -> okloadMatrixd(M) -> okloadMatrixf(M) -> okmultMatrixd(M) -> okmultMatrixf(M) -> okrotated(Angle, X, Y, Z) -> okrotatef(Angle, X, Y, Z) -> okscaled(X, Y, Z) -> okscalef(X, Y, Z) -> oktranslated(X, Y, Z) -> oktranslatef(X, Y, Z) -> okisList(List) -> 0 | 1deleteLists(List, Range) -> okgenLists(Range) -> integer()newList(List, Mode) -> okendList() -> okcallList(List) -> okcallLists(Lists) -> oklistBase(Base) -> okbegin(Mode) -> okend() -> okvertex2d(X, Y) -> okvertex2f(X, Y) -> okvertex2i(X, Y) -> okvertex2s(X, Y) -> okvertex3d(X, Y, Z) -> okvertex3f(X, Y, Z) -> okvertex3i(X, Y, Z) -> okvertex3s(X, Y, Z) -> okvertex4d(X, Y, Z, W) -> okvertex4f(X, Y, Z, W) -> okvertex4i(X, Y, Z, W) -> okvertex4s(X, Y, Z, W) -> okvertex2dv(V) -> okvertex2fv(V) -> okvertex2iv(V) -> okvertex2sv(V) -> okvertex3dv(V) -> okvertex3fv(V) -> okvertex3iv(V) -> okvertex3sv(V) -> okvertex4dv(V) -> okvertex4fv(V) -> okvertex4iv(V) -> okvertex4sv(V) -> oknormal3b(Nx, Ny, Nz) -> oknormal3d(Nx, Ny, Nz) -> oknormal3f(Nx, Ny, Nz) -> oknormal3i(Nx, Ny, Nz) -> oknormal3s(Nx, Ny, Nz) -> oknormal3bv(V) -> oknormal3dv(V) -> oknormal3fv(V) -> oknormal3iv(V) -> oknormal3sv(V) -> okindexd(C) -> okindexf(C) -> okindexi(C) -> okindexs(C) -> okindexub(C) -> okindexdv(C) -> okindexfv(C) -> okindexiv(C) -> okindexsv(C) -> okindexubv(C) -> okcolor3b(Red, Green, Blue) -> okcolor3d(Red, Green, Blue) -> okcolor3f(Red, Green, Blue) -> okcolor3i(Red, Green, Blue) -> okcolor3s(Red, Green, Blue) -> okcolor3ub(Red, Green, Blue) -> okcolor3ui(Red, Green, Blue) -> okcolor3us(Red, Green, Blue) -> okcolor4b(Red, Green, Blue, Alpha) -> okcolor4d(Red, Green, Blue, Alpha) -> okcolor4f(Red, Green, Blue, Alpha) -> okcolor4i(Red, Green, Blue, Alpha) -> okcolor4s(Red, Green, Blue, Alpha) -> okcolor4ub(Red, Green, Blue, Alpha) -> okcolor4ui(Red, Green, Blue, Alpha) -> okcolor4us(Red, Green, Blue, Alpha) -> okcolor3bv(V) -> okcolor3dv(V) -> okcolor3fv(V) -> okcolor3iv(V) -> okcolor3sv(V) -> okcolor3ubv(V) -> okcolor3uiv(V) -> okcolor3usv(V) -> okcolor4bv(V) -> okcolor4dv(V) -> okcolor4fv(V) -> okcolor4iv(V) -> okcolor4sv(V) -> okcolor4ubv(V) -> okcolor4uiv(V) -> okcolor4usv(V) -> oktexCoord1d(S) -> oktexCoord1f(S) -> oktexCoord1i(S) -> oktexCoord1s(S) -> oktexCoord2d(S, T) -> oktexCoord2f(S, T) -> oktexCoord2i(S, T) -> oktexCoord2s(S, T) -> oktexCoord3d(S, T, R) -> oktexCoord3f(S, T, R) -> oktexCoord3i(S, T, R) -> oktexCoord3s(S, T, R) -> oktexCoord4d(S, T, R, Q) -> oktexCoord4f(S, T, R, Q) -> oktexCoord4i(S, T, R, Q) -> oktexCoord4s(S, T, R, Q) -> oktexCoord1dv(V) -> oktexCoord1fv(V) -> oktexCoord1iv(V) -> oktexCoord1sv(V) -> oktexCoord2dv(V) -> oktexCoord2fv(V) -> oktexCoord2iv(V) -> oktexCoord2sv(V) -> oktexCoord3dv(V) -> oktexCoord3fv(V) -> oktexCoord3iv(V) -> oktexCoord3sv(V) -> oktexCoord4dv(V) -> oktexCoord4fv(V) -> oktexCoord4iv(V) -> oktexCoord4sv(V) -> okrasterPos2d(X, Y) -> okrasterPos2f(X, Y) -> okrasterPos2i(X, Y) -> okrasterPos2s(X, Y) -> okrasterPos3d(X, Y, Z) -> okrasterPos3f(X, Y, Z) -> okrasterPos3i(X, Y, Z) -> okrasterPos3s(X, Y, Z) -> okrasterPos4d(X, Y, Z, W) -> okrasterPos4f(X, Y, Z, W) -> okrasterPos4i(X, Y, Z, W) -> okrasterPos4s(X, Y, Z, W) -> okrasterPos2dv(V) -> okrasterPos2fv(V) -> okrasterPos2iv(V) -> okrasterPos2sv(V) -> okrasterPos3dv(V) -> okrasterPos3fv(V) -> okrasterPos3iv(V) -> okrasterPos3sv(V) -> okrasterPos4dv(V) -> okrasterPos4fv(V) -> okrasterPos4iv(V) -> okrasterPos4sv(V) -> okrectd(X1, Y1, X2, Y2) -> okrectf(X1, Y1, X2, Y2) -> okrecti(X1, Y1, X2, Y2) -> okrects(X1, Y1, X2, Y2) -> okrectdv(V1, V2) -> okrectfv(V1, V2) -> okrectiv(V1, V2) -> okrectsv(V1, V2) -> okvertexPointer(Size, Type, Stride, Ptr) -> oknormalPointer(Type, Stride, Ptr) -> okcolorPointer(Size, Type, Stride, Ptr) -> okindexPointer(Type, Stride, Ptr) -> oktexCoordPointer(Size, Type, Stride, Ptr) -> okedgeFlagPointer(Stride, Ptr) -> okarrayElement(I) -> okdrawArrays(Mode, First, Count) -> okdrawElements(Mode, Count, Type, Indices) -> okinterleavedArrays(Format, Stride, Pointer) -> okshadeModel(Mode) -> oklightf(Light, Pname, Param) -> oklighti(Light, Pname, Param) -> oklightfv(Light, Pname, Params) -> oklightiv(Light, Pname, Params) -> okgetLightfv(Light, Pname) -> {float(), float(), float(), float()}getLightiv(Light, Pname) -> {integer(), integer(), integer(), integer()}lightModelf(Pname, Param) -> oklightModeli(Pname, Param) -> oklightModelfv(Pname, Params) -> oklightModeliv(Pname, Params) -> okmaterialf(Face, Pname, Param) -> okmateriali(Face, Pname, Param) -> okmaterialfv(Face, Pname, Params) -> okmaterialiv(Face, Pname, Params) -> okgetMaterialfv(Face, Pname) -> {float(), float(), float(), float()}getMaterialiv(Face, Pname) -> {integer(), integer(), integer(), integer()}colorMaterial(Face, Mode) -> okpixelZoom(Xfactor, Yfactor) -> okpixelStoref(Pname, Param) -> okpixelStorei(Pname, Param) -> okpixelTransferf(Pname, Param) -> okpixelTransferi(Pname, Param) -> okpixelMapfv(Map, Mapsize, Values) -> okpixelMapuiv(Map, Mapsize, Values) -> okpixelMapusv(Map, Mapsize, Values) -> okgetPixelMapfv(Map, Values) -> okgetPixelMapuiv(Map, Values) -> okgetPixelMapusv(Map, Values) -> okbitmap(Width, Height, Xorig, Yorig, Xmove, Ymove, Bitmap) -> okreadPixels(X, Y, Width, Height, Format, Type, Pixels) -> okdrawPixels(Width, Height, Format, Type, Pixels) -> okcopyPixels(X, Y, Width, Height, Type) -> okstencilFunc(Func, Ref, Mask) -> okstencilMask(Mask) -> okstencilOp(Fail, Zfail, Zpass) -> okclearStencil(S) -> oktexGend(Coord, Pname, Param) -> oktexGenf(Coord, Pname, Param) -> oktexGeni(Coord, Pname, Param) -> oktexGendv(Coord, Pname, Params) -> oktexGenfv(Coord, Pname, Params) -> oktexGeniv(Coord, Pname, Params) -> okgetTexGendv(Coord, Pname) -> {float(), float(), float(), float()}getTexGenfv(Coord, Pname) -> {float(), float(), float(), float()}getTexGeniv(Coord, Pname) -> {integer(), integer(), integer(), integer()}texEnvf(Target, Pname, Param) -> oktexEnvi(Target, Pname, Param) -> oktexEnvfv(Target, Pname, Params) -> oktexEnviv(Target, Pname, Params) -> okgetTexEnvfv(Target, Pname) -> {float(), float(), float(), float()}getTexEnviv(Target, Pname) -> {integer(), integer(), integer(), integer()}texParameterf(Target, Pname, Param) -> oktexParameteri(Target, Pname, Param) -> oktexParameterfv(Target, Pname, Params) -> oktexParameteriv(Target, Pname, Params) -> okgetTexParameterfv(Target, Pname) -> {float(), float(), float(), float()}getTexParameteriv(Target, Pname) -> {integer(), integer(), integer(), integer()}getTexLevelParameterfv(Target, Level, Pname) -> {float()}getTexLevelParameteriv(Target, Level, Pname) -> {integer()}texImage1D(Target, Level, InternalFormat, Width, Border, Format, Type, Pixels) -> oktexImage2D(Target, Level, InternalFormat, Width, Height, Border, Format, Type, Pixels) -> okgetTexImage(Target, Level, Format, Type, Pixels) -> okgenTextures(N) -> [integer()]deleteTextures(Textures) -> okbindTexture(Target, Texture) -> okprioritizeTextures(Textures, Priorities) -> okareTexturesResident(Textures) -> {0 | 1, Residences::[0 | 1]}isTexture(Texture) -> 0 | 1texSubImage1D(Target, Level, Xoffset, Width, Format, Type, Pixels) -> oktexSubImage2D(Target, Level, Xoffset, Yoffset, Width, Height, Format, Type, Pixels) -> okcopyTexImage1D(Target, Level, Internalformat, X, Y, Width, Border) -> okcopyTexImage2D(Target, Level, Internalformat, X, Y, Width, Height, Border) -> okcopyTexSubImage1D(Target, Level, Xoffset, X, Y, Width) -> okcopyTexSubImage2D(Target, Level, Xoffset, Yoffset, X, Y, Width, Height) -> okmap1d(Target, U1, U2, Stride, Order, Points) -> okmap1f(Target, U1, U2, Stride, Order, Points) -> okmap2d(Target, U1, U2, Ustride, Uorder, V1, V2, Vstride, Vorder, Points) -> okmap2f(Target, U1, U2, Ustride, Uorder, V1, V2, Vstride, Vorder, Points) -> okgetMapdv(Target, Query, V) -> okgetMapfv(Target, Query, V) -> okgetMapiv(Target, Query, V) -> okevalCoord1d(U) -> okevalCoord1f(U) -> okevalCoord1dv(U) -> okevalCoord1fv(U) -> okevalCoord2d(U, V) -> okevalCoord2f(U, V) -> okevalCoord2dv(U) -> okevalCoord2fv(U) -> okmapGrid1d(Un, U1, U2) -> okmapGrid1f(Un, U1, U2) -> okmapGrid2d(Un, U1, U2, Vn, V1, V2) -> okmapGrid2f(Un, U1, U2, Vn, V1, V2) -> okevalPoint1(I) -> okevalPoint2(I, J) -> okevalMesh1(Mode, I1, I2) -> okevalMesh2(Mode, I1, I2, J1, J2) -> okfogf(Pname, Param) -> okfogi(Pname, Param) -> okfogfv(Pname, Params) -> okfogiv(Pname, Params) -> okfeedbackBuffer(Size, Type, Buffer) -> okpassThrough(Token) -> okselectBuffer(Size, Buffer) -> okinitNames() -> okloadName(Name) -> okpushName(Name) -> okpopName() -> okblendColor(Red, Green, Blue, Alpha) -> okblendEquation(Mode) -> okdrawRangeElements(Mode, Start, End, Count, Type, Indices) -> oktexImage3D(Target, Level, InternalFormat, Width, Height, Depth, Border, Format, Type, Pixels) -> oktexSubImage3D(Target, Level, Xoffset, Yoffset, Zoffset, Width, Height, Depth, Format, Type, Pixels) -> okcopyTexSubImage3D(Target, Level, Xoffset, Yoffset, Zoffset, X, Y, Width, Height) -> okcolorTable(Target, Internalformat, Width, Format, Type, Table) -> okcolorTableParameterfv(Target, Pname, Params) -> okcolorTableParameteriv(Target, Pname, Params) -> okcopyColorTable(Target, Internalformat, X, Y, Width) -> okgetColorTable(Target, Format, Type, Table) -> okgetColorTableParameterfv(Target, Pname) -> {float(), float(), float(), float()}getColorTableParameteriv(Target, Pname) -> {integer(), integer(), integer(), integer()}colorSubTable(Target, Start, Count, Format, Type, Data) -> okcopyColorSubTable(Target, Start, X, Y, Width) -> okconvolutionFilter1D(Target, Internalformat, Width, Format, Type, Image) -> okconvolutionFilter2D(Target, Internalformat, Width, Height, Format, Type, Image) -> okconvolutionParameterf(Target, Pname, Params) -> okconvolutionParameterfv(Target::enum(), Pname::enum(), Params) -> okconvolutionParameteri(Target, Pname, Params) -> okconvolutionParameteriv(Target::enum(), Pname::enum(), Params) -> okcopyConvolutionFilter1D(Target, Internalformat, X, Y, Width) -> okcopyConvolutionFilter2D(Target, Internalformat, X, Y, Width, Height) -> okgetConvolutionFilter(Target, Format, Type, Image) -> okgetConvolutionParameterfv(Target, Pname) -> {float(), float(), float(), float()}getConvolutionParameteriv(Target, Pname) -> {integer(), integer(), integer(), integer()}separableFilter2D(Target, Internalformat, Width, Height, Format, Type, Row, Column) -> okgetHistogram(Target, Reset, Format, Type, Values) -> okgetHistogramParameterfv(Target, Pname) -> {float()}getHistogramParameteriv(Target, Pname) -> {integer()}getMinmax(Target, Reset, Format, Types, Values) -> okgetMinmaxParameterfv(Target, Pname) -> {float()}getMinmaxParameteriv(Target, Pname) -> {integer()}histogram(Target, Width, Internalformat, Sink) -> okminmax(Target, Internalformat, Sink) -> okresetHistogram(Target) -> okresetMinmax(Target) -> okactiveTexture(Texture) -> oksampleCoverage(Value, Invert) -> okcompressedTexImage3D(Target, Level, Internalformat, Width, Height, Depth, Border, ImageSize, Data) -> okcompressedTexImage2D(Target, Level, Internalformat, Width, Height, Border, ImageSize, Data) -> okcompressedTexImage1D(Target, Level, Internalformat, Width, Border, ImageSize, Data) -> okcompressedTexSubImage3D(Target, Level, Xoffset, Yoffset, Zoffset, Width, Height, Depth, Format, ImageSize, Data) -> okcompressedTexSubImage2D(Target, Level, Xoffset, Yoffset, Width, Height, Format, ImageSize, Data) -> okcompressedTexSubImage1D(Target, Level, Xoffset, Width, Format, ImageSize, Data) -> okgetCompressedTexImage(Target, Lod, Img) -> okclientActiveTexture(Texture) -> okmultiTexCoord1d(Target, S) -> okmultiTexCoord1dv(Target::enum(), V) -> okmultiTexCoord1f(Target, S) -> okmultiTexCoord1fv(Target::enum(), V) -> okmultiTexCoord1i(Target, S) -> okmultiTexCoord1iv(Target::enum(), V) -> okmultiTexCoord1s(Target, S) -> okmultiTexCoord1sv(Target::enum(), V) -> okmultiTexCoord2d(Target, S, T) -> okmultiTexCoord2dv(Target::enum(), V) -> okmultiTexCoord2f(Target, S, T) -> okmultiTexCoord2fv(Target::enum(), V) -> okmultiTexCoord2i(Target, S, T) -> okmultiTexCoord2iv(Target::enum(), V) -> okmultiTexCoord2s(Target, S, T) -> okmultiTexCoord2sv(Target::enum(), V) -> okmultiTexCoord3d(Target, S, T, R) -> okmultiTexCoord3dv(Target::enum(), V) -> okmultiTexCoord3f(Target, S, T, R) -> okmultiTexCoord3fv(Target::enum(), V) -> okmultiTexCoord3i(Target, S, T, R) -> okmultiTexCoord3iv(Target::enum(), V) -> okmultiTexCoord3s(Target, S, T, R) -> okmultiTexCoord3sv(Target::enum(), V) -> okmultiTexCoord4d(Target, S, T, R, Q) -> okmultiTexCoord4dv(Target::enum(), V) -> okmultiTexCoord4f(Target, S, T, R, Q) -> okmultiTexCoord4fv(Target::enum(), V) -> okmultiTexCoord4i(Target, S, T, R, Q) -> okmultiTexCoord4iv(Target::enum(), V) -> okmultiTexCoord4s(Target, S, T, R, Q) -> okmultiTexCoord4sv(Target::enum(), V) -> okloadTransposeMatrixf(M) -> okloadTransposeMatrixd(M) -> okmultTransposeMatrixf(M) -> okmultTransposeMatrixd(M) -> okblendFuncSeparate(SfactorRGB, DfactorRGB, SfactorAlpha, DfactorAlpha) -> okmultiDrawArrays(Mode, First, Count) -> okpointParameterf(Pname, Param) -> okpointParameterfv(Pname, Params) -> okpointParameteri(Pname, Param) -> okpointParameteriv(Pname, Params) -> okfogCoordf(Coord) -> okfogCoordfv(Coord) -> okfogCoordd(Coord) -> okfogCoorddv(Coord) -> okfogCoordPointer(Type, Stride, Pointer) -> oksecondaryColor3b(Red, Green, Blue) -> oksecondaryColor3bv(V) -> oksecondaryColor3d(Red, Green, Blue) -> oksecondaryColor3dv(V) -> oksecondaryColor3f(Red, Green, Blue) -> oksecondaryColor3fv(V) -> oksecondaryColor3i(Red, Green, Blue) -> oksecondaryColor3iv(V) -> oksecondaryColor3s(Red, Green, Blue) -> oksecondaryColor3sv(V) -> oksecondaryColor3ub(Red, Green, Blue) -> oksecondaryColor3ubv(V) -> oksecondaryColor3ui(Red, Green, Blue) -> oksecondaryColor3uiv(V) -> oksecondaryColor3us(Red, Green, Blue) -> oksecondaryColor3usv(V) -> oksecondaryColorPointer(Size, Type, Stride, Pointer) -> okwindowPos2d(X, Y) -> okwindowPos2dv(V) -> okwindowPos2f(X, Y) -> okwindowPos2fv(V) -> okwindowPos2i(X, Y) -> okwindowPos2iv(V) -> okwindowPos2s(X, Y) -> okwindowPos2sv(V) -> okwindowPos3d(X, Y, Z) -> okwindowPos3dv(V) -> okwindowPos3f(X, Y, Z) -> okwindowPos3fv(V) -> okwindowPos3i(X, Y, Z) -> okwindowPos3iv(V) -> okwindowPos3s(X, Y, Z) -> okwindowPos3sv(V) -> okgenQueries(N) -> [integer()]deleteQueries(Ids) -> okisQuery(Id) -> 0 | 1beginQuery(Target, Id) -> okendQuery(Target) -> okgetQueryiv(Target, Pname) -> integer()getQueryObjectiv(Id, Pname) -> integer()getQueryObjectuiv(Id, Pname) -> integer()bindBuffer(Target, Buffer) -> okdeleteBuffers(Buffers) -> okgenBuffers(N) -> [integer()]isBuffer(Buffer) -> 0 | 1bufferData(Target, Size, Data, Usage) -> okbufferSubData(Target, Offset, Size, Data) -> okgetBufferSubData(Target, Offset, Size, Data) -> okgetBufferParameteriv(Target, Pname) -> integer()blendEquationSeparate(ModeRGB, ModeAlpha) -> okdrawBuffers(Bufs) -> okstencilOpSeparate(Face, Sfail, Dpfail, Dppass) -> okstencilFuncSeparate(Face, Func, Ref, Mask) -> okstencilMaskSeparate(Face, Mask) -> okattachShader(Program, Shader) -> okbindAttribLocation(Program, Index, Name) -> okcompileShader(Shader) -> okcreateProgram() -> integer()createShader(Type) -> integer()deleteProgram(Program) -> okdeleteShader(Shader) -> okdetachShader(Program, Shader) -> okdisableVertexAttribArray(Index) -> okenableVertexAttribArray(Index) -> okgetActiveAttrib(Program, Index, BufSize) -> {Size::integer(), Type::enum(), Name::string()}getActiveUniform(Program, Index, BufSize) -> {Size::integer(), Type::enum(), Name::string()}getAttachedShaders(Program, MaxCount) -> [integer()]getAttribLocation(Program, Name) -> integer()getProgramiv(Program, Pname) -> integer()getProgramInfoLog(Program, BufSize) -> string()getShaderiv(Shader, Pname) -> integer()getShaderInfoLog(Shader, BufSize) -> string()getShaderSource(Shader, BufSize) -> string()getUniformLocation(Program, Name) -> integer()getUniformfv(Program, Location) -> matrix()getUniformiv(Program, Location) -> {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}getVertexAttribdv(Index, Pname) -> {float(), float(), float(), float()}getVertexAttribfv(Index, Pname) -> {float(), float(), float(), float()}getVertexAttribiv(Index, Pname) -> {integer(), integer(), integer(), integer()}isProgram(Program) -> 0 | 1isShader(Shader) -> 0 | 1linkProgram(Program) -> okshaderSource(Shader, String) -> okuseProgram(Program) -> okuniform1f(Location, V0) -> okuniform2f(Location, V0, V1) -> okuniform3f(Location, V0, V1, V2) -> okuniform4f(Location, V0, V1, V2, V3) -> okuniform1i(Location, V0) -> okuniform2i(Location, V0, V1) -> okuniform3i(Location, V0, V1, V2) -> okuniform4i(Location, V0, V1, V2, V3) -> okuniform1fv(Location, Value) -> okuniform2fv(Location, Value) -> okuniform3fv(Location, Value) -> okuniform4fv(Location, Value) -> okuniform1iv(Location, Value) -> okuniform2iv(Location, Value) -> okuniform3iv(Location, Value) -> okuniform4iv(Location, Value) -> okuniformMatrix2fv(Location, Transpose, Value) -> okuniformMatrix3fv(Location, Transpose, Value) -> okuniformMatrix4fv(Location, Transpose, Value) -> okvalidateProgram(Program) -> okvertexAttrib1d(Index, X) -> okvertexAttrib1dv(Index::integer(), V) -> okvertexAttrib1f(Index, X) -> okvertexAttrib1fv(Index::integer(), V) -> okvertexAttrib1s(Index, X) -> okvertexAttrib1sv(Index::integer(), V) -> okvertexAttrib2d(Index, X, Y) -> okvertexAttrib2dv(Index::integer(), V) -> okvertexAttrib2f(Index, X, Y) -> okvertexAttrib2fv(Index::integer(), V) -> okvertexAttrib2s(Index, X, Y) -> okvertexAttrib2sv(Index::integer(), V) -> okvertexAttrib3d(Index, X, Y, Z) -> okvertexAttrib3dv(Index::integer(), V) -> okvertexAttrib3f(Index, X, Y, Z) -> okvertexAttrib3fv(Index::integer(), V) -> okvertexAttrib3s(Index, X, Y, Z) -> okvertexAttrib3sv(Index::integer(), V) -> okvertexAttrib4Nbv(Index, V) -> okvertexAttrib4Niv(Index, V) -> okvertexAttrib4Nsv(Index, V) -> okvertexAttrib4Nub(Index, X, Y, Z, W) -> okvertexAttrib4Nubv(Index::integer(), V) -> okvertexAttrib4Nuiv(Index, V) -> okvertexAttrib4Nusv(Index, V) -> okvertexAttrib4bv(Index, V) -> okvertexAttrib4d(Index, X, Y, Z, W) -> okvertexAttrib4dv(Index::integer(), V) -> okvertexAttrib4f(Index, X, Y, Z, W) -> okvertexAttrib4fv(Index::integer(), V) -> okvertexAttrib4iv(Index, V) -> okvertexAttrib4s(Index, X, Y, Z, W) -> okvertexAttrib4sv(Index::integer(), V) -> okvertexAttrib4ubv(Index, V) -> okvertexAttrib4uiv(Index, V) -> okvertexAttrib4usv(Index, V) -> okvertexAttribPointer(Index, Size, Type, Normalized, Stride, Pointer) -> okuniformMatrix2x3fv(Location, Transpose, Value) -> okuniformMatrix3x2fv(Location, Transpose, Value) -> okuniformMatrix2x4fv(Location, Transpose, Value) -> okuniformMatrix4x2fv(Location, Transpose, Value) -> okuniformMatrix3x4fv(Location, Transpose, Value) -> okuniformMatrix4x3fv(Location, Transpose, Value) -> okcolorMaski(Index, R, G, B, A) -> okgetBooleani_v(Target, Index) -> [0 | 1]getIntegeri_v(Target, Index) -> [integer()]enablei(Target, Index) -> okdisablei(Target, Index) -> okisEnabledi(Target, Index) -> 0 | 1beginTransformFeedback(PrimitiveMode) -> okendTransformFeedback() -> okbindBufferRange(Target, Index, Buffer, Offset, Size) -> okbindBufferBase(Target, Index, Buffer) -> oktransformFeedbackVaryings(Program, Varyings, BufferMode) -> okgetTransformFeedbackVarying(Program, Index, BufSize) -> {Size::integer(), Type::enum(), Name::string()}clampColor(Target, Clamp) -> okbeginConditionalRender(Id, Mode) -> okendConditionalRender() -> okvertexAttribIPointer(Index, Size, Type, Stride, Pointer) -> okgetVertexAttribIiv(Index, Pname) -> {integer(), integer(), integer(), integer()}getVertexAttribIuiv(Index, Pname) -> {integer(), integer(), integer(), integer()}vertexAttribI1i(Index, X) -> okvertexAttribI2i(Index, X, Y) -> okvertexAttribI3i(Index, X, Y, Z) -> okvertexAttribI4i(Index, X, Y, Z, W) -> okvertexAttribI1ui(Index, X) -> okvertexAttribI2ui(Index, X, Y) -> okvertexAttribI3ui(Index, X, Y, Z) -> okvertexAttribI4ui(Index, X, Y, Z, W) -> okvertexAttribI1iv(Index::integer(), V) -> okvertexAttribI2iv(Index::integer(), V) -> okvertexAttribI3iv(Index::integer(), V) -> okvertexAttribI4iv(Index::integer(), V) -> okvertexAttribI1uiv(Index::integer(), V) -> okvertexAttribI2uiv(Index::integer(), V) -> okvertexAttribI3uiv(Index::integer(), V) -> okvertexAttribI4uiv(Index::integer(), V) -> okvertexAttribI4bv(Index, V) -> okvertexAttribI4sv(Index, V) -> okvertexAttribI4ubv(Index, V) -> okvertexAttribI4usv(Index, V) -> okgetUniformuiv(Program, Location) -> {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}bindFragDataLocation(Program, Color, Name) -> okgetFragDataLocation(Program, Name) -> integer()uniform1ui(Location, V0) -> okuniform2ui(Location, V0, V1) -> okuniform3ui(Location, V0, V1, V2) -> okuniform4ui(Location, V0, V1, V2, V3) -> okuniform1uiv(Location, Value) -> okuniform2uiv(Location, Value) -> okuniform3uiv(Location, Value) -> okuniform4uiv(Location, Value) -> oktexParameterIiv(Target, Pname, Params) -> oktexParameterIuiv(Target, Pname, Params) -> okgetTexParameterIiv(Target, Pname) -> {integer(), integer(), integer(), integer()}getTexParameterIuiv(Target, Pname) -> {integer(), integer(), integer(), integer()}clearBufferiv(Buffer, Drawbuffer, Value) -> okclearBufferuiv(Buffer, Drawbuffer, Value) -> okclearBufferfv(Buffer, Drawbuffer, Value) -> okclearBufferfi(Buffer, Drawbuffer, Depth, Stencil) -> okgetStringi(Name, Index) -> string()drawArraysInstanced(Mode, First, Count, Primcount) -> okdrawElementsInstanced(Mode, Count, Type, Indices, Primcount) -> oktexBuffer(Target, Internalformat, Buffer) -> okprimitiveRestartIndex(Index) -> okgetInteger64i_v(Target, Index) -> [integer()]getBufferParameteri64v(Target, Pname) -> [integer()]framebufferTexture(Target, Attachment, Texture, Level) -> okvertexAttribDivisor(Index, Divisor) -> okminSampleShading(Value) -> okblendEquationi(Buf, Mode) -> okblendEquationSeparatei(Buf, ModeRGB, ModeAlpha) -> okblendFunci(Buf, Src, Dst) -> okblendFuncSeparatei(Buf, SrcRGB, DstRGB, SrcAlpha, DstAlpha) -> okloadTransposeMatrixfARB(M) -> okloadTransposeMatrixdARB(M) -> okmultTransposeMatrixfARB(M) -> okmultTransposeMatrixdARB(M) -> okweightbvARB(Weights) -> okweightsvARB(Weights) -> okweightivARB(Weights) -> okweightfvARB(Weights) -> okweightdvARB(Weights) -> okweightubvARB(Weights) -> okweightusvARB(Weights) -> okweightuivARB(Weights) -> okvertexBlendARB(Count) -> okcurrentPaletteMatrixARB(Index) -> okmatrixIndexubvARB(Indices) -> okmatrixIndexusvARB(Indices) -> okmatrixIndexuivARB(Indices) -> okprogramStringARB(Target, Format, String) -> okbindProgramARB(Target, Program) -> okdeleteProgramsARB(Programs) -> okgenProgramsARB(N) -> [integer()]programEnvParameter4dARB(Target, Index, X, Y, Z, W) -> okprogramEnvParameter4dvARB(Target, Index, Params) -> okprogramEnvParameter4fARB(Target, Index, X, Y, Z, W) -> okprogramEnvParameter4fvARB(Target, Index, Params) -> okprogramLocalParameter4dARB(Target, Index, X, Y, Z, W) -> okprogramLocalParameter4dvARB(Target, Index, Params) -> okprogramLocalParameter4fARB(Target, Index, X, Y, Z, W) -> okprogramLocalParameter4fvARB(Target, Index, Params) -> okgetProgramEnvParameterdvARB(Target, Index) -> {float(), float(), float(), float()}getProgramEnvParameterfvARB(Target, Index) -> {float(), float(), float(), float()}getProgramLocalParameterdvARB(Target, Index) -> {float(), float(), float(), float()}getProgramLocalParameterfvARB(Target, Index) -> {float(), float(), float(), float()}getProgramStringARB(Target, Pname, String) -> okgetBufferParameterivARB(Target, Pname) -> [integer()]deleteObjectARB(Obj) -> okgetHandleARB(Pname) -> integer()detachObjectARB(ContainerObj, AttachedObj) -> okcreateShaderObjectARB(ShaderType) -> integer()shaderSourceARB(ShaderObj, String) -> okcompileShaderARB(ShaderObj) -> okcreateProgramObjectARB() -> integer()attachObjectARB(ContainerObj, Obj) -> oklinkProgramARB(ProgramObj) -> okuseProgramObjectARB(ProgramObj) -> okvalidateProgramARB(ProgramObj) -> okgetObjectParameterfvARB(Obj, Pname) -> float()getObjectParameterivARB(Obj, Pname) -> integer()getInfoLogARB(Obj, MaxLength) -> string()getAttachedObjectsARB(ContainerObj, MaxCount) -> [integer()]getUniformLocationARB(ProgramObj, Name) -> integer()getActiveUniformARB(ProgramObj, Index, MaxLength) -> {Size::integer(), Type::enum(), Name::string()}getUniformfvARB(ProgramObj, Location) -> matrix()getUniformivARB(ProgramObj, Location) -> {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}getShaderSourceARB(Obj, MaxLength) -> string()bindAttribLocationARB(ProgramObj, Index, Name) -> okgetActiveAttribARB(ProgramObj, Index, MaxLength) -> {Size::integer(), Type::enum(), Name::string()}getAttribLocationARB(ProgramObj, Name) -> integer()isRenderbuffer(Renderbuffer) -> 0 | 1bindRenderbuffer(Target, Renderbuffer) -> okdeleteRenderbuffers(Renderbuffers) -> okgenRenderbuffers(N) -> [integer()]renderbufferStorage(Target, Internalformat, Width, Height) -> okgetRenderbufferParameteriv(Target, Pname) -> integer()isFramebuffer(Framebuffer) -> 0 | 1bindFramebuffer(Target, Framebuffer) -> okdeleteFramebuffers(Framebuffers) -> okgenFramebuffers(N) -> [integer()]checkFramebufferStatus(Target) -> enum()framebufferTexture1D(Target, Attachment, Textarget, Texture, Level) -> okframebufferTexture2D(Target, Attachment, Textarget, Texture, Level) -> okframebufferTexture3D(Target, Attachment, Textarget, Texture, Level, Zoffset) -> okframebufferRenderbuffer(Target, Attachment, Renderbuffertarget, Renderbuffer) -> okgetFramebufferAttachmentParameteriv(Target, Attachment, Pname) -> integer()generateMipmap(Target) -> okblitFramebuffer(SrcX0, SrcY0, SrcX1, SrcY1, DstX0, DstY0, DstX1, DstY1, Mask, Filter) -> okrenderbufferStorageMultisample(Target, Samples, Internalformat, Width, Height) -> okframebufferTextureLayer(Target, Attachment, Texture, Level, Layer) -> okframebufferTextureFaceARB(Target, Attachment, Texture, Level, Face) -> okflushMappedBufferRange(Target, Offset, Length) -> okbindVertexArray(Array) -> okdeleteVertexArrays(Arrays) -> okgenVertexArrays(N) -> [integer()]isVertexArray(Array) -> 0 | 1getUniformIndices(Program, UniformNames) -> [integer()]getActiveUniformsiv(Program, UniformIndices, Pname) -> [integer()]getActiveUniformName(Program, UniformIndex, BufSize) -> string()getUniformBlockIndex(Program, UniformBlockName) -> integer()getActiveUniformBlockiv(Program, UniformBlockIndex, Pname, Params) -> okgetActiveUniformBlockName(Program, UniformBlockIndex, BufSize) -> string()uniformBlockBinding(Program, UniformBlockIndex, UniformBlockBinding) -> okcopyBufferSubData(ReadTarget, WriteTarget, ReadOffset, WriteOffset, Size) -> okdrawElementsBaseVertex(Mode, Count, Type, Indices, Basevertex) -> okdrawRangeElementsBaseVertex(Mode, Start, End, Count, Type, Indices, Basevertex) -> okdrawElementsInstancedBaseVertex(Mode, Count, Type, Indices, Primcount, Basevertex) -> okprovokingVertex(Mode) -> okfenceSync(Condition, Flags) -> integer()isSync(Sync) -> 0 | 1deleteSync(Sync) -> okclientWaitSync(Sync, Flags, Timeout) -> enum()waitSync(Sync, Flags, Timeout) -> okgetInteger64v(Pname) -> [integer()]getSynciv(Sync, Pname, BufSize) -> [integer()]texImage2DMultisample(Target, Samples, Internalformat, Width, Height, Fixedsamplelocations) -> oktexImage3DMultisample(Target, Samples, Internalformat, Width, Height, Depth, Fixedsamplelocations) -> okgetMultisamplefv(Pname, Index) -> {float(), float()}sampleMaski(Index, Mask) -> oknamedStringARB(Type, Name, String) -> okdeleteNamedStringARB(Name) -> okcompileShaderIncludeARB(Shader, Path) -> okisNamedStringARB(Name) -> 0 | 1getNamedStringARB(Name, BufSize) -> string()getNamedStringivARB(Name, Pname) -> integer()bindFragDataLocationIndexed(Program, ColorNumber, Index, Name) -> okgetFragDataIndex(Program, Name) -> integer()genSamplers(Count) -> [integer()]deleteSamplers(Samplers) -> okisSampler(Sampler) -> 0 | 1bindSampler(Unit, Sampler) -> oksamplerParameteri(Sampler, Pname, Param) -> oksamplerParameteriv(Sampler, Pname, Param) -> oksamplerParameterf(Sampler, Pname, Param) -> oksamplerParameterfv(Sampler, Pname, Param) -> oksamplerParameterIiv(Sampler, Pname, Param) -> oksamplerParameterIuiv(Sampler, Pname, Param) -> okgetSamplerParameteriv(Sampler, Pname) -> [integer()]getSamplerParameterIiv(Sampler, Pname) -> [integer()]getSamplerParameterfv(Sampler, Pname) -> [float()]getSamplerParameterIuiv(Sampler, Pname) -> [integer()]queryCounter(Id, Target) -> okgetQueryObjecti64v(Id, Pname) -> integer()getQueryObjectui64v(Id, Pname) -> integer()drawArraysIndirect(Mode, Indirect) -> okdrawElementsIndirect(Mode, Type, Indirect) -> okuniform1d(Location, X) -> okuniform2d(Location, X, Y) -> okuniform3d(Location, X, Y, Z) -> okuniform4d(Location, X, Y, Z, W) -> okuniform1dv(Location, Value) -> okuniform2dv(Location, Value) -> okuniform3dv(Location, Value) -> okuniform4dv(Location, Value) -> okuniformMatrix2dv(Location, Transpose, Value) -> okuniformMatrix3dv(Location, Transpose, Value) -> okuniformMatrix4dv(Location, Transpose, Value) -> okuniformMatrix2x3dv(Location, Transpose, Value) -> okuniformMatrix2x4dv(Location, Transpose, Value) -> okuniformMatrix3x2dv(Location, Transpose, Value) -> okuniformMatrix3x4dv(Location, Transpose, Value) -> okuniformMatrix4x2dv(Location, Transpose, Value) -> okuniformMatrix4x3dv(Location, Transpose, Value) -> okgetUniformdv(Program, Location) -> matrix()getSubroutineUniformLocation(Program, Shadertype, Name) -> integer()getSubroutineIndex(Program, Shadertype, Name) -> integer()getActiveSubroutineUniformName(Program, Shadertype, Index, Bufsize) -> string()getActiveSubroutineName(Program, Shadertype, Index, Bufsize) -> string()uniformSubroutinesuiv(Shadertype, Indices) -> okgetUniformSubroutineuiv(Shadertype, Location) -> {integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer(), integer()}getProgramStageiv(Program, Shadertype, Pname) -> integer()patchParameteri(Pname, Value) -> okpatchParameterfv(Pname, Values) -> okbindTransformFeedback(Target, Id) -> okdeleteTransformFeedbacks(Ids) -> okgenTransformFeedbacks(N) -> [integer()]isTransformFeedback(Id) -> 0 | 1pauseTransformFeedback() -> okresumeTransformFeedback() -> okdrawTransformFeedback(Mode, Id) -> okdrawTransformFeedbackStream(Mode, Id, Stream) -> okbeginQueryIndexed(Target, Index, Id) -> okendQueryIndexed(Target, Index) -> okgetQueryIndexediv(Target, Index, Pname) -> integer()releaseShaderCompiler() -> okshaderBinary(Shaders, Binaryformat, Binary) -> okgetShaderPrecisionFormat(Shadertype, Precisiontype) -> {Range::{integer(), integer()}, Precision::integer()}depthRangef(N, F) -> okclearDepthf(D) -> okgetProgramBinary(Program, BufSize) -> {BinaryFormat::enum(), Binary::binary()}programBinary(Program, BinaryFormat, Binary) -> okprogramParameteri(Program, Pname, Value) -> okuseProgramStages(Pipeline, Stages, Program) -> okactiveShaderProgram(Pipeline, Program) -> okcreateShaderProgramv(Type, Strings) -> integer()bindProgramPipeline(Pipeline) -> okdeleteProgramPipelines(Pipelines) -> okgenProgramPipelines(N) -> [integer()]isProgramPipeline(Pipeline) -> 0 | 1getProgramPipelineiv(Pipeline, Pname) -> integer()programUniform1i(Program, Location, V0) -> okprogramUniform1iv(Program, Location, Value) -> okprogramUniform1f(Program, Location, V0) -> okprogramUniform1fv(Program, Location, Value) -> okprogramUniform1d(Program, Location, V0) -> okprogramUniform1dv(Program, Location, Value) -> okprogramUniform1ui(Program, Location, V0) -> okprogramUniform1uiv(Program, Location, Value) -> okprogramUniform2i(Program, Location, V0, V1) -> okprogramUniform2iv(Program, Location, Value) -> okprogramUniform2f(Program, Location, V0, V1) -> okprogramUniform2fv(Program, Location, Value) -> okprogramUniform2d(Program, Location, V0, V1) -> okprogramUniform2dv(Program, Location, Value) -> okprogramUniform2ui(Program, Location, V0, V1) -> okprogramUniform2uiv(Program, Location, Value) -> okprogramUniform3i(Program, Location, V0, V1, V2) -> okprogramUniform3iv(Program, Location, Value) -> okprogramUniform3f(Program, Location, V0, V1, V2) -> okprogramUniform3fv(Program, Location, Value) -> okprogramUniform3d(Program, Location, V0, V1, V2) -> okprogramUniform3dv(Program, Location, Value) -> okprogramUniform3ui(Program, Location, V0, V1, V2) -> okprogramUniform3uiv(Program, Location, Value) -> okprogramUniform4i(Program, Location, V0, V1, V2, V3) -> okprogramUniform4iv(Program, Location, Value) -> okprogramUniform4f(Program, Location, V0, V1, V2, V3) -> okprogramUniform4fv(Program, Location, Value) -> okprogramUniform4d(Program, Location, V0, V1, V2, V3) -> okprogramUniform4dv(Program, Location, Value) -> okprogramUniform4ui(Program, Location, V0, V1, V2, V3) -> okprogramUniform4uiv(Program, Location, Value) -> okprogramUniformMatrix2fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix3fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix4fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix2dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix3dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix4dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix2x3fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix3x2fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix2x4fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix4x2fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix3x4fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix4x3fv(Program, Location, Transpose, Value) -> okprogramUniformMatrix2x3dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix3x2dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix2x4dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix4x2dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix3x4dv(Program, Location, Transpose, Value) -> okprogramUniformMatrix4x3dv(Program, Location, Transpose, Value) -> okvalidateProgramPipeline(Pipeline) -> okgetProgramPipelineInfoLog(Pipeline, BufSize) -> string()vertexAttribL1d(Index, X) -> okvertexAttribL2d(Index, X, Y) -> okvertexAttribL3d(Index, X, Y, Z) -> okvertexAttribL4d(Index, X, Y, Z, W) -> okvertexAttribL1dv(Index::integer(), V) -> okvertexAttribL2dv(Index::integer(), V) -> okvertexAttribL3dv(Index::integer(), V) -> okvertexAttribL4dv(Index::integer(), V) -> okvertexAttribLPointer(Index, Size, Type, Stride, Pointer) -> okgetVertexAttribLdv(Index, Pname) -> {float(), float(), float(), float()}viewportArrayv(First, V) -> okviewportIndexedf(Index, X, Y, W, H) -> okviewportIndexedfv(Index, V) -> okscissorArrayv(First, V) -> okscissorIndexed(Index, Left, Bottom, Width, Height) -> okscissorIndexedv(Index, V) -> okdepthRangeArrayv(First, V) -> okdepthRangeIndexed(Index, N, F) -> okgetFloati_v(Target, Index) -> [float()]getDoublei_v(Target, Index) -> [float()]debugMessageControlARB(Source, Type, Severity, Ids, Enabled) -> okdebugMessageInsertARB(Source, Type, Id, Severity, Buf) -> okgetDebugMessageLogARB(Count, Bufsize) -> {integer(), Sources::[enum()], Types::[enum()], Ids::[integer()], Severities::[enum()], MessageLog::[string()]}getGraphicsResetStatusARB() -> enum()drawArraysInstancedBaseInstance(Mode, First, Count, Primcount, Baseinstance) -> okdrawElementsInstancedBaseInstance(Mode, Count, Type, Indices, Primcount, Baseinstance) -> okdrawElementsInstancedBaseVertexBaseInstance(Mode, Count, Type, Indices, Primcount, Basevertex, Baseinstance) -> okdrawTransformFeedbackInstanced(Mode, Id, Primcount) -> okdrawTransformFeedbackStreamInstanced(Mode, Id, Stream, Primcount) -> okgetInternalformativ(Target, Internalformat, Pname, BufSize) -> [integer()]bindImageTexture(Unit, Texture, Level, Layered, Layer, Access, Format) -> okmemoryBarrier(Barriers) -> oktexStorage1D(Target, Levels, Internalformat, Width) -> oktexStorage2D(Target, Levels, Internalformat, Width, Height) -> oktexStorage3D(Target, Levels, Internalformat, Width, Height, Depth) -> okdepthBoundsEXT(Zmin, Zmax) -> okstencilClearTagEXT(StencilTagBits, StencilClearTag) -> ok"
  ],
  [
    "global",
    "del_lock(Id) -> truedel_lock(Id, Nodes) -> truenotify_all_name(Name, Pid1, Pid2) -> nonerandom_exit_name(Name, Pid1, Pid2) -> pid()random_notify_name(Name, Pid1, Pid2) -> pid()re_register_name(Name, Pid) -> yesre_register_name(Name, Pid, Resolve) -> yesregister_name(Name, Pid) -> yes | noregister_name(Name, Pid, Resolve) -> yes | noregistered_names() -> [Name]send(Name, Msg) -> Pidset_lock(Id) -> boolean()set_lock(Id, Nodes) -> boolean()set_lock(Id, Nodes, Retries) -> boolean()sync() -> ok | {error, Reason :: term()}trans(Id, Fun) -> Res | abortedtrans(Id, Fun, Nodes) -> Res | abortedtrans(Id, Fun, Nodes, Retries) -> Res | abortedunregister_name(Name) -> term()whereis_name(Name) -> pid() | undefined"
  ],
  [
    "global_group",
    "global_groups() -> {GroupName, GroupNames} | undefinedinfo() -> [info_item()]monitor_nodes(Flag) -> okown_nodes() -> Nodesregistered_names(Where) -> Namessend(Name, Msg) -> pid() | {badarg, {Name, Msg}}send(Where, Name, Msg) -> pid() | {badarg, {Name, Msg}}sync() -> okwhereis_name(Name) -> pid() | undefinedwhereis_name(Where, Name) -> pid() | undefined"
  ],
  [
    "glu",
    "tesselate(Normal, Vs::[Vs]) -> {Triangles, VertexPos}build1DMipmapLevels(Target, InternalFormat, Width, Format, Type, Level, Base, Max, Data) -> integer()build1DMipmaps(Target, InternalFormat, Width, Format, Type, Data) -> integer()build2DMipmapLevels(Target, InternalFormat, Width, Height, Format, Type, Level, Base, Max, Data) -> integer()build2DMipmaps(Target, InternalFormat, Width, Height, Format, Type, Data) -> integer()build3DMipmapLevels(Target, InternalFormat, Width, Height, Depth, Format, Type, Level, Base, Max, Data) -> integer()build3DMipmaps(Target, InternalFormat, Width, Height, Depth, Format, Type, Data) -> integer()checkExtension(ExtName, ExtString) -> 0 | 1cylinder(Quad, Base, Top, Height, Slices, Stacks) -> okdeleteQuadric(Quad) -> okdisk(Quad, Inner, Outer, Slices, Loops) -> okerrorString(Error) -> string()getString(Name) -> string()lookAt(EyeX, EyeY, EyeZ, CenterX, CenterY, CenterZ, UpX, UpY, UpZ) -> oknewQuadric() -> integer()ortho2D(Left, Right, Bottom, Top) -> okpartialDisk(Quad, Inner, Outer, Slices, Loops, Start, Sweep) -> okperspective(Fovy, Aspect, ZNear, ZFar) -> okpickMatrix(X, Y, DelX, DelY, Viewport) -> okproject(ObjX, ObjY, ObjZ, Model, Proj, View) -> {integer(), WinX::float(), WinY::float(), WinZ::float()}quadricDrawStyle(Quad, Draw) -> okquadricNormals(Quad, Normal) -> okquadricOrientation(Quad, Orientation) -> okquadricTexture(Quad, Texture) -> okscaleImage(Format, WIn, HIn, TypeIn, DataIn, WOut, HOut, TypeOut, DataOut) -> integer()sphere(Quad, Radius, Slices, Stacks) -> okunProject(WinX, WinY, WinZ, Model, Proj, View) -> {integer(), ObjX::float(), ObjY::float(), ObjZ::float()}unProject4(WinX, WinY, WinZ, ClipW, Model, Proj, View, NearVal, FarVal) -> {integer(), ObjX::float(), ObjY::float(), ObjZ::float(), ObjW::float()}"
  ],
  [
    "heart",
    "set_cmd(Cmd) -> ok | {error, {bad_cmd, Cmd}}clear_cmd() -> okget_cmd() -> {ok, Cmd}set_callback(Module, Function) -> ok | {error, {bad_callback, {Module, Function}}}clear_callback() -> okget_callback() -> {ok, {Module, Function}} | noneset_options(Options) -> ok | {error, {bad_options, Options}}get_options() -> {ok, Options} | none"
  ],
  ["HiPE_app"],
  [
    "http_uri",
    "decode(HexEncodedURI) -> URIencode(URI) -> HexEncodedURIparse(URI) -> {ok, Result} | {error, Reason}parse(URI, Options) -> {ok, Result} | {error, Reason}scheme_defaults() -> SchemeDefaults"
  ],
  [
    "httpc",
    "cancel_request(RequestId) ->cancel_request(RequestId, Profile) -> okcookie_header(Url) -> cookie_header(Url, Profile | Opts) -> header() | {error, Reason}cookie_header(Url, Opts, Profile) -> header() | {error, Reason}get_options(OptionItems) -> {ok, Values} | {error, Reason}get_options(OptionItems, Profile) -> {ok, Values} | {error, Reason}info() -> list()info(Profile) -> list()reset_cookies() -> void()reset_cookies(Profile) -> void()request(Url) -> request(Url, Profile) -> {ok, Result} | {error, Reason}request(Method, Request, HTTPOptions, Options) ->request(Method, Request, HTTPOptions, Options, Profile) -> {ok, Result} | {ok, saved_to_file} | {error, Reason}set_options(Options) -> set_options(Options, Profile) -> ok | {error, Reason}store_cookies(SetCookieHeaders, Url) -> store_cookies(SetCookieHeaders, Url, Profile) -> ok | {error, Reason}stream_next(Pid) -> okwhich_cookies() -> cookies()which_cookies(Profile) -> cookies()which_sessions() -> session_info()which_sessions(Profile) -> session_info()"
  ],
  [
    "httpd",
    "info(Pid) ->info(Pid, Properties) -> [{Option, Value}]info(Address, Port) -> info(Address, Port, Profile) -> info(Address, Port, Profile, Properties) -> [{Option, Value}] info(Address, Port, Properties) -> [{Option, Value}] reload_config(Config, Mode) -> ok | {error, Reason}Module:do(ModData)-> {proceed, OldData} | {proceed, NewData} | {break, NewData} | doneModule:load(Line, AccIn)-> eof | ok | {ok, AccOut} | {ok, AccOut, {Option, Value}} | {ok, AccOut, [{Option, Value}]} | {error, Reason}Module:remove(ConfigDB) -> ok | {error, Reason} Module:store({Option, Value}, Config)-> {ok, {Option, NewValue}} | {error, Reason}parse_query(QueryString) -> [{Key,Value}]"
  ],
  [
    "httpd_custom_api",
    "response_default_headers() -> [Header] response_header({HeaderName, HeaderValue}) -> {true, Header} | false request_header({HeaderName, HeaderValue}) -> {true, Header} | false "
  ],
  [
    "httpd_socket",
    "deliver(SocketType, Socket, Data) -> Resultpeername(SocketType,Socket) -> {Port,IPAddress}resolve() -> HostName"
  ],
  [
    "httpd_util",
    "convert_request_date(DateString) -> ErlDate|bad_datecreate_etag(FileInfo) -> Etagday(NthDayOfWeek) -> DayOfWeekdecode_hex(HexValue) -> DecValueflatlength(NestedList) -> Sizehexlist_to_integer(HexString) -> Numberinteger_to_hexlist(Number) -> HexStringlookup(ETSTable,Key) -> Resultlookup(ETSTable,Key,Undefined) -> Resultlookup_mime(ConfigDB,Suffix)lookup_mime(ConfigDB,Suffix,Undefined) -> MimeTypelookup_mime_default(ConfigDB,Suffix)lookup_mime_default(ConfigDB,Suffix,Undefined) -> MimeTypemessage(StatusCode,PhraseArgs,ConfigDB) -> Messagemonth(NthMonth) -> Monthmulti_lookup(ETSTable,Key) -> Resultreason_phrase(StatusCode) -> Descriptionrfc1123_date() -> RFC1123Daterfc1123_date(Date) -> RFC1123Datesplit(String,RegExp,N) -> SplitRessplit_script_path(RequestLine) -> Splittedsplit_path(RequestLine) -> {Path,QueryStringOrPathInfo}strip(String) -> Strippedsuffix(FileName) -> Suffix"
  ],
  [
    "i",
    "im() -> pid()ii(AbsModules) -> okii(AbsModule) -> {module, Module} | errorini(AbsModules) -> okini(AbsModule) -> {module, Module} | erroriq(AbsModule) -> okinq(AbsModule) -> okil() -> okip() -> okic() -> okiaa(Flags) -> trueiaa(Flags, Function) -> trueist(Flag) -> trueia(Pid) -> ok | no_procia(X,Y,Z) -> ok | no_procia(Pid, Function) -> ok | no_procia(X,Y,Z, Function) -> ok | no_procib(Module, Line) -> ok | {error, break_exists}ib(Module, Name, Arity) -> ok | {error, function_not_found} ir() -> okir(Module) -> okir(Module, Line) -> okir(Module, Name, Arity) -> ok | {error, function_not_found} ibd(Module, Line) -> okibe(Module, Line) -> okiba(Module, Line, Action) -> okibc(Module, Line, Function) -> okipb() -> okipb(Module) -> okiv() -> atom()help() -> ok"
  ],
  [
    "igor",
    "create_stubs(Stubs::[stubDescriptor()], Options::[term()]) -> [string()]merge(Name::atom(), Files::[filename()]) -> [filename()]merge(Name::atom(), Files::[filename()], Options::[term()]) -> [filename()]merge_files(Name::atom(), Files::[filename()], Options::[term()]) -> {syntaxTree(), [stubDescriptor()]}merge_files(Name::atom(), Sources::[Forms], Files::[filename()], Options::[term()]) -> {syntaxTree(), [stubDescriptor()]}merge_sources(Name::atom(), Sources::[Forms], Options::[term()]) -> {syntaxTree(), [stubDescriptor()]}parse_transform(Forms::[syntaxTree()], Options::[term()]) -> [syntaxTree()]rename(Files::[filename()], Renamings) -> [string()]rename(Files::[filename()], Renamings, Options::[term()]) -> [string()]"
  ],
  [
    "inet",
    "close(Socket) -> okformat_error(Reason) -> string()get_rc() -> [{Par :: atom(), Val :: any()} | {Par :: atom(), Val1 :: any(), Val2 :: any()}]getaddr(Host, Family) -> {ok, Address} | {error, posix()}getaddrs(Host, Family) -> {ok, Addresses} | {error, posix()}gethostbyaddr(Address) -> {ok, Hostent} | {error, posix()}gethostbyname(Hostname) -> {ok, Hostent} | {error, posix()}gethostbyname(Hostname, Family) -> {ok, Hostent} | {error, posix()}gethostname() -> {ok, Hostname}getifaddrs() -> {ok, [{Ifname :: string(), Ifopts :: getifaddrs_ifopts()}]} | {error, posix()}getopts(Socket, Options) -> {ok, OptionValues} | {error, posix()}getstat(Socket) -> {ok, OptionValues} | {error, posix()}getstat(Socket, Options) -> {ok, OptionValues} | {error, posix()}i() -> oki(Proto :: socket_protocol()) -> oki(X1 :: socket_protocol(), Fs :: [atom()]) -> okntoa(IpAddress) -> Address | {error, einval}parse_address(Address) -> {ok, IPAddress} | {error, einval}parse_ipv4_address(Address) -> {ok, IPv4Address} | {error, einval}parse_ipv4strict_address(Address) -> {ok, IPv4Address} | {error, einval}parse_ipv6_address(Address) -> {ok, IPv6Address} | {error, einval}parse_ipv6strict_address(Address) -> {ok, IPv6Address} | {error, einval}ipv4_mapped_ipv6_address(X1 :: ip_address()) -> ip_address() parse_strict_address(Address) -> {ok, IPAddress} | {error, einval}peername(Socket :: socket()) -> {ok, {ip_address(), port_number()} | returned_non_ip_address()} | {error, posix()}peernames(Socket :: socket()) -> {ok, [{ip_address(), port_number()} | returned_non_ip_address()]} | {error, posix()}peernames(Socket, Assoc) -> {ok, [{Address, Port}]} | {error, posix()}port(Socket) -> {ok, Port} | {error, any()}setopts(Socket, Options) -> ok | {error, posix()}sockname(Socket :: socket()) -> {ok, {ip_address(), port_number()} | returned_non_ip_address()} | {error, posix()}socknames(Socket :: socket()) -> {ok, [{ip_address(), port_number()} | returned_non_ip_address()]} | {error, posix()}socknames(Socket, Assoc) -> {ok, [{Address, Port}]} | {error, posix()}",
    "getifaddrs(Opts) -> {ok, [{Ifname, Ifopts}]} | {error, Posix} "
  ],
  [
    "inet_res",
    "getbyname(Name, Type) -> {ok, Hostent} | {error, Reason}getbyname(Name, Type, Timeout) -> {ok, Hostent} | {error, Reason}gethostbyaddr(Address) -> {ok, Hostent} | {error, Reason}gethostbyaddr(Address, Timeout) -> {ok, Hostent} | {error, Reason}gethostbyname(Name) -> {ok, Hostent} | {error, Reason}gethostbyname(Name, Family) -> {ok, Hostent} | {error, Reason}gethostbyname(Name, Family, Timeout) -> {ok, Hostent} | {error, Reason}lookup(Name, Class, Type) -> [dns_data()]lookup(Name, Class, Type, Opts) -> [dns_data()]lookup(Name, Class, Type, Opts, Timeout) -> [dns_data()]resolve(Name, Class, Type) -> {ok, dns_msg()} | Errorresolve(Name, Class, Type, Opts) -> {ok, dns_msg()} | Errorresolve(Name, Class, Type, Opts, Timeout) -> {ok, dns_msg()} | Errornslookup(Name, Class, Type) -> {ok, dns_msg()} | {error, Reason}nslookup(Name, Class, Type, Timeout) -> {ok, dns_msg()} | {error, Reason}nslookup(Name, Class, Type, Nameservers) -> {ok, dns_msg()} | {error, Reason}nnslookup(Name, Class, Type, Nameservers) -> {ok, dns_msg()} | {error, Reason}nnslookup(Name, Class, Type, Nameservers, Timeout) -> {ok, dns_msg()} | {error, Reason}"
  ],
  [
    "inets",
    "services() -> [{Service, Pid}]services_info() -> [{Service, Pid, Info}]service_names() -> [Service] start() -> start(Type) -> ok | {error, Reason}start(Service, ServiceConfig) -> {ok, Pid} | {error, Reason}start(Service, ServiceConfig, How) -> {ok, Pid} | {error, Reason}stop() -> ok stop(Service, Reference) -> ok | {error, Reason} "
  ],
  [
    "init",
    "boot(BootArgs) -> no_return()get_argument(Flag) -> {ok, Arg} | errorget_arguments() -> Flagsget_plain_arguments() -> [Arg]get_status() -> {InternalStatus, ProvidedStatus}reboot() -> okrestart() -> okscript_id() -> Idstop() -> okstop(Status) -> ok"
  ],
  [
    "init",
    "boot(BootArgs) -> no_return()get_argument(Flag) -> {ok, Arg} | errorget_arguments() -> Flagsget_plain_arguments() -> [Arg]get_status() -> {InternalStatus, ProvidedStatus}reboot() -> okrestart() -> okscript_id() -> Idstop() -> okstop(Status) -> ok"
  ],
  [
    "instrument",
    "allocations() -> {ok, Result} | {error, Reason}allocations(Options) -> {ok, Result} | {error, Reason}carriers() -> {ok, Result} | {error, Reason}carriers(Options) -> {ok, Result} | {error, Reason}"
  ],
  [
    "int",
    "i(AbsModule) -> {module,Module} | errori(AbsModules) -> okni(AbsModule) -> {module,Module} | errorni(AbsModules) -> okn(AbsModule) -> oknn(AbsModule) -> okinterpreted() -> [Module]file(Module) -> File | {error,not_loaded}interpretable(AbsModule) -> true | {error,Reason}auto_attach() -> false | {Flags,Function}auto_attach(false)auto_attach(Flags, Function)stack_trace() -> Flagstack_trace(Flag)break(Module, Line) -> ok | {error,break_exists}delete_break(Module, Line) -> okbreak_in(Module, Name, Arity) -> ok | {error,function_not_found}del_break_in(Module, Name, Arity) -> ok | {error,function_not_found}no_break() -> okno_break(Module) -> okdisable_break(Module, Line) -> okenable_break(Module, Line) -> okaction_at_break(Module, Line, Action) -> oktest_at_break(Module, Line, Function) -> okget_binding(Var, Bindings) -> {value,Value} | unboundall_breaks() -> [Break]all_breaks(Module) -> [Break]snapshot() -> [Snapshot]clear() -> okcontinue(Pid) -> ok | {error,not_interpreted}continue(X,Y,Z) -> ok | {error,not_interpreted}"
  ],
  [
    "io",
    "columns() -> {ok, integer() >= 1} | {error, enotsup}columns(IoDevice) -> {ok, integer() >= 1} | {error, enotsup}format(Format) -> okformat(Format, Data) -> okformat(IoDevice, Format, Data) -> okfwrite(Format) -> okfwrite(Format, Data) -> okfwrite(IoDevice, Format, Data) -> okfread(Prompt, Format) -> Resultfread(IoDevice, Prompt, Format) -> Resultget_chars(Prompt, Count) -> Data | server_no_data() get_chars(IoDevice, Prompt, Count) -> Data | server_no_data() get_line(Prompt) -> Data | server_no_data() get_line(IoDevice, Prompt) -> Data | server_no_data() getopts() -> [opt_pair()] | {error, Reason}getopts(IoDevice) -> [opt_pair()] | {error, Reason}nl() -> oknl(IoDevice) -> okparse_erl_exprs(Prompt) -> Resultparse_erl_exprs(IoDevice, Prompt) -> Resultparse_erl_exprs(IoDevice, Prompt, StartLocation) -> Resultparse_erl_exprs(IoDevice, Prompt, StartLocation, Options) -> Resultparse_erl_form(Prompt) -> Resultparse_erl_form(IoDevice, Prompt) -> Resultparse_erl_form(IoDevice, Prompt, StartLocation) -> Resultparse_erl_form(IoDevice, Prompt, StartLocation, Options) -> Resultprintable_range() -> unicode | latin1put_chars(CharData) -> okput_chars(IoDevice, CharData) -> okread(Prompt) -> Resultread(IoDevice, Prompt) -> Resultread(IoDevice, Prompt, StartLocation) -> Resultread(IoDevice, Prompt, StartLocation, Options) -> Resultrows() -> {ok, integer() >= 1} | {error, enotsup}rows(IoDevice) -> {ok, integer() >= 1} | {error, enotsup}scan_erl_exprs(Prompt) -> Resultscan_erl_exprs(Device, Prompt) -> Resultscan_erl_exprs(Device, Prompt, StartLocation) -> Resultscan_erl_exprs(Device, Prompt, StartLocation, Options) -> Resultscan_erl_form(Prompt) -> Resultscan_erl_form(IoDevice, Prompt) -> Resultscan_erl_form(IoDevice, Prompt, StartLocation) -> Resultscan_erl_form(IoDevice, Prompt, StartLocation, Options) -> Resultsetopts(Opts) -> ok | {error, Reason}setopts(IoDevice, Opts) -> ok | {error, Reason}write(Term) -> okwrite(IoDevice, Term) -> ok"
  ],
  [
    "io_lib",
    "build_text(FormatList) -> chars() char_list(Term) -> boolean()deep_char_list(Term) -> boolean()deep_latin1_char_list(Term) -> boolean()format(Format, Data) -> chars() fwrite(Format, Data) -> chars() format(Format, Data, Options) -> chars() fwrite(Format, Data, Options) -> chars() fread(Format, String) -> Resultfread(Continuation, CharSpec, Format) -> Returnindentation(String, StartIndent) -> integer()latin1_char_list(Term) -> boolean()nl() -> string()print(Term) -> chars() print(Term, Column, LineLength, Depth) -> chars() printable_latin1_list(Term) -> boolean()printable_list(Term) -> boolean()printable_unicode_list(Term) -> boolean()scan_format(Format, Data) -> FormatListunscan_format(FormatList) -> {Format, Data}write(Term) -> chars() write(Term, Depth) -> chars() write(Term, Options) -> chars() write_atom(Atom) -> chars() write_atom_as_latin1(Atom) -> latin1_string() write_char(Char) -> chars() write_char_as_latin1(Char) -> latin1_string() write_latin1_char(Latin1Char) -> latin1_string() write_latin1_string(Latin1String) -> latin1_string() write_string(String) -> chars() write_string_as_latin1(String) -> latin1_string()"
  ],
  ["jinterface"],
  ["kernel_app"],
  [
    "lcnt",
    "start() -> {ok, Pid} | {error, {already_started, Pid}} stop() -> okcollect() -> okcollect(Node) -> okclear() -> okclear(Node) -> okconflicts() -> okconflicts([Option]) -> oklocations() -> oklocations([Option]) -> okinspect(Lock) -> okinspect(Lock, [Option]) -> okinformation() -> okswap_pid_keys() -> okload(Filename) -> oksave(Filename) -> okapply(Fun) -> term()apply(Fun, Args) -> term()apply(Module, Function, Args) -> term()pid(Id, Serial) -> pid()pid(Node, Id, Serial) -> pid()port(Id) -> port()port(Node, Id) -> port()rt_collect() -> [lock_counter_data()]rt_collect(Node) -> [lock_counter_data()]rt_clear() -> okrt_clear(Node) -> okrt_mask() -> [category_atom()]rt_mask(Node) -> [category_atom()]rt_mask(Categories) -> ok | {error, copy_save_enabled}rt_mask(Node, Categories) -> ok | {error, copy_save_enabled}rt_opt({Type, bool()}) -> bool()rt_opt(Node, {Type, bool()}) -> bool()"
  ],
  [
    "leex",
    "file(FileName) -> LeexRetfile(FileName, Options) -> LeexRetformat_error(ErrorInfo) -> Charsstring(String) -> StringRetstring(String, StartLine) -> StringRettoken(Cont, Chars) -> {more,Cont1} | {done,TokenRet,RestChars} token(Cont, Chars, StartLine) -> {more,Cont1} | {done,TokenRet,RestChars} tokens(Cont, Chars) -> {more,Cont1} | {done,TokensRet,RestChars} tokens(Cont, Chars, StartLine) -> {more,Cont1} | {done,TokensRet,RestChars} "
  ],
  [
    "lists",
    "all(Pred, List) -> boolean()any(Pred, List) -> boolean()append(ListOfLists) -> List1append(List1, List2) -> List3concat(Things) -> string()delete(Elem, List1) -> List2droplast(List) -> InitListdropwhile(Pred, List1) -> List2duplicate(N, Elem) -> Listfilter(Pred, List1) -> List2filtermap(Fun, List1) -> List2flatlength(DeepList) -> integer() >= 0flatmap(Fun, List1) -> List2flatten(DeepList) -> Listflatten(DeepList, Tail) -> Listfoldl(Fun, Acc0, List) -> Acc1foldr(Fun, Acc0, List) -> Acc1join(Sep, List1) -> List2foreach(Fun, List) -> okkeydelete(Key, N, TupleList1) -> TupleList2keyfind(Key, N, TupleList) -> Tuple | falsekeymap(Fun, N, TupleList1) -> TupleList2keymember(Key, N, TupleList) -> boolean()keymerge(N, TupleList1, TupleList2) -> TupleList3keyreplace(Key, N, TupleList1, NewTuple) -> TupleList2keysearch(Key, N, TupleList) -> {value, Tuple} | falsekeysort(N, TupleList1) -> TupleList2keystore(Key, N, TupleList1, NewTuple) -> TupleList2keytake(Key, N, TupleList1) -> {value, Tuple, TupleList2} | falselast(List) -> Lastmap(Fun, List1) -> List2mapfoldl(Fun, Acc0, List1) -> {List2, Acc1}mapfoldr(Fun, Acc0, List1) -> {List2, Acc1}max(List) -> Maxmember(Elem, List) -> boolean()merge(ListOfLists) -> List1merge(List1, List2) -> List3merge(Fun, List1, List2) -> List3merge3(List1, List2, List3) -> List4min(List) -> Minnth(N, List) -> Elemnthtail(N, List) -> Tailpartition(Pred, List) -> {Satisfying, NotSatisfying}prefix(List1, List2) -> boolean()reverse(List1) -> List2reverse(List1, Tail) -> List2search(Pred, List) -> {value, Value} | falseseq(From, To) -> Seqseq(From, To, Incr) -> Seqsort(List1) -> List2sort(Fun, List1) -> List2split(N, List1) -> {List2, List3}splitwith(Pred, List) -> {List1, List2}sublist(List1, Len) -> List2sublist(List1, Start, Len) -> List2subtract(List1, List2) -> List3suffix(List1, List2) -> boolean()sum(List) -> number()takewhile(Pred, List1) -> List2ukeymerge(N, TupleList1, TupleList2) -> TupleList3ukeysort(N, TupleList1) -> TupleList2umerge(ListOfLists) -> List1umerge(List1, List2) -> List3umerge(Fun, List1, List2) -> List3umerge3(List1, List2, List3) -> List4unzip(List1) -> {List2, List3}unzip3(List1) -> {List2, List3, List4}usort(List1) -> List2usort(Fun, List1) -> List2zip(List1, List2) -> List3zip3(List1, List2, List3) -> List4zipwith(Combine, List1, List2) -> List3zipwith3(Combine, List1, List2, List3) -> List4"
  ],
  [
    "log_mf_h",
    "init(Dir, MaxBytes, MaxFiles) -> Argsinit(Dir, MaxBytes, MaxFiles, Pred) -> Args"
  ],
  [
    "logger",
    "log(Level, StringOrReport) -> oklog(Level, StringOrReport, Metadata) -> oklog(Level, Format, Args) -> oklog(Level, Fun, FunArgs) -> oklog(Level, Format, Args, Metadata) -> oklog(Level, Fun, FunArgs, Metadata) -> okadd_handler(HandlerId, Module, Config) -> ok | {error, term()}add_handler_filter(HandlerId, FilterId, Filter) -> ok | {error, term()}add_handlers(Application) -> ok | {error, term()}add_handlers(HandlerConfig) -> ok | {error, term()}add_primary_filter(FilterId, Filter) -> ok | {error, term()}get_config() -> #{primary => primary_config(), handlers => [handler_config()], proxy => olp_config(), module_levels => [{module(), level() | all | none}]}get_handler_config() -> [Config]get_handler_config(HandlerId) -> {ok, Config} | {error, term()}get_handler_ids() -> [HandlerId]get_primary_config() -> Configget_proxy_config() -> Configget_module_level() -> [{Module, Level}]get_module_level(Modules) -> [{Module, Level}]get_process_metadata() -> Meta | undefinedi() -> oki(What) -> okremove_handler(HandlerId) -> ok | {error, term()}remove_handler_filter(HandlerId, FilterId) -> ok | {error, term()}remove_primary_filter(FilterId) -> ok | {error, term()}set_application_level(Application, Level) -> ok | {error, not_loaded}set_handler_config(HandlerId, Config) -> ok | {error, term()}set_handler_config(HandlerId, Key :: level, Level) -> Returnset_handler_config(HandlerId, Key :: filter_default, FilterDefault) -> Returnset_handler_config(HandlerId, Key :: filters, Filters) -> Returnset_handler_config(HandlerId, Key :: formatter, Formatter) -> Returnset_handler_config(HandlerId, Key :: config, Config) -> Returnset_primary_config(Config) -> ok | {error, term()}set_primary_config(Key :: level, Level) -> ok | {error, term()}set_primary_config(Key :: filter_default, FilterDefault) -> ok | {error, term()}set_primary_config(Key :: filters, Filters) -> ok | {error, term()}set_proxy_config(Config) -> ok | {error, term()}set_module_level(Modules, Level) -> ok | {error, term()}set_process_metadata(Meta) -> okunset_application_level(Application) -> ok | {error, not_loaded}unset_module_level() -> okunset_module_level(Modules) -> okunset_process_metadata() -> okupdate_formatter_config(HandlerId, FormatterConfig) -> ok | {error, term()}update_formatter_config(HandlerId, Key, Value) -> ok | {error, term()}update_handler_config(HandlerId, Config) -> ok | {error, term()}update_handler_config(HandlerId, Key :: level, Level) -> Returnupdate_handler_config(HandlerId, Key :: filter_default, FilterDefault) -> Returnupdate_handler_config(HandlerId, Key :: filters, Filters) -> Returnupdate_handler_config(HandlerId, Key :: formatter, Formatter) -> Returnupdate_handler_config(HandlerId, Key :: config, Config) -> Returnupdate_primary_config(Config) -> ok | {error, term()}update_process_metadata(Meta) -> okupdate_proxy_config(Config) -> ok | {error, term()}compare_levels(Level1, Level2) -> eq | gt | ltformat_report(Report) -> FormatArgstimestamp() -> timestamp()",
    "emergency(StringOrReport[,Metadata])emergency(Format,Args[,Metadata])emergency(Fun,FunArgs[,Metadata])alert(StringOrReport[,Metadata])alert(Format,Args[,Metadata])alert(Fun,FunArgs[,Metadata])critical(StringOrReport[,Metadata])critical(Format,Args[,Metadata])critical(Fun,FunArgs[,Metadata])error(StringOrReport[,Metadata])error(Format,Args[,Metadata])error(Fun,FunArgs[,Metadata])warning(StringOrReport[,Metadata])warning(Format,Args[,Metadata])warning(Fun,FunArgs[,Metadata])notice(StringOrReport[,Metadata])notice(Format,Args[,Metadata])notice(Fun,FunArgs[,Metadata])info(StringOrReport[,Metadata])info(Format,Args[,Metadata])info(Fun,FunArgs[,Metadata])debug(StringOrReport[,Metadata])debug(Format,Args[,Metadata])debug(Fun,FunArgs[,Metadata])HModule:adding_handler(Config1) -> {ok, Config2} | {error, Reason}HModule:changing_config(SetOrUpdate, OldConfig, NewConfig) -> {ok, Config} | {error, Reason}HModule:filter_config(Config) -> FilteredConfigHModule:log(LogEvent, Config) -> void()HModule:removing_handler(Config) -> okFModule:check_config(FConfig) -> ok | {error, Reason}FModule:format(LogEvent, FConfig) -> FormattedLogEntry"
  ],
  ["logger_disk_log_h", "filesync(Name) -> ok | {error, Reason}"],
  [
    "logger_filters",
    "domain(LogEvent, Extra) -> logger:filter_return() level(LogEvent, Extra) -> logger:filter_return() progress(LogEvent, Extra) -> logger:filter_return() remote_gl(LogEvent, Extra) -> logger:filter_return()"
  ],
  [
    "logger_formatter",
    "check_config(Config) -> ok | {error, term()}format(LogEvent, Config) -> unicode:chardata()"
  ],
  ["logger_std_h", "filesync(Name) -> ok | {error, Reason}"],
  [
    "make",
    "all() -> up_to_date | errorall(Options) -> up_to_date | errorfiles(ModFiles) -> up_to_date | errorfiles(ModFiles, Options) -> up_to_date | error"
  ],
  [
    "maps",
    "filter(Pred, MapOrIter) -> Mapfind(Key, Map) -> {ok, Value} | errorfold(Fun, Init, MapOrIter) -> Accfrom_list(List) -> Mapget(Key, Map) -> Valueget(Key, Map, Default) -> Value | Defaultis_key(Key, Map) -> boolean()iterator(Map) -> Iteratorkeys(Map) -> Keysmap(Fun, MapOrIter) -> Mapmerge(Map1, Map2) -> Map3new() -> Mapnext(Iterator) -> {Key, Value, NextIterator} | noneput(Key, Value, Map1) -> Map2remove(Key, Map1) -> Map2size(Map) -> integer() >= 0take(Key, Map1) -> {Value, Map2} | errorto_list(Map) -> [{Key, Value}]update(Key, Value, Map1) -> Map2update_with(Key, Fun, Map1) -> Map2update_with(Key, Fun, Init, Map1) -> Map2values(Map) -> Valueswith(Ks, Map1) -> Map2without(Ks, Map1) -> Map2"
  ],
  [
    "math",
    "acos(X) -> float()acosh(X) -> float()asin(X) -> float()asinh(X) -> float()atan(X) -> float()atan2(Y, X) -> float()atanh(X) -> float()ceil(X) -> float()cos(X) -> float()cosh(X) -> float()exp(X) -> float()floor(X) -> float()fmod(X, Y) -> float()log(X) -> float()log10(X) -> float()log2(X) -> float()pow(X, Y) -> float()sin(X) -> float()sinh(X) -> float()sqrt(X) -> float()tan(X) -> float()tanh(X) -> float()erf(X) -> float()erfc(X) -> float()pi() -> float()"
  ],
  [
    "megaco",
    "start() -> ok | {error, Reason}stop() -> ok | {error, Reason}start_user(UserMid, Config) -> ok | {error, Reason}stop_user(UserMid) -> ok | {error, Reason}user_info(UserMid) -> [{Item, Value}]user_info(UserMid, Item) -> Value | exit(Reason)update_user_info(UserMid, Item, Value) -> ok | {error, Reason}conn_info(ConnHandle) -> [{Item, Value}]conn_info(ConnHandle, Item) -> Value | exit(Reason)update_conn_info(ConnHandle, Item, Value) -> ok | {error, Reason}system_info() -> [{Item, Value}] | exit(Reason)system_info(Item) -> Value | exit(Reason)info() -> Infoconnect(ReceiveHandle, RemoteMid, SendHandle, ControlPid) -> {ok, ConnHandle} | {error, Reason}connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid, Extra) -> {ok, ConnHandle} | {error, Reason}disconnect(ConnHandle, DiscoReason) -> ok | {error, ErrReason}call(ConnHandle, Actions, Options) -> {ProtocolVersion, UserReply}cast(ConnHandle, Actions, Options) -> ok | {error, Reason}encode_actions(ConnHandle, Actions, Options) -> {ok, BinOrBins} | {error, Reason}token_tag2string(Tag) -> Resulttoken_tag2string(Tag, EncoderMod) -> Resulttoken_tag2string(Tag, EncoderMod, Version) -> Resultcancel(ConnHandle, CancelReason) -> ok | {error, ErrReason}process_received_message(ReceiveHandle, ControlPid, SendHandle, BinMsg) -> okprocess_received_message(ReceiveHandle, ControlPid, SendHandle, BinMsg, Extra) -> okreceive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg) -> okreceive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg, Extra) -> okparse_digit_map(DigitMapBody) -> {ok, ParsedDigitMap} | {error, Reason}eval_digit_map(DigitMap) -> {ok, MatchResult} | {error, Reason}eval_digit_map(DigitMap, Timers) -> {ok, MatchResult} | {error, Reason}report_digit_event(DigitMapEvalPid, Events) -> ok | {error, Reason}test_digit_event(DigitMap, Events) -> {ok, Kind, Letters} | {error, Reason}encode_sdp(SDP) -> {ok, PP} | {error, Reason}decode_sdp(PP) -> {ok, SDP} | {error, Reason}get_sdp_record_from_PropertGroup(Type, PG) -> [sdp()]versions1() -> {ok, VersionInfo} | {error, Reason}versions2() -> {ok, Info} | {error, Reason}print_version_info() -> void()print_version_info(VersionInfo) -> void()enable_trace(Level, Destination) -> void()disable_trace() -> void()set_trace(Level) -> void()get_stats() -> {ok, TotalStats} | {error, Reason}get_stats(GlobalCounter) -> {ok, CounterStats} | {error, Reason}get_stats(ConnHandle) -> {ok, ConnHandleStats} | {error, Reason}get_stats(ConnHandle, Counter) -> {ok, integer()} | {error, Reason}reset_stats() -> void()reset_stats(ConnHandle) -> void()test_request(ConnHandle, Version, EncodingMod, EncodingConfig, Actions) -> {MegaMsg, EncodeRes}test_reply(ConnHandle, Version, EncodingMod, EncodingConfig, Reply) -> {MegaMsg, EncodeRes}"
  ],
  ["megaco_codec_meas", "start() -> void()start(MessagePackage) -> void()"],
  [
    "megaco_codec_mstone1",
    "start() -> void()start(MessagePackage) -> void()start(MessagePackage, Factor) -> void()start_flex() -> void()start_flex(MessagePackage) -> void()start_flex(MessagePackage, Factor) -> void()start_only_drv() -> void()start_only_drv(MessagePackage) -> void()start_only_drv(MessagePackage, Factor) -> void()start_no_drv() -> void()start_no_drv(MessagePackage) -> void()start_no_drv(MessagePackage, Factor) -> void()"
  ],
  ["megaco_codec_mstone2", "start() -> void()start(MessagePackage) -> void()"],
  [
    "megaco_codec_transform",
    "export_messages() -> void()export_messages(MessagePackage) -> void()"
  ],
  [
    "megaco_edist_compress",
    "Module:encode(R, Version) -> TModule:decode(T, Version) -> R"
  ],
  [
    "megaco_encoder",
    "Module:encode_message(EncodingConfig, Version, Message) -> {ok, Bin} | ErrorModule:decode_message(EncodingConfig, Version, Bin) -> {ok, Message} | ErrorModule:decode_mini_message(EncodingConfig, Version, Bin) -> {ok, Message} | ErrorModule:encode_transaction(EncodingConfig, Version, Transaction) -> OK | ErrorModule:encode_action_requests(EncodingConfig, Version, ARs) -> OK | ErrorModule:encode_action_reply(EncodingConfig, Version, AR) -> OK | Error"
  ],
  [
    "megaco_flex_scanner",
    "start() -> {ok, PortOrPorts} | {error, Reason}stop(PortOrPorts) -> stoppedis_reentrant_enabled() -> Booleanis_scanner_port(Port, PortOrPorts) -> Booleanscan(Binary, PortOrPorts) -> {ok, Tokens, Version, LatestLine} | {error, Reason, LatestLine} "
  ],
  [
    "megaco_tcp",
    "start_transport() -> {ok, TransportRef}listen(TransportRef, ListenPortSpecList) -> okconnect(TransportRef, OptionList) -> {ok, Handle, ControlPid} | {error, Reason}close(Handle) -> oksocket(Handle) -> Socketsend_message(Handle, Message) -> okblock(Handle) -> okunblock(Handle) -> okupgrade_receive_handle(ControlPid) -> okget_stats() -> {ok, TotalStats} | {error, Reason}get_stats(SendHandle) -> {ok, SendHandleStats} | {error, Reason}get_stats(SendHandle, Counter) -> {ok, CounterStats} | {error, Reason}reset_stats() -> void()reset_stats(SendHandle) -> void()"
  ],
  [
    "megaco_transport",
    "Module:send_message(Handle, Msg) -> ok | {cancel, Reason} | ErrorModule:send_message(Handle, Msg, Resend) -> ok | {cancel, Reason} | ErrorModule:resend_message(Handle, Msg) -> ok | {cancel, Reason} | Error"
  ],
  [
    "megaco_udp",
    "start_transport() -> {ok, TransportRef}open(TransportRef, OptionList) -> {ok, Handle, ControlPid} | {error, Reason}close(Handle, Msg) -> oksocket(Handle) -> Socketcreate_send_handle(Handle, Host, Port) -> send_handle()send_message(SendHandle, Msg) -> okblock(Handle) -> okunblock(Handle) -> okupgrade_receive_handle(ControlPid, NewHandle) -> okget_stats() -> {ok, TotalStats} | {error, Reason}get_stats(SendHandle) -> {ok, SendHandleStats} | {error, Reason}get_stats(SendHandle, Counter) -> {ok, CounterStats} | {error, Reason}reset_stats() -> void()reset_stats(SendHandle) -> void()"
  ],
  [
    "megaco_user",
    "handle_connect(ConnHandle, ProtocolVersion) -> ok | error | {error,ErrorDescr}handle_connect(ConnHandle, ProtocolVersion, Extra) -> ok | error | {error,ErrorDescr}handle_disconnect(ConnHandle, ProtocolVersion, Reason) -> okhandle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED) -> reply | {reply, ED} | no_reply | {no_reply, ED} handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED, Extra) -> reply | {reply, ED} | no_reply | {no_reply, ED} handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr) -> okhandle_message_error(ConnHandle, ProtocolVersion, ErrorDescr, Extra) -> okhandle_trans_request(ConnHandle, ProtocolVersion, ActionRequests) -> pending() | reply() | ignore_trans_requesthandle_trans_request(ConnHandle, ProtocolVersion, ActionRequests, Extra) -> pending() | reply() | ignore_trans_requesthandle_trans_long_request(ConnHandle, ProtocolVersion, ReqData) -> reply()handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData, Extra) -> reply()handle_trans_reply(ConnHandle, ProtocolVersion, UserReply, ReplyData) -> okhandle_trans_reply(ConnHandle, ProtocolVersion, UserReply, ReplyData, Extra) -> okhandle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData) -> okhandle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData, Extra) -> okhandle_unexpected_trans(ConnHandle, ProtocolVersion, Trans) -> okhandle_unexpected_trans(ConnHandle, ProtocolVersion, Trans, Extra) -> okhandle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo, Pid) -> okhandle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo, Pid, Extra) -> okhandle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo, SegCompl) -> okhandle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo, SegCompl, Extra) -> ok"
  ],
  [
    "memsup",
    "get_memory_data() -> {Total,Allocated,Worst}get_system_memory_data() -> MemDataListget_os_wordsize() -> Wordsizeget_check_interval() -> MSset_check_interval(Minutes) -> okget_procmem_high_watermark() -> int()set_procmem_high_watermark(Float) -> okget_sysmem_high_watermark() -> int()set_sysmem_high_watermark(Float) -> okget_helper_timeout() -> Secondsset_helper_timeout(Seconds) -> ok"
  ],
  [
    "merl",
    "alpha(Trees::pattern_or_patterns(), Env::[{id(), id()}]) -> template_or_templates()compile(Code) -> term()compile(Code, Options) -> term()compile_and_load(Code) -> term()compile_and_load(Code, Options) -> term()match(Patterns::pattern_or_patterns(), Trees::tree_or_trees()) -> {ok, env()} | errormeta_template(Templates::template_or_templates()) -> tree_or_trees()print(Ts) -> term()qquote(Text::text(), Env::env()) -> tree_or_trees()qquote(StartPos::location(), Text::text(), Env::env()) -> tree_or_trees()quote(Text::text()) -> tree_or_trees()quote(StartPos::location(), Text::text()) -> tree_or_trees()show(Ts) -> term()subst(Trees::pattern_or_patterns(), Env::env()) -> tree_or_trees()switch(Trees::tree_or_trees(), Cs::[switch_clause()]) -> any()template(Trees::pattern_or_patterns()) -> template_or_templates()template_vars(Template::template_or_templates()) -> [id()]term(Term::term()) -> tree()tree(Templates::template_or_templates()) -> tree_or_trees()tsubst(Trees::pattern_or_patterns(), Env::env()) -> template_or_templates()var(Name::atom()) -> tree()"
  ],
  ["merl_transform", "parse_transform(Forms, Options) -> term()"],
  [
    "mnesia",
    "abort(Reason) -> transaction abortactivate_checkpoint(Args) -> {ok,Name,Nodes} | {error,Reason}activity(AccessContext, Fun [, Args]) -> ResultOfFun | exit(Reason)activity(AccessContext, Fun, Args, AccessMod) -> ResultOfFun | exit(Reason)add_table_copy(Tab, Node, Type) -> {aborted, R} | {atomic, ok}add_table_index(Tab, AttrName) -> {aborted, R} | {atomic, ok}all_keys(Tab) -> KeyList | transaction abortasync_dirty(Fun, [, Args]) -> ResultOfFun | exit(Reason)backup(Opaque [, BackupMod]) -> ok | {error,Reason}backup_checkpoint(Name, Opaque [, BackupMod]) -> ok | {error,Reason}change_config(Config, Value) -> {error, Reason} | {ok, ReturnValue}change_table_access_mode(Tab, AccessMode) -> {aborted, R} | {atomic, ok}change_table_copy_type(Tab, Node, To) -> {aborted, R} | {atomic, ok}change_table_load_order(Tab, LoadOrder) -> {aborted, R} | {atomic, ok}change_table_majority(Tab, Majority) -> {aborted, R} | {atomic, ok}clear_table(Tab) -> {aborted, R} | {atomic, ok}create_schema(DiscNodes) -> ok | {error,Reason}create_table(Name, TabDef) -> {atomic, ok} | {aborted, Reason}deactivate_checkpoint(Name) -> ok | {error, Reason}del_table_copy(Tab, Node) -> {aborted, R} | {atomic, ok}del_table_index(Tab, AttrName) -> {aborted, R} | {atomic, ok}delete({Tab, Key}) -> transaction abort | okdelete(Tab, Key, LockKind) -> transaction abort | okdelete_object(Record) -> transaction abort | okdelete_object(Tab, Record, LockKind) -> transaction abort | okdelete_schema(DiscNodes) -> ok | {error,Reason}delete_table(Tab) -> {aborted, Reason} | {atomic, ok}dirty_all_keys(Tab) -> KeyList | exit({aborted, Reason})dirty_delete({Tab, Key}) -> ok | exit({aborted, Reason})dirty_delete(Tab, Key) -> ok | exit({aborted, Reason})dirty_delete_object(Record)dirty_delete_object(Tab, Record)dirty_first(Tab) -> Key | exit({aborted, Reason})dirty_index_match_object(Pattern, Pos)dirty_index_match_object(Tab, Pattern, Pos)dirty_index_read(Tab, SecondaryKey, Pos)dirty_last(Tab) -> Key | exit({aborted, Reason})dirty_match_object(Pattern) -> RecordList | exit({aborted, Reason})dirty_match_object(Tab, Pattern) -> RecordList | exit({aborted, Reason})dirty_next(Tab, Key) -> Key | exit({aborted, Reason})dirty_prev(Tab, Key) -> Key | exit({aborted, Reason})dirty_read({Tab, Key}) -> ValueList | exit({aborted, Reason}dirty_read(Tab, Key) -> ValueList | exit({aborted, Reason}dirty_select(Tab, MatchSpec) -> ValueList | exit({aborted, Reason}dirty_slot(Tab, Slot) -> RecordList | exit({aborted, Reason})dirty_update_counter({Tab, Key}, Incr) -> NewVal | exit({aborted, Reason})dirty_update_counter(Tab, Key, Incr) -> NewVal | exit({aborted, Reason})dirty_write(Record) -> ok | exit({aborted, Reason})dirty_write(Tab, Record) -> ok | exit({aborted, Reason})dump_log() -> dumpeddump_tables(TabList) -> {atomic, ok} | {aborted, Reason}dump_to_textfile(Filename)error_description(Error) -> Stringets(Fun, [, Args]) -> ResultOfFun | exit(Reason)first(Tab) -> Key | transaction abortfoldl(Function, Acc, Table) -> NewAcc | transaction abortfoldr(Function, Acc, Table) -> NewAcc | transaction abortforce_load_table(Tab) -> yes | ErrorDescriptionindex_match_object(Pattern, Pos) -> transaction abort | ObjListindex_match_object(Tab, Pattern, Pos, LockKind) -> transaction abort | ObjListindex_read(Tab, SecondaryKey, Pos) -> transaction abort | RecordListinfo() -> okinstall_fallback(Opaque) -> ok | {error,Reason}install_fallback(Opaque), BackupMod) -> ok | {error,Reason}install_fallback(Opaque, Args) -> ok | {error,Reason}is_transaction() -> booleanlast(Tab) -> Key | transaction abortload_textfile(Filename)lock(LockItem, LockKind) -> Nodes | ok | transaction abortmatch_object(Pattern) -> transaction abort | RecListmatch_object(Tab, Pattern, LockKind) -> transaction abort | RecListmove_table_copy(Tab, From, To) -> {aborted, Reason} | {atomic, ok}next(Tab, Key) -> Key | transaction abortprev(Tab, Key) -> Key | transaction abortread({Tab, Key}) -> transaction abort | RecordListread(Tab, Key) -> transaction abort | RecordListread(Tab, Key, LockKind) -> transaction abort | RecordListread_lock_table(Tab) -> ok | transaction abortreport_event(Event) -> okrestore(Opaque, Args) -> {atomic, RestoredTabs} |{aborted, Reason}s_delete({Tab, Key}) -> ok | transaction aborts_delete_object(Record) -> ok | transaction aborts_write(Record) -> ok | transaction abortschema() -> okschema(Tab) -> okselect(Tab, MatchSpec [, Lock]) -> transaction abort | [Object]select(Tab, MatchSpec, NObjects, Lock) -> transaction abort | {[Object],Cont} | '$end_of_table'select(Cont) -> transaction abort | {[Object],Cont} | '$end_of_table'set_debug_level(Level) -> OldLevelset_master_nodes(MasterNodes) -> ok | {error, Reason}set_master_nodes(Tab, MasterNodes) -> ok | {error, Reason}snmp_close_table(Tab) -> {aborted, R} | {atomic, ok}snmp_get_mnesia_key(Tab, RowIndex) -> {ok, Key} | undefinedsnmp_get_next_index(Tab, RowIndex) -> {ok, NextIndex} | endOfTablesnmp_get_row(Tab, RowIndex) -> {ok, Row} | undefinedsnmp_open_table(Tab, SnmpStruct) -> {aborted, R} | {atomic, ok}start() -> ok | {error, Reason}stop() -> stoppedsubscribe(EventCategory) -> {ok, Node} | {error, Reason}sync_dirty(Fun, [, Args]) -> ResultOfFun | exit(Reason)sync_log() -> ok | {error, Reason}sync_transaction(Fun, [[, Args], Retries]) -> {aborted, Reason} | {atomic, ResultOfFun}system_info(InfoKey) -> Info | exit({aborted, Reason})table(Tab [,[Option]]) -> QueryHandletable_info(Tab, InfoKey) -> Info | exit({aborted, Reason})transaction(Fun [[, Args], Retries]) -> {aborted, Reason} | {atomic, ResultOfFun}transform_table(Tab, Fun, NewAttributeList, NewRecordName) -> {aborted, R} | {atomic, ok}transform_table(Tab, Fun, NewAttributeList) -> {aborted, R} | {atomic, ok}traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc) -> {ok, LastAcc} | {error, Reason}uninstall_fallback() -> ok | {error,Reason}uninstall_fallback(Args) -> ok | {error,Reason}unsubscribe(EventCategory) -> {ok, Node} | {error, Reason}wait_for_tables(TabList, Timeout) -> ok | {timeout, BadTabList} | {error, Reason}wread({Tab, Key}) -> transaction abort | RecordListwrite(Record) -> transaction abort | okwrite(Tab, Record, LockKind) -> transaction abort | okwrite_lock_table(Tab) -> ok | transaction abort"
  ],
  [
    "mnesia_frag_hash",
    "init_state(Tab, State) -> NewState | abort(Reason)add_frag(State) -> {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)del_frag(State) -> {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)key_to_frag_number(State, Key) -> FragNum | abort(Reason)match_spec_to_frag_numbers(State, MatchSpec) -> FragNums | abort(Reason)"
  ],
  [
    "mnesia_registry",
    "create_table(Tab) -> ok | exit(Reason)create_table(Tab, TabDef) -> ok | exit(Reason)"
  ],
  [
    "mod_alias",
    "default_index(ConfigDB, Path) -> NewPathpath(PathData, ConfigDB, RequestURI) -> Pathreal_name(ConfigDB, RequestURI, Aliases) -> Retreal_script_name(ConfigDB, RequestURI, ScriptAliases) -> Ret"
  ],
  [
    "mod_auth",
    "add_group_member(GroupName, UserName, Options) -> true | {error, Reason}add_group_member(GroupName, UserName, Port, Dir) -> true | {error, Reason}add_group_member(GroupName, UserName, Address, Port, Dir) -> true | {error, Reason}add_user(UserName, Options) -> true| {error, Reason}add_user(UserName, Password, UserData, Port, Dir) -> true | {error, Reason}add_user(UserName, Password, UserData, Address, Port, Dir) -> true | {error, Reason}delete_group(GroupName, Options) -> true | {error,Reason} <name>delete_group(GroupName, Port, Dir) -> true | {error, Reason}delete_group(GroupName, Address, Port, Dir) -> true | {error, Reason}delete_group_member(GroupName, UserName, Options) -> true | {error, Reason}delete_group_member(GroupName, UserName, Port, Dir) -> true | {error, Reason}delete_group_member(GroupName, UserName, Address, Port, Dir) -> true | {error, Reason}delete_user(UserName,Options) -> true | {error, Reason}delete_user(UserName, Port, Dir) -> true | {error, Reason}delete_user(UserName, Address, Port, Dir) -> true | {error, Reason}get_user(UserName,Options) -> {ok, #httpd_user} |{error, Reason}get_user(UserName, Port, Dir) -> {ok, #httpd_user} | {error, Reason}get_user(UserName, Address, Port, Dir) -> {ok, #httpd_user} | {error, Reason}list_groups(Options) -> {ok, Groups} | {error, Reason}list_groups(Port, Dir) -> {ok, Groups} | {error, Reason}list_groups(Address, Port, Dir) -> {ok, Groups} | {error, Reason}list_group_members(GroupName, Options) -> {ok, Users} | {error, Reason}list_group_members(GroupName, Port, Dir) -> {ok, Users} | {error, Reason}list_group_members(GroupName, Address, Port, Dir) -> {ok, Users} | {error, Reason}list_users(Options) -> {ok, Users} | {error, Reason}list_users(Port, Dir) -> {ok, Users} | {error, Reason}list_users(Address, Port, Dir) -> {ok, Users} | {error, Reason}update_password(Port, Dir, OldPassword, NewPassword, NewPassword) -> ok | {error, Reason}update_password(Address,Port, Dir, OldPassword, NewPassword, NewPassword) -> ok | {error, Reason}"
  ],
  [
    "mod_esi",
    "deliver(SessionID, Data) -> ok | {error, Reason}Module:Function(SessionID, Env, Input)-> {continue, State} | _ Module:Function(Env, Input)-> Response "
  ],
  [
    "mod_security",
    "block_user(User, Port, Dir, Seconds) -> true | {error, Reason}block_user(User, Address, Port, Dir, Seconds) -> true | {error, Reason}list_auth_users(Port) -> Users | []list_auth_users(Address, Port) -> Users | []list_auth_users(Port, Dir) -> Users | []list_auth_users(Address, Port, Dir) -> Users | []list_blocked_users(Port) -> Users | []list_blocked_users(Address, Port) -> Users | []list_blocked_users(Port, Dir) -> Users | []list_blocked_users(Address, Port, Dir) -> Users | []unblock_user(User, Port) -> true | {error, Reason}unblock_user(User, Address, Port) -> true | {error, Reason}unblock_user(User, Port, Dir) -> true | {error, Reason}unblock_user(User, Address, Port, Dir) -> true | {error, Reason}Module:event(What, Port, Dir, Data) -> ignoredModule:event(What, Address, Port, Dir, Data) -> ignored"
  ],
  [
    "ms_transform",
    "format_error(Error) -> Charsparse_transform(Forms, Options) -> Forms2 | Errors | Warningstransform_from_shell(Dialect, Clauses, BoundEnvironment) -> term()"
  ],
  [
    "msacc",
    "available() -> boolean()start() -> boolean()start(Time) -> truestop() -> boolean()reset() -> boolean()print() -> okprint(DataOrStats) -> okprint(DataOrStats, Options) -> okprint(FileOrDevice, DataOrStats, Options) -> okstats() -> msacc_data() stats(Analysis, Stats) -> integer() >= 0stats(Analysis, Stats) -> msacc_stats() stats(Analysis, StatsOrData) -> msacc_data() | msacc_stats() to_file(Filename) -> ok | {error, file:posix()}from_file(Filename) -> msacc_data()"
  ],
  [
    "net",
    "gethostname() -> {ok, HostName} | {error, Reason}getnameinfo(SockAddr) -> {ok, Info} | {error, Reason}getnameinfo(SockAddr, Flags) -> {ok, Info} | {error, Reason}getaddrinfo(Host) -> {ok, Info} | {error, Reason}getaddrinfo(Host, Service :: undefined) -> {ok, Info} | {error, Reason}getaddrinfo(Host :: undefined, Service) -> {ok, Info} | {error, Reason}getaddrinfo(Host, Service) -> {ok, Info} | {error, Reason}getifaddrs() -> {ok, IfAddrs} | {error, Reason}getifaddrs(Filter) -> {ok, IfAddrs} | {error, Reason}getifaddrs(Namespace) -> {ok, IfAddrs} | {error, Reason}getifaddrs(Filter, Namespace) -> {ok, IfAddrs} | {error, Reason}if_name2index(Name) -> {ok, Idx} | {error, Reason}if_index2name(Idx) -> {ok, Name} | {error, Reason}if_names() -> Names | {error, Reason}"
  ],
  [
    "net_adm",
    "dns_hostname(Host) -> {ok, Name} | {error, Host}host_file() -> Hosts | {error, Reason}localhost() -> Namenames() -> {ok, [{Name, Port}]} | {error, Reason}names(Host) -> {ok, [{Name, Port}]} | {error, Reason}ping(Node) -> pong | pangworld() -> [node()]world(Arg) -> [node()]world_list(Hosts) -> [node()]world_list(Hosts, Arg) -> [node()]"
  ],
  [
    "net_kernel",
    "allow(Nodes) -> ok | errorconnect_node(Node) -> boolean() | ignoredget_net_ticktime() -> Resgetopts(Node, Options) -> {ok, OptionValues} | {error, Reason} | ignoredmonitor_nodes(Flag) -> ok | Errormonitor_nodes(Flag, Options) -> ok | Errorset_net_ticktime(NetTicktime) -> Resset_net_ticktime(NetTicktime, TransitionPeriod) -> Ressetopts(Node, Options) -> ok | {error, Reason} | ignoredstop() -> ok | {error, Reason}",
    "start([Name]) -> {ok, pid()} | {error, Reason}start([Name, NameType]) -> {ok, pid()} | {error, Reason}start([Name, NameType, Ticktime]) -> {ok, pid()} | {error, Reason}"
  ],
  [
    "nteventlog",
    "start(Identifier, MFA) -> Resultstart_link(Identifier, MFA) -> Resultstop() -> stopped"
  ],
  ["observer", "start() -> ok"],
  ["Observer_app"],
  [
    "odbc",
    "commit(Ref, CommitMode) ->commit(Ref, CommitMode, TimeOut) -> ok | {error, Reason} connect(ConnectStr, Options) -> {ok, Ref} | {error, Reason} disconnect(Ref) -> ok | {error, Reason} describe_table(Ref, Table) -> describe_table(Ref, Table, Timeout) -> {ok, Description} | {error, Reason} first(Ref) ->first(Ref, Timeout) -> {selected, ColNames, Rows} | {error, Reason} last(Ref) ->last(Ref, TimeOut) -> {selected, ColNames, Rows} | {error, Reason} next(Ref) -> next(Ref, TimeOut) -> {selected, ColNames, Rows} | {error, Reason} param_query(Ref, SQLQuery, Params) -> param_query(Ref, SQLQuery, Params, TimeOut) -> ResultTuple | {error, Reason} prev(Ref) -> prev(ConnectionReference, TimeOut) -> {selected, ColNames, Rows} | {error, Reason} start() -> start(Type) -> ok | {error, Reason}stop() -> ok sql_query(Ref, SQLQuery) -> sql_query(Ref, SQLQuery, TimeOut) -> ResultTuple | [ResultTuple] |{error, Reason}select_count(Ref, SelectQuery) -> select_count(Ref, SelectQuery, TimeOut) -> {ok, NrRows} | {error, Reason} select(Ref, Position, N) ->select(Ref, Position, N, TimeOut) -> {selected, ColNames, Rows} | {error, Reason} "
  ],
  [
    "orddict",
    "append(Key, Value, Orddict1) -> Orddict2append_list(Key, ValList, Orddict1) -> Orddict2erase(Key, Orddict1) -> Orddict2fetch(Key, Orddict) -> Valuefetch_keys(Orddict) -> Keystake(Key, Orddict) -> {Value, Orddict1} | errorfilter(Pred, Orddict1) -> Orddict2find(Key, Orddict) -> {ok, Value} | errorfold(Fun, Acc0, Orddict) -> Acc1from_list(List) -> Orddictis_empty(Orddict) -> boolean()is_key(Key, Orddict) -> boolean()map(Fun, Orddict1) -> Orddict2merge(Fun, Orddict1, Orddict2) -> Orddict3new() -> orddict() size(Orddict) -> integer() >= 0store(Key, Value, Orddict1) -> Orddict2to_list(Orddict) -> Listupdate(Key, Fun, Orddict1) -> Orddict2update(Key, Fun, Initial, Orddict1) -> Orddict2update_counter(Key, Increment, Orddict1) -> Orddict2"
  ],
  [
    "ordsets",
    "add_element(Element, Ordset1) -> Ordset2del_element(Element, Ordset1) -> Ordset2filter(Pred, Ordset1) -> Ordset2fold(Function, Acc0, Ordset) -> Acc1from_list(List) -> Ordsetintersection(OrdsetList) -> Ordsetintersection(Ordset1, Ordset2) -> Ordset3is_disjoint(Ordset1, Ordset2) -> boolean()is_element(Element, Ordset) -> boolean()is_empty(Ordset) -> boolean()is_set(Ordset) -> boolean()is_subset(Ordset1, Ordset2) -> boolean()new() -> []size(Ordset) -> integer() >= 0subtract(Ordset1, Ordset2) -> Ordset3to_list(Ordset) -> Listunion(OrdsetList) -> Ordsetunion(Ordset1, Ordset2) -> Ordset3"
  ],
  [
    "os",
    "cmd(Command) -> string()cmd(Command, Options) -> string()find_executable(Name) -> Filename | falsefind_executable(Name, Path) -> Filename | falsegetenv() -> [env_var_name_value()]getenv(VarName) -> Value | falsegetenv(VarName, DefaultValue) -> Valuegetpid() -> Valueputenv(VarName, Value) -> trueset_signal(Signal, Option) -> oksystem_time() -> integer()system_time(Unit) -> integer()timestamp() -> Timestampperf_counter() -> Counterperf_counter(Unit) -> integer()type() -> {Osfamily, Osname}unsetenv(VarName) -> trueversion() -> VersionString | {Major, Minor, Release}"
  ],
  ["os_mon_app"],
  [
    "os_sup",
    "enable() -> ok | {error, Res}enable(Dir, Conf) -> ok | {error, Error}disable() -> ok | {error, Res}disable(Dir, Conf) -> ok | {error, Error}"
  ],
  [
    "persistent_term",
    "erase(Key) -> Resultget() -> Listget(Key) -> Valueget(Key, Default) -> Valueinfo() -> Infoput(Key, Value) -> ok"
  ],
  [
    "pg2",
    "create(Name :: name()) -> okdelete(Name :: name()) -> okget_closest_pid(Name) -> pid() | {error, Reason}get_local_members(Name) -> [pid()] | {error, {no_such_group, Name}}get_members(Name) -> [pid()] | {error, {no_such_group, Name}}join(Name, Pid :: pid()) -> ok | {error, {no_such_group, Name}}leave(Name, Pid :: pid()) -> ok | {error, {no_such_group, Name}}start() -> {ok, pid()} | {error, any()}start_link() -> {ok, pid()} | {error, any()}which_groups() -> [Name :: name()]"
  ],
  [
    "pool",
    "attach(Node) -> already_attached | attachedget_node() -> node()get_nodes() -> [node()]pspawn(Mod, Fun, Args) -> pid()pspawn_link(Mod, Fun, Args) -> pid()start(Name) -> Nodesstart(Name, Args) -> Nodesstop() -> stopped"
  ],
  [
    "prettypr",
    "above(D1::document(), D2::document()) -> document()beside(D1::document(), D2::document()) -> document()best(D::document(), PaperWidth::integer(), LineWidth::integer()) -> empty | document()break(D::document()) -> document()empty() -> document()floating(D::document()) -> document()floating(D::document(), Hp::integer(), Vp::integer()) -> document()follow(D1::document(), D2::document()) -> document()follow(D1::document(), D2::document(), Offset::integer()) -> document()format(D::document()) -> string()format(D::document(), PaperWidth::integer()) -> string()format(D::document(), PaperWidth::integer(), LineWidth::integer()) -> string()nest(N::integer(), D::document()) -> document()null_text(Characters::string()) -> document()par(Docs::[document()]) -> document()par(Docs::[document()], Offset::integer()) -> document()sep(Docs::[document()]) -> document()text(Characters::string()) -> document()text_par(Text::string()) -> document()text_par(Text::string(), Indentation::integer()) -> document()"
  ],
  [
    "proc_lib",
    "format(CrashReport) -> string()format(CrashReport, Encoding) -> string()format(CrashReport, Encoding, Depth) -> string()hibernate(Module, Function, Args) -> no_return()init_ack(Ret) -> okinit_ack(Parent, Ret) -> okinitial_call(Process) -> {Module, Function, Args} | falsespawn(Fun) -> pid()spawn(Node, Fun) -> pid()spawn(Module, Function, Args) -> pid()spawn(Node, Module, Function, Args) -> pid()spawn_link(Fun) -> pid()spawn_link(Node, Fun) -> pid()spawn_link(Module, Function, Args) -> pid()spawn_link(Node, Module, Function, Args) -> pid()spawn_opt(Fun, SpawnOpts) -> pid()spawn_opt(Node, Function, SpawnOpts) -> pid()spawn_opt(Module, Function, Args, SpawnOpts) -> pid()spawn_opt(Node, Module, Function, Args, SpawnOpts) -> pid()start(Module, Function, Args) -> Retstart(Module, Function, Args, Time) -> Retstart(Module, Function, Args, Time, SpawnOpts) -> Retstart_link(Module, Function, Args) -> Retstart_link(Module, Function, Args, Time) -> Retstart_link(Module, Function, Args, Time, SpawnOpts) -> Retstop(Process) -> okstop(Process, Reason, Timeout) -> oktranslate_initial_call(Process) -> {Module, Function, Arity}"
  ],
  [
    "proplists",
    "append_values(Key, ListIn) -> ListOutcompact(ListIn) -> ListOutdelete(Key, List) -> Listexpand(Expansions, ListIn) -> ListOutget_all_values(Key, List) -> [term()]get_bool(Key, List) -> boolean()get_keys(List) -> [term()]get_value(Key, List) -> term()get_value(Key, List, Default) -> term()is_defined(Key, List) -> boolean()lookup(Key, List) -> none | tuple()lookup_all(Key, List) -> [tuple()]normalize(ListIn, Stages) -> ListOutproperty(PropertyIn) -> PropertyOutproperty(Key, Value) -> Propertysplit(List, Keys) -> {Lists, Rest}substitute_aliases(Aliases, ListIn) -> ListOutsubstitute_negations(Negations, ListIn) -> ListOutunfold(ListIn) -> ListOut"
  ],
  [
    "public_key",
    "compute_key(OthersECDHkey, MyECDHkey) -> SharedSecretcompute_key(OthersDHkey, MyDHkey, DHparms) -> SharedSecretdecrypt_private(CipherText, Key) -> PlainTextdecrypt_private(CipherText, Key, Options) -> PlainTextdecrypt_public(CipherText, Key) -> PlainTextdecrypt_public(CipherText, Key, Options) -> PlainTextder_decode(Asn1Type, Der) -> Entityder_encode(Asn1Type, Entity) -> Derdh_gex_group(MinSize, SuggestedSize, MaxSize, Groups) -> {ok, {Size, Group}} | {error, term()}encrypt_private(PlainText, Key) -> CipherTextencrypt_private(PlainText, Key, Options) -> CipherTextencrypt_public(PlainText, Key) -> CipherTextencrypt_public(PlainText, Key, Options) -> CipherTextgenerate_key(Params :: DHparams | ECparams | RSAparams) -> DHkeys | ECkey | RSAkeypem_decode(PemBin :: binary()) -> [pem_entry()]pem_encode(PemEntries :: [pem_entry()]) -> binary()pem_entry_decode(PemEntry) -> term()pem_entry_decode(PemEntry, Password) -> term()pem_entry_encode(Asn1Type, Entity) -> pem_entry() pem_entry_encode(Asn1Type, Entity, InfoPwd) -> pem_entry() pkix_decode_cert(Cert, Type) -> #'Certificate'{} | #'OTPCertificate'{}pkix_encode(Asn1Type, Entity, Type) -> Derpkix_is_issuer(Cert, IssuerCert) -> boolean()pkix_is_fixed_dh_cert(Cert) -> boolean()pkix_is_self_signed(Cert) -> boolean()pkix_issuer_id(Cert, IssuedBy) -> {ok, issuer_id()} | {error, Reason}pkix_normalize_name(Issuer) -> Normalizedpkix_crl_issuer(CRL :: CRL | #'CertificateList'{}) -> Issuerpkix_crls_validate(OTPcertificate, DPandCRLs, Options) -> CRLstatuspkix_crl_verify(CRL, Cert) -> boolean()pkix_dist_point(Cert) -> DistPointpkix_dist_points(Cert) -> DistPointspkix_match_dist_point(CRL, DistPoint) -> boolean()pkix_sign(Cert, Key) -> Derpkix_sign_types(AlgorithmId) -> {DigestType, SignatureType}pkix_verify(Cert, Key) -> boolean()sign(Msg, DigestType, Key) -> Signaturesign(Msg, DigestType, Key, Options) -> Signaturessh_decode(SshBin, Type) -> Decodedssh_encode(InData, Type) -> binary()verify(Msg, DigestType, Signature, Key) -> boolean()verify(Msg, DigestType, Signature, Key, Options) -> boolean()short_name_hash(Name) -> string()",
    "pkix_path_validation(TrustedCert, CertChain, Options) -> {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} pkix_test_data(Options) -> Config pkix_test_data([chain_opts()]) -> [conf_opt()]pkix_test_root_cert(Name, Options) -> RootCertpkix_verify_hostname(Cert, ReferenceIDs) -> boolean()pkix_verify_hostname(Cert, ReferenceIDs, Opts) -> boolean()pkix_verify_hostname_match_fun(Protcol) -> fun(RefId | FQDN::string(), PresentedID) -> boolean() | defaultssh_hostkey_fingerprint(HostKey) -> string()ssh_hostkey_fingerprint(DigestType, HostKey) -> string()ssh_hostkey_fingerprint([DigestType], HostKey) -> [string()]"
  ],
  ["public_key_app"],
  [
    "qlc",
    "append(QHL) -> QHappend(QH1, QH2) -> QH3cursor(QH) -> Cursorcursor(QH, Options) -> Cursordelete_cursor(QueryCursor) -> oke(QH) -> Answers | Errore(QH, Options) -> Answers | Erroreval(QH) -> Answers | Erroreval(QH, Options) -> Answers | Errorfold(Function, Acc0, QH) -> Acc1 | Errorfold(Function, Acc0, QH, Options) -> Acc1 | Errorformat_error(Error) -> Charsinfo(QH) -> Infoinfo(QH, Options) -> Infokeysort(KeyPos, QH1) -> QH2keysort(KeyPos, QH1, SortOptions) -> QH2next_answers(QueryCursor) -> Answers | Errornext_answers(QueryCursor, NumberOfAnswers) -> Answers | Errorq(QLC) -> QHq(QLC, Options) -> QHsort(QH1) -> QH2sort(QH1, SortOptions) -> QH2string_to_handle(QueryString) -> QH | Errorstring_to_handle(QueryString, Options) -> QH | Errorstring_to_handle(QueryString, Options, Bindings) -> QH | Errortable(TraverseFun, Options) -> QH"
  ],
  [
    "queue",
    "filter(Fun, Q1 :: queue(Item)) -> Q2 :: queue(Item)from_list(L :: [Item]) -> queue(Item)in(Item, Q1 :: queue(Item)) -> Q2 :: queue(Item)in_r(Item, Q1 :: queue(Item)) -> Q2 :: queue(Item)is_empty(Q :: queue()) -> boolean()is_queue(Term :: term()) -> boolean()join(Q1 :: queue(Item), Q2 :: queue(Item)) -> Q3 :: queue(Item)len(Q :: queue()) -> integer() >= 0member(Item, Q :: queue(Item)) -> boolean()new() -> queue() out(Q1 :: queue(Item)) -> {{value, Item}, Q2 :: queue(Item)} | {empty, Q1 :: queue(Item)}out_r(Q1 :: queue(Item)) -> {{value, Item}, Q2 :: queue(Item)} | {empty, Q1 :: queue(Item)}reverse(Q1 :: queue(Item)) -> Q2 :: queue(Item)split(N :: integer() >= 0, Q1 :: queue(Item)) -> {Q2 :: queue(Item), Q3 :: queue(Item)}to_list(Q :: queue(Item)) -> [Item]drop(Q1 :: queue(Item)) -> Q2 :: queue(Item)drop_r(Q1 :: queue(Item)) -> Q2 :: queue(Item)get(Q :: queue(Item)) -> Itemget_r(Q :: queue(Item)) -> Itempeek(Q :: queue(Item)) -> empty | {value, Item}peek_r(Q :: queue(Item)) -> empty | {value, Item}cons(Item, Q1 :: queue(Item)) -> Q2 :: queue(Item)daeh(Q :: queue(Item)) -> Itemhead(Q :: queue(Item)) -> Iteminit(Q1 :: queue(Item)) -> Q2 :: queue(Item)lait(Q1 :: queue(Item)) -> Q2 :: queue(Item)last(Q :: queue(Item)) -> Itemliat(Q1 :: queue(Item)) -> Q2 :: queue(Item)snoc(Q1 :: queue(Item), Item) -> Q2 :: queue(Item)tail(Q1 :: queue(Item)) -> Q2 :: queue(Item)"
  ],
  [
    "rand",
    "export_seed() -> undefined | export_state() export_seed_s(State :: state()) -> export_state() jump() -> NewState :: state() jump(State :: state()) -> NewState :: state() normal() -> float()normal(Mean :: number(), Variance :: number()) -> float()normal_s(State :: state()) -> {float(), NewState :: state()}normal_s(Mean :: number(), Variance :: number(), State0 :: state()) -> {float(), NewS :: state()}seed(AlgOrStateOrExpState :: builtin_alg() | state() | export_state()) -> state() seed(Alg :: builtin_alg(), Seed :: seed()) -> state() seed_s(AlgOrStateOrExpState :: builtin_alg() | state() | export_state()) -> state() seed_s(Alg :: builtin_alg(), Seed :: seed()) -> state() uniform() -> X :: float()uniform_real() -> X :: float()uniform(N :: integer() >= 1) -> X :: integer() >= 1uniform_s(State :: state()) -> {X :: float(), NewState :: state()}uniform_real_s(State :: state()) -> {X :: float(), NewState :: state()}uniform_s(N :: integer() >= 1, State :: state()) -> {X :: integer() >= 1, NewState :: state()}"
  ],
  [
    "random",
    "seed() -> ran() seed(SValue) -> undefined | ran() seed(A1, A2, A3) -> undefined | ran() seed0() -> ran() uniform() -> float()uniform(N) -> integer() >= 1uniform_s(State0) -> {float(), State1}uniform_s(N, State0) -> {integer(), State1}"
  ],
  [
    "rb",
    "filter(Filters)filter(Filters, Dates)grep(RegExp)h()help()list()list(Type)log_list()log_list(Type)rescan()rescan(Options)show()show(Report)start()start(Options)start_log(FileName)stop()stop_log()"
  ],
  [
    "re",
    "version() -> binary()compile(Regexp) -> {ok, MP} | {error, ErrSpec}compile(Regexp, Options) -> {ok, MP} | {error, ErrSpec}inspect(MP, Item) -> {namelist, [binary()]}replace(Subject, RE, Replacement) -> iodata() | unicode:charlist() replace(Subject, RE, Replacement, Options) -> iodata() | unicode:charlist() run(Subject, RE) -> {match, Captured} | nomatchrun(Subject, RE, Options) -> {match, Captured} | match | nomatch | {error, ErrType}split(Subject, RE) -> SplitListsplit(Subject, RE, Options) -> SplitList"
  ],
  [
    "registry",
    "int ei_reg_close(reg)int ei_reg_delete(reg,key)int ei_reg_dump(fd,reg,mntab,flags)double ei_reg_getfval(reg,key)int ei_reg_getival(reg,key)const void *ei_reg_getpval(reg,key,size)const char *ei_reg_getsval(reg,key)int ei_reg_getval(reg,key,flags,v,...)int ei_reg_markdirty(reg,key)ei_reg *ei_reg_open(size)int ei_reg_purge(reg)int ei_reg_resize(reg,newsize)int ei_reg_restore(fd,reg,mntab)int ei_reg_setfval(reg,key,f)int ei_reg_setival(reg,key,i)int ei_reg_setpval(reg,key,p,size)int ei_reg_setsval(reg,key,s)int ei_reg_setval(reg,key,flags,v,...)int ei_reg_stat(reg,key,obuf)int ei_reg_tabstat(reg,obuf)"
  ],
  ["rel"],
  [
    "release_handler",
    "check_install_release(Vsn) -> {ok, OtherVsn, Descr} | {error, Reason}check_install_release(Vsn,Opts) -> {ok, OtherVsn, Descr} | {error, Reason}create_RELEASES(Root, RelDir, RelFile, AppDirs) -> ok | {error, Reason}install_file(Vsn, File) -> ok | {error, Reason}install_release(Vsn) -> {ok, OtherVsn, Descr} | {error, Reason}install_release(Vsn, [Opt]) -> {ok, OtherVsn, Descr} | {continue_after_restart, OtherVsn, Descr} | {error, Reason}make_permanent(Vsn) -> ok | {error, Reason}remove_release(Vsn) -> ok | {error, Reason}reboot_old_release(Vsn) -> ok | {error, Reason}set_removed(Vsn) -> ok | {error, Reason}set_unpacked(RelFile, AppDirs) -> {ok, Vsn} | {error, Reason}unpack_release(Name) -> {ok, Vsn} | {error, Reason}which_releases() -> [{Name, Vsn, Apps, Status}]which_releases(Status) -> [{Name, Vsn, Apps, Status}]upgrade_app(App, Dir) -> {ok, Unpurged} | restart_emulator | {error, Reason}downgrade_app(App, Dir) ->downgrade_app(App, OldVsn, Dir) -> {ok, Unpurged} | restart_emulator | {error, Reason}upgrade_script(App, Dir) -> {ok, NewVsn, Script}downgrade_script(App, OldVsn, Dir) -> {ok, Script}eval_appup_script(App, ToVsn, ToDir, Script) -> {ok, Unpurged} | restart_emulator | {error, Reason}"
  ],
  [
    "reltool",
    "create_target(Server, TargetDir) -> ok | {error, Reason}eval_target_spec(TargetSpec, RootDir, TargetDir) -> ok | {error, Reason}get_config(Server) -> {ok, Config} | {error, Reason}get_config(Server, InclDefaults, InclDerived) -> {ok, Config} | {error, Reason}get_rel(Server, Relname) -> {ok, RelFile} | {error, Reason}get_script(Server, Relname) -> {ok, ScriptFile | {error, Reason}get_status(Server) -> {ok, [Warning]} | {error, Reason}get_server(WindowPid) -> {ok, ServerPid} | {error, Reason}get_target_spec(Server) -> {ok, TargetSpec} | {error, Reason}install(RelName, TargetDir) -> ok | {error, Reason}start() -> {ok, WindowPid} | {error, Reason}start(Options) -> {ok, WindowPid} | {error, Reason}start_link(Options) -> {ok, WindowPid} | {error, Reason}start_server(Options) -> {ok, ServerPid} | {error, Reason}stop(Pid) -> ok | {error, Reason}"
  ],
  ["relup"],
  [
    "rpc",
    "abcast(Name, Msg) -> abcastabcast(Nodes, Name, Msg) -> abcastasync_call(Node, Module, Function, Args) -> Keyblock_call(Node, Module, Function, Args) -> Res | {badrpc, Reason}block_call(Node, Module, Function, Args, Timeout) -> Res | {badrpc, Reason}call(Node, Module, Function, Args) -> Res | {badrpc, Reason}call(Node, Module, Function, Args, Timeout) -> Res | {badrpc, Reason}cast(Node, Module, Function, Args) -> trueeval_everywhere(Module, Function, Args) -> abcasteval_everywhere(Nodes, Module, Function, Args) -> abcastmulti_server_call(Name, Msg) -> {Replies, BadNodes}multi_server_call(Nodes, Name, Msg) -> {Replies, BadNodes}multicall(Module, Function, Args) -> {ResL, BadNodes}multicall(Nodes, Module, Function, Args) -> {ResL, BadNodes}multicall(Module, Function, Args, Timeout) -> {ResL, BadNodes}multicall(Nodes, Module, Function, Args, Timeout) -> {ResL, BadNodes}nb_yield(Key) -> {value, Val} | timeoutnb_yield(Key, Timeout) -> {value, Val} | timeoutparallel_eval(FuncCalls) -> ResLpinfo(Pid) -> [{Item, Info}] | undefinedpinfo(Pid, Item) -> {Item, Info} | undefined | []pinfo(Pid, ItemList) -> [{Item, Info}] | undefined | []pmap(FuncSpec, ExtraArgs, List1) -> List2sbcast(Name, Msg) -> {GoodNodes, BadNodes}sbcast(Nodes, Name, Msg) -> {GoodNodes, BadNodes}server_call(Node, Name, ReplyWrapper, Msg) -> Reply | {error, Reason}yield(Key) -> Res | {badrpc, Reason}"
  ],
  ["run_erl"],
  ["runtime_tools_app"],
  ["sasl_app"],
  [
    "scheduler",
    "sample() -> sched_sample() sample_all() -> sched_sample() utilization(Seconds) -> sched_util_result() utilization(Sample) -> sched_util_result() utilization(Sample1, Sample2) -> sched_util_result()"
  ],
  ["script"],
  [
    "seq_trace",
    "set_token(Token) -> PreviousToken | okset_token(Component, Val) -> OldValget_token() -> [] | token() get_token(Component) -> {Component, Val}print(TraceInfo) -> okprint(Label, TraceInfo) -> okreset_trace() -> trueset_system_tracer(Tracer) -> OldTracerget_system_tracer() -> Tracer"
  ],
  [
    "sets",
    "add_element(Element, Set1) -> Set2del_element(Element, Set1) -> Set2filter(Pred, Set1) -> Set2fold(Function, Acc0, Set) -> Acc1from_list(List) -> Setintersection(SetList) -> Setintersection(Set1, Set2) -> Set3is_disjoint(Set1, Set2) -> boolean()is_element(Element, Set) -> boolean()is_empty(Set) -> boolean()is_set(Set) -> boolean()is_subset(Set1, Set2) -> boolean()new() -> set() size(Set) -> integer() >= 0subtract(Set1, Set2) -> Set3to_list(Set) -> Listunion(SetList) -> Setunion(Set1, Set2) -> Set3"
  ],
  [
    "shell",
    "history(N) -> integer() >= 0prompt_func(PromptFunc) -> PromptFunc2results(N) -> integer() >= 0start_restricted(Module) -> {error, Reason}stop_restricted() -> no_return()strings(Strings) -> Strings2",
    "catch_exception(Bool) -> boolean()"
  ],
  ["shell_default"],
  [
    "slave",
    "pseudo(Master, ServerList) -> okrelay(Pid) -> no_return()start(Host) -> {ok, Node} | {error, Reason}start(Host, Name) -> {ok, Node} | {error, Reason}start(Host, Name, Args) -> {ok, Node} | {error, Reason}start_link(Host) -> {ok, Node} | {error, Reason}start_link(Host, Name) -> {ok, Node} | {error, Reason}start_link(Host, Name, Args) -> {ok, Node} | {error, Reason}stop(Node) -> ok",
    "pseudo([Master | ServerList]) -> ok"
  ],
  [
    "snmp",
    "config() -> ok | {error, Reason}start() -> ok | {error, Reason}start(Type) -> ok | {error, Reason}start_agent() -> ok | {error, Reason}start_agent(Type) -> ok | {error, Reason}start_manager() -> ok | {error, Reason}start_manager(Type) -> ok | {error, Reason}date_and_time() -> DateAndTimedate_and_time_to_universal_time_dst(DateAndTime) -> [utc()]date_and_time_to_string(DateAndTime) -> string()date_and_time_to_string(DateAndTime, Validate) -> string()date_and_time_to_string2(DateAndTime) -> string()local_time_to_date_and_time_dst(Local) -> [DateAndTime]universal_time_to_date_and_time(UTC) -> DateAndTimevalidate_date_and_time(DateAndTime) -> bool()validate_date_and_time(DateAndTime, Validate) -> bool()passwd2localized_key(Alg, Passwd, EngineID) -> Keyoctet_string_to_bits(S) -> Valbits_to_octet_string(B) -> Valread_mib(FileName) -> {ok, mib()} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Block | Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop, Block) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Start, Block | Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop, Block) -> ok | {ok, Cnt} | {error, Reason}change_log_size(LogName, NewSize) -> ok | {error, Reason}print_version_info() -> void()print_version_info(Prefix) -> void()versions1() -> {ok, Info} | {error, Reason}versions2() -> {ok, Info} | {error, Reason}print_versions(VersionInfo) -> void()print_versions(Prefix, VersionInfo) -> void()enable_trace() -> void()disable_trace() -> void()set_trace(Targets) -> void()reset_trace(Targets) -> void()set_trace(Targets, Opts) -> void()"
  ],
  ["snmp_app"],
  [
    "snmp_community_mib",
    "configure(ConfDir) -> void()reconfigure(ConfDir) -> void()add_community(Idx, CommName, SecName, CtxName, TransportTag) -> Retadd_community(Idx, CommName, SecName, EngineId, CtxName, TransportTag) -> Retdelete_community(Key) -> Ret"
  ],
  [
    "snmp_framework_mib",
    "configure(ConfDir) -> void()init() -> void()add_context(Ctx) -> Retdelete_context(Key) -> Ret"
  ],
  [
    "snmp_generic",
    "get_status_col(Name, Cols)get_status_col(NameDb, Cols) -> {ok, StatusVal} | falseget_index_types(Name)get_table_info(Name, Item) -> table_info_result()table_func(Op1, NameDb)table_func(Op2, RowIndex, Cols, NameDb) -> Rettable_get_elements(NameDb, RowIndex, Cols) -> Valuestable_next(NameDb, RestOid) -> RowIndex | endOfTabletable_row_exists(NameDb, RowIndex) -> bool()table_set_elements(NameDb, RowIndex, Cols) -> bool()variable_func(Op1, NameDb)variable_func(Op2, Val, NameDb) -> Retvariable_get(NameDb) -> {value, Value} | undefinedvariable_set(NameDb, NewVal) -> true | false"
  ],
  [
    "snmp_index",
    "delete(Index) -> truedelete(Index, Key) -> NewIndexget(Index, KeyOid) -> {ok, {KeyOid, Value}} | undefinedget_last(Index) -> {ok, {KeyOid, Value}} | undefinedget_next(Index, KeyOid) -> {ok, {NextKeyOid, Value}} | undefinedinsert(Index, Key, Value) -> NewIndexkey_to_oid(Index, Key) -> KeyOidnew(KeyTypes) -> Index"
  ],
  [
    "snmp_notification_mib",
    "configure(ConfDir) -> void()reconfigure(ConfDir) -> void()add_notify(Name, Tag, Type) -> Retdelete_notify(Key) -> Ret"
  ],
  [
    "snmp_pdus",
    "dec_message([byte()]) -> Messagedec_message_only([byte()]) -> Messagedec_pdu([byte()]) -> Pdudec_scoped_pdu([byte()]) -> ScopedPdudec_scoped_pdu_data([byte()]) -> ScopedPduDatadec_usm_security_parameters([byte()]) -> UsmSecParamsenc_encrypted_scoped_pdu(EncryptedScopedPdu) -> [byte()]enc_message(Message) -> [byte()]enc_message_only(Message) -> [byte()]enc_pdu(Pd) -> [byte()]enc_scoped_pdu(ScopedPdu) -> [byte()]enc_usm_security_parameters(UsmSecParams) -> [byte()]"
  ],
  [
    "snmp_standard_mib",
    "configure(ConfDir) -> void()inc(Name) -> void()inc(Name, N) -> void()reconfigure(ConfDir) -> void()reset() -> void()sys_up_time() -> Time"
  ],
  [
    "snmp_target_mib",
    "configure(ConfDir) -> void()reconfigure(ConfDir) -> void()set_target_engine_id(TargetAddrName, EngineId) -> boolean()add_addr(Name, Domain, Addr, Timeout, Retry, TagList, Params, EngineId, TMask, MMS) -> Retdelete_addr(Key) -> Retadd_params(Name, MPModel, SecModel, SecName, SecLevel) -> Retdelete_params(Key) -> Ret"
  ],
  [
    "snmp_user_based_sm_mib",
    "configure(ConfDir) -> void()reconfigure(ConfDir) -> void()add_user(EngineID, Name, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey) -> Retdelete_user(Key) -> Ret"
  ],
  [
    "snmp_view_based_acm_mib",
    "configure(ConfDir) -> void()reconfigure(ConfDir) -> void()add_sec2group(SecModel, SecName, GroupName) -> Retdelete_sec2group(Key) -> Retadd_access(GroupName, Prefix, SecModel, SecLevel, Match, RV, WV, NV) -> Retdelete_access(Key) -> Retadd_view_tree_fam(ViewIndex, SubTree, Status, Mask) -> Retdelete_view_tree_fam(Key) -> Ret"
  ],
  [
    "snmpa",
    "add_agent_caps(SysORID, SysORDescr) -> SysORIndexdel_agent_caps(SysORIndex) -> void()get_agent_caps() -> [[SysORIndex, SysORID, SysORDescr, SysORUpTime]]get(Agent, Vars) -> Values | {error, Reason}get(Agent, Vars, Context) -> Values | {error, Reason}get_next(Agent, Vars) -> Values | {error, Reason}get_next(Agent, Vars, Context) -> Values | {error, Reason}backup(BackupDir) -> ok | {error, Reason}backup(Agent, BackupDir) -> ok | {error, Reason}info() -> [{Key, Value}]info(Agent) -> [{Key, Value}]old_info_format(NewInfo) -> OldInfoload_mib(Mib) -> ok | {error, Reason}load_mib(Agent, Mib) -> ok | {error, Reason}load_mibs(Mibs) -> ok | {error, Reason}load_mibs(Mibs, Force) -> ok | {error, Reason}load_mibs(Agent, Mibs) -> ok | {error, Reason}load_mibs(Agent, Mibs, Force) -> ok | {error, Reason}unload_mib(Mib) -> ok | {error, Reason}unload_mib(Agent, Mib) -> ok | {error, Reason}unload_mibs(Mibs) -> ok | {error, Reason}unload_mibs(Mibs, Force) -> ok | {error, Reason}unload_mibs(Agent, Mibs) -> ok | {error, Reason}unload_mibs(Agent, Mibs, Force) -> ok | {error, Reason}which_mibs() -> Mibswhich_mibs(Agent) -> Mibswhereis_mib(MibName) -> {ok, MibFile} | {error, Reason}whereis_mib(Agent, MibName) -> {ok, MibFile} | {error, Reason}current_request_id() -> {value, RequestId} | falsecurrent_context() -> {value, Context} | falsecurrent_community() -> {value, Community} | falsecurrent_address() -> {value, Address} | falseenum_to_int(Name, Enum) -> {value, Int} | falseenum_to_int(Db, Name, Enum) -> {value, Int} | falseint_to_enum(Name, Int) -> {value, Enum} | falseint_to_enum(Db, Name, Int) -> {value, Enum} | falsename_to_oid(Name) -> {value, oid()} | falsename_to_oid(Db, Name) -> {value, oid()} | falseoid_to_name(OID) -> {value, Name} | falseoid_to_name(Db, OID) -> {value, Name} | falsewhich_aliasnames() -> Resultwhich_tables() -> Resultwhich_variables() -> Resultwhich_notifications() -> Resultlog_to_txt(LogDir)log_to_txt(LogDir, Block | Mibs)log_to_txt(LogDir, Mibs, Block | OutFile) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Block | Mibs) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, Block | LogName) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, Block | LogFile) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}change_log_size(NewSize) -> ok | {error, Reason}set_log_type(NewType) -> {ok, OldType} | {error, Reason}set_log_type(Agent, NewType) -> {ok, OldType} | {error, Reason}mib_of(Oid) -> {ok, MibName} | {error, Reason}mib_of(Agent, Oid) -> {ok, MibName} | {error, Reason}me_of(Oid) -> {ok, Me} | {error, Reason}me_of(Agent, Oid) -> {ok, Me} | {error, Reason}invalidate_mibs_cache() -> void()invalidate_mibs_cache(Agent) -> void()enable_mibs_cache() -> void()enable_mibs_cache(Agent) -> void()disable_mibs_cache() -> void()disable_mibs_cache(Agent) -> void()which_mibs_cache_size() -> void()which_mibs_cache_size(Agent) -> void()gc_mibs_cache() -> {ok, NumElementsGCed} | {error, Reason}gc_mibs_cache(Agent) -> {ok, NumElementsGCed} | {error, Reason}gc_mibs_cache(Age) -> {ok, NumElementsGCed} | {error, Reason}gc_mibs_cache(Agent, Age) -> {ok, NumElementsGCed} | {error, Reason}gc_mibs_cache(Age, GcLimit) -> {ok, NumElementsGCed} | {error, Reason}gc_mibs_cache(Agent, Age, GcLimit) -> {ok, NumElementsGCed} | {error, Reason}enable_mibs_cache_autogc() -> void()enable_mibs_cache_autogc(Agent) -> void()disable_mibs_cache_autogc() -> void()disable_mibs_cache_autogc(Agent) -> void()update_mibs_cache_age(NewAge) -> ok | {error, Reason}update_mibs_cache_age(Agent, NewAge) -> ok | {error, Reason}update_mibs_cache_gclimit(NewGcLimit) -> ok | {error, Reason}update_mibs_cache_gclimit(Agent, NewGCLimit) -> ok | {error, Reason}register_notification_filter(Id, Mod, Data) -> ok | {error, Reason}register_notification_filter(Agent, Id, Mod, Data) -> ok | {error, Reason}register_notification_filter(Id, Mod, Data, Where) -> ok | {error, Reason}register_notification_filter(Agent, Id, Mod, Data, Where) -> ok | {error, Reason}unregister_notification_filter(Id) -> ok | {error, Reason}unregister_notification_filter(Agent, Id) -> ok | {error, Reason}which_notification_filter() -> Filterswhich_notification_filter(Agent) -> Filtersset_request_limit(NewLimit) -> {ok, OldLimit} | {error, Reason}set_request_limit(Agent, NewLimit) -> {ok, OldLimit} | {error, Reason}register_subagent(Agent, SubTreeOid, Subagent) -> ok | {error, Reason}unregister_subagent(Agent, SubagentOidOrPid) -> ok | {ok, SubAgentPid} | {error, Reason}send_notification2(Agent, Notification, SendOpts) -> void()send_notification(Agent, Notification, Receiver)send_notification(Agent, Notification, Receiver, Varbinds)send_notification(Agent, Notification, Receiver, NotifyName, Varbinds)send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds) -> void() send_notification(Agent, Notification, Receiver, NotifyName, ContextName, Varbinds, LocalEngineID) -> void() discovery(TargetName, Notification) -> {ok, ManagerEngineID} | {error, Reason}discovery(TargetName, Notification, Varbinds) -> {ok, ManagerEngineID} | {error, Reason}discovery(TargetName, Notification, DiscoHandler) -> {ok, ManagerEngineID} | {error, Reason}discovery(TargetName, Notification, ContextName, Varbinds) -> {ok, ManagerEngineID} | {error, Reason}discovery(TargetName, Notification, Varbinds, DiscoHandler) -> {ok, ManagerEngineID} | {error, Reason}discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler) -> {ok, ManagerEngineID} | {error, Reason}discovery(TargetName, Notification, ContextName, Varbinds, DiscoHandler, ExtraInfo) -> {ok, ManagerEngineID} | {error, Reason}convert_config(OldConfig) -> AgentConfigrestart_worker() -> void()restart_worker(Agent) -> void()restart_set_worker() -> void()restart_set_worker(Agent) -> void()print_mib_info() -> void()print_mib_tables() -> void()print_mib_variables() -> void()verbosity(Ref,Verbosity) -> void()"
  ],
  [
    "snmpa_conf",
    "agent_entry(Tag, Val) -> agent_entry()write_agent_config(Dir, Conf) -> okwrite_agent_config(Dir, Hdr, Conf) -> okappend_agent_config(Dir, Conf) -> okread_agent_config(Dir) -> Confstandard_entry(Tag, Val) -> standard_entry()write_standard_config(Dir, Conf) -> okwrite_standard_config(Dir, Hdr, Conf) -> okappend_standard_config(Dir, Conf) -> okread_standard_config(Dir) -> Confcontext_entry(Context) -> context_entry()write_context_config(Dir, Conf) -> okwrite_context_config(Dir, Hdr, Conf) -> okappend_context_config(Dir, Conf) -> okread_context_config(Dir) -> Confcommunity_entry(CommunityIndex) -> community_entry()community_entry(CommunityIndex, CommunityName, SecName, ContextName, TransportTag) -> community_entry()write_community_config(Dir, Conf) -> okwrite_community_config(Dir, Hdr, Conf) -> okappend_community_config(Dir, Conf) -> okread_community_config(Dir) -> Conftarget_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId) -> target_addr_entry()target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask) -> target_addr_entry()target_addr_entry(Name, Domain, Addr, TagList, ParamsName, EngineId, TMask, MaxMessageSize) -> target_addr_entry()target_addr_entry(Name, Domain, Addr, Timeout, RetryCount, TagList, ParamsName, EngineId, TMask, MaxMessageSize) -> target_addr_entry()write_target_addr_config(Dir, Conf) -> okwrite_target_addr_config(Dir, Hdr, Conf) -> okappend_target_addr_config(Dir, Conf) -> okread_target_addr_config(Dir) -> Conftarget_params_entry(Name, Vsn) -> target_params_entry()target_params_entry(Name, Vsn, SecName, SecLevel) -> target_params_entry()target_params_entry(Name, MPModel, SecModel, SecName, SecLevel) -> target_params_entry()write_target_params_config(Dir, Conf) -> okwrite_target_params_config(Dir, Hdr, Conf) -> okappend_target_params_config(Dir, Conf) -> okread_target_params_config(Dir) -> Confvacm_s2g_entry(SecModel, SecName, GroupName) -> vacm_s2g_entry()vacm_acc_entry(GroupName, Prefix, SecModel, SecLevel, Match, ReadView, WriteView, NotifyView) -> vacm_acc_entry()vacm_vtf_entry(ViewIndex, ViewSubtree) -> vacm_vtf_entry()vacm_vtf_entry(ViewIndex, ViewSubtree, ViewStatus, ViewMask) -> vacm_vtf_entry()write_vacm_config(Dir, Conf) -> okwrite_vacm_config(Dir, Hdr, Conf) -> okappend_vacm_config(Dir, Conf) -> okread_vacm_config(Dir) -> Confusm_entry(EngineId) -> usm_entry()usm_entry(EngineID, UserName, SecName, Clone, AuthP, AuthKeyC, OwnAuthKeyC, PrivP, PrivKeyC, OwnPrivKeyC, Public, AuthKey, PrivKey) -> usm_entry()write_usm_config(Dir, Conf) -> okwrite_usm_config(Dir, Hdr, Conf) -> okappend_usm_config(Dir, Conf) -> okread_usm_config(Dir) -> Confnotify_entry(Name, Tag, Type) -> notify_entry()write_notify_config(Dir, Conf) -> okwrite_notify_config(Dir, Hdr, Conf) -> okappend_notify_config(Dir, Conf) -> okread_notify_config(Dir) -> Conf"
  ],
  [
    "snmpa_discovery_handler",
    "stage1_finish(TargetName, ManagerEngineID, ExtraInfo) -> ignore | {ok, usm_entry() | [usm_entry()]} | {ok, usm_entry() | [usm_entry()], NewExtraInfo}"
  ],
  [
    "snmpa_error",
    "config_err(Format, Args) -> void()user_err(Format, Args) -> void()"
  ],
  [
    "snmpa_error_io",
    "config_err(Format, Args) -> void()user_err(Format, Args) -> void()"
  ],
  [
    "snmpa_error_logger",
    "config_err(Format, Args) -> void()user_err(Format, Args) -> void()"
  ],
  [
    "snmpa_error_report",
    "config_err(Format, Args) -> void()user_err(Format, Args) -> void()"
  ],
  [
    "snmpa_local_db",
    "dump() -> ok | {error, Reason}match(NameDb, Pattern)print()print(TableName)print(TableName, Db)table_create(NameDb) -> bool()table_create_row(NameDb, RowIndex, Row) -> bool()table_delete(NameDb) -> void()table_delete_row(NameDb, RowIndex) -> bool()table_exists(NameDb) -> bool()table_get_row(NameDb, RowIndex) -> Row | undefined"
  ],
  [
    "snmpa_mib_data",
    "Module:new(Storage) -> StateModule:close(State) -> void()Module:sync(State) -> void()Module:load_mib(State, Filename, MeOverride, TeOverride) -> {ok, NewState} | {error, Reason}Module:unload_mib(State, Filename) -> {ok, NewState} | {error, Reason}Module:lookup(State, Oid) -> ReplyModule:next(State, Oid, MibView) -> ReplyModule:register_subagent(State, Oid, Pid) -> ReplyModule:unregister_subagent(State, PidOrOid) -> ReplyModule:dump(State, Destination) -> ReplyModule:which_mib(State, Oid) -> ReplyModule:which_mibs(State) -> ReplyModule:whereis_mib(State, MibName) -> ReplyModule:info(State) -> ReplyModule:backup(State, BackupDir) -> ReplyModule:code_change(Destination, Vsn, Extra, State) -> NewState"
  ],
  [
    "snmpa_mib_storage",
    "Module:open(Name, RecordName, Fields, Type, Options) -> {ok, TabId} | {error, Reason}Module:close(TabId) -> void()Module:read(TabId, Key) -> false | {value, Record}Module:write(TabId, Record) -> ok | {error, Reason}Module:delete(TabId) -> void()Module:delete(TabId, Key) -> ok | {error, Reason}Module:match_object(TabId, Pattern) -> Recs | {error, Reason}Module:match_delete(TabId, Pattern) -> Recs | {error, Reason}Module:tab2list(TabId) -> RecsModule:info(TabId) -> {ok, Info} | {error, Reason}Module:sync(TabId) -> void()Module:backup(TabId, BackupDir) -> ok | {error, Reason}"
  ],
  [
    "snmpa_mpd",
    "init(Vsns) -> mpd_state()process_packet(Packet, From, State, NoteStore, Log) -> {ok, Vsn, Pdu, PduMS, ACMData} | {discarded, Reason} | {discovery, DiscoPacket}process_packet(Packet, From, LocalEngineID, State, NoteStore, Log) -> {ok, Vsn, Pdu, PduMS, ACMData} | {discarded, Reason} | {discovery, DiscoPacket}generate_response_msg(Vsn, RePdu, Type, ACMData, Log) -> {ok, Packet} | {discarded, Reason}generate_response_msg(Vsn, RePdu, Type, ACMData, LocalEngineID, Log) -> {ok, Packet} | {discarded, Reason}generate_msg(Vsn, NoteStore, Pdu, MsgData, To) -> {ok, PacketsAndAddresses} | {discarded, Reason}generate_msg(Vsn, NoteStore, Pdu, MsgData, LocalEngineID, To) -> {ok, PacketsAndAddresses} | {discarded, Reason}process_taddrs(TDests) -> Destsdiscarded_pdu(Variable) -> void()"
  ],
  [
    "snmpa_network_interface",
    "start_link(Prio, NoteStore, MasterAgent, Opts) -> {ok, Pid} | {error, Reason}info(Pid) -> [{Key, Value}]verbosity(Pid, Verbosity) -> void()get_log_type(Pid) -> {ok, LogType} | {error, Reason}set_log_type(Pid, NewType) -> {ok, OldType} | {error, Reason}"
  ],
  [
    "snmpa_network_interface_filter",
    "accept_recv(Domain, Addr) -> boolean()accept_send(Domain, Addr) -> boolean()accept_recv_pdu(Domain, Addr, PduType) -> boolean()accept_send_pdu(Targets, PduType) -> Reply"
  ],
  [
    "snmpa_notification_delivery_info_receiver",
    "delivery_targets(Tag, Targets, Extra) -> void()delivery_info(Tag, Target, DeliveryResult, Extra) -> void()"
  ],
  ["snmpa_notification_filter", "handle_notification(Notif, Data) -> Reply"],
  [
    "snmpa_supervisor",
    "start_sub_sup(Opts) -> {ok, pid()} | {error, {already_started, pid()}} | {error, Reason}start_master_sup(Opts) -> {ok, pid()} | {error, {already_started, pid()}} | {error, Reason}start_sub_agent(ParentAgent,Subtree,Mibs) -> {ok, pid()} | {error, Reason}stop_sub_agent(SubAgent) -> ok | no_such_child"
  ],
  [
    "snmpc",
    "compile(File)compile(File, Options) -> {ok, BinFileName} | {error, Reason}is_consistent(Mibs) -> ok | {error, Reason}mib_to_hrl(MibName) -> ok | {error, Reason}"
  ],
  ["snmpc(command)"],
  [
    "snmpm",
    "monitor() -> Refdemonitor(Ref) -> void()notify_started(Timeout) -> Pidcancel_notify_started(Pid) -> void()register_user(Id, Module, Data) -> ok | {error, Reason}register_user(Id, Module, Data, DefaultAgentConfig) -> ok | {error, Reason}register_user_monitor(Id, Module, Data) -> ok | {error, Reason}register_user_monitor(Id, Module, Data, DefaultAgentConfig) -> ok | {error, Reason}unregister_user(Id) -> ok | {error, Reason}which_users() -> Usersregister_agent(UserId, TargetName, Config) -> ok | {error, Reason}unregister_agent(UserId, TargetName) -> ok | {error, Reason}agent_info(TargetName, Item) -> {ok, Val} | {error, Reason}update_agent_info(UserId, TargetName, Info) -> ok | {error, Reason}update_agent_info(UserId, TargetName, Item, Val) -> ok | {error, Reason}which_agents() -> Agentswhich_agents(UserId) -> Agentsregister_usm_user(EngineID, UserName, Conf) -> ok | {error, Reason}unregister_usm_user(EngineID, UserName) -> ok | {error, Reason}usm_user_info(EngineID, UserName, Item) -> {ok, Val} | {error, Reason}update_usm_user_info(EngineID, UserName, Item, Val) -> ok | {error, Reason}which_usm_users() -> UsmUserswhich_usm_users(EngineID) -> UsmUserssync_get2(UserId, TargetName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get2(UserId, TargetName, Oids, SendOpts) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get(UserId, TargetName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get(UserId, TargetName, ContextName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get(UserId, TargetName, Oids, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get(UserId, TargetName, ContextName, Oids, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get(UserId, TargetName, ContextName, Oids, Timeout, ExtraInfo) -> {ok, SnmpReply, Remaining} | {error, Reason}async_get2(UserId, TargetName, Oids) -> {ok, ReqId} | {error, Reason}async_get2(UserId, TargetName, Oids, SendOpts) -> {ok, ReqId} | {error, Reason}async_get(UserId, TargetName, Oids) -> {ok, ReqId} | {error, Reason}async_get(UserId, TargetName, ContextName, Oids) -> {ok, ReqId} | {error, Reason}async_get(UserId, TargetName, Oids, Expire) -> {ok, ReqId} | {error, Reason}async_get(UserId, TargetName, ContextName, Oids, Expire) -> {ok, ReqId} | {error, Reason}async_get(UserId, TargetName, ContextName, Oids, Expire, ExtraInfo) -> {ok, ReqId} | {error, Reason}sync_get_next2(UserId, TargetName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_next2(UserId, TargetName, Oids, SendOpts) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_next(UserId, TargetName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_next(UserId, TargetName, ContextName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_next(UserId, TargetName, Oids, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_next(UserId, TargetName, ContextName, Oids, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_next(UserId, TargetName, ContextName, Oids, Timeout, ExtraInfo) -> {ok, SnmpReply, Remaining} | {error, Reason}async_get_next2(UserId, TargetName, Oids) -> {ok, ReqId} | {error, Reason}async_get_next2(UserId, TargetName, Oids, SendOpts) -> {ok, ReqId} | {error, Reason}async_get_next(UserId, TargetName, Oids) -> {ok, ReqId} | {error, Reason}async_get_next(UserId, TargetName, ContextName, Oids) -> {ok, ReqId} | {error, Reason}async_get_next(UserId, TargetName, Oids, Expire) -> {ok, ReqId} | {error, Reason}async_get_next(UserId, TargetName, ContextName, Oids, Expire) -> {ok, ReqId} | {error, Reason}async_get_next(UserId, TargetName, ContextName, Oids, Expire, ExtraInfo) -> {ok, ReqId} | {error, Reason}sync_set2(UserId, TargetName, VarsAndVals) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_set2(UserId, TargetName, VarsAndVals, SendOpts) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_set(UserId, TargetName, VarsAndVals) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_set(UserId, TargetName, ContextName, VarsAndVals) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_set(UserId, TargetName, VarsAndVals, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_set(UserId, TargetName, ContextName, VarsAndVals, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_set(UserId, TargetName, ContextName, VarsAndVals, Timeout, ExtraInfo) -> {ok, SnmpReply, Remaining} | {error, Reason}async_set2(UserId, TargetName, VarsAndVals) -> {ok, ReqId} | {error, Reason}async_set2(UserId, TargetName, VarsAndVals, SendOpts) -> {ok, ReqId} | {error, Reason}async_set(UserId, TargetName, VarsAndVals) -> {ok, ReqId} | {error, Reason}async_set(UserId, TargetName, ContextName, VarsAndVals) -> {ok, ReqId} | {error, Reason}async_set(UserId, TargetName, VarsAndVals, Expire) -> {ok, ReqId} | {error, Reason}async_set(UserId, TargetName, ContextName, VarsAndVals, Expire) -> {ok, ReqId} | {error, Reason}async_set(UserId, TargetName, ContextName, VarsAndVals, Expire, ExtraInfo) -> {ok, ReqId} | {error, Reason}sync_get_bulk2(UserId, TragetName, NonRep, MaxRep, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_bulk2(UserId, TragetName, NonRep, MaxRep, Oids, SendOpts) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_bulk(UserId, TragetName, NonRep, MaxRep, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_bulk(UserId, TragetName, NonRep, MaxRep, Oids, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids, Timeout) -> {ok, SnmpReply, Remaining} | {error, Reason}sync_get_bulk(UserId, TragetName, NonRep, MaxRep, ContextName, Oids, Timeout, ExtraInfo) -> {ok, SnmpReply, Remaining} | {error, Reason}async_get_bulk2(UserId, TargetName, NonRep, MaxRep, Oids) -> {ok, ReqId} | {error, Reason}async_get_bulk2(UserId, TargetName, NonRep, MaxRep, Oids, SendOpts) -> {ok, ReqId} | {error, Reason}async_get_bulk(UserId, TargetName, NonRep, MaxRep, Oids) -> {ok, ReqId} | {error, Reason}async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids) -> {ok, ReqId} | {error, Reason}async_get_bulk(UserId, TargetName, NonRep, MaxRep, Oids, Expire) -> {ok, ReqId} | {error, Reason}async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids, Expire) -> {ok, ReqId} | {error, Reason}async_get_bulk(UserId, TargetName, NonRep, MaxRep, ContextName, Oids, Expire, ExtraInfo) -> {ok, ReqId} | {error, Reason}cancel_async_request(UserId, ReqId) -> ok | {error, Reason}log_to_txt(LogDir)log_to_txt(LogDir, Block | Mibs)log_to_txt(LogDir, Mibs, Block | OutFile) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, Block | LogName) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Block | Mibs) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs) -> ok | {error, Reason}log_to_io(LogDir, Mibs, Block | LogName) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, Block | LogFile) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop) -> ok | {ok, Cnt} | {error, Reason}change_log_size(NewSize) -> ok | {error, Reason}set_log_type(NewType) -> {ok, OldType} | {error, Reason}load_mib(Mib) -> ok | {error, Reason}unload_mib(Mib) -> ok | {error, Reason}which_mibs() -> Mibsname_to_oid(Name) -> {ok, Oids} | {error, Reason}oid_to_name(Oid) -> {ok, Name} | {error, Reason}oid_to_type(Oid) -> {ok, Type} | {error, Reason}backup(BackupDir) -> ok | {error, Reason}info() -> [{Key, Value}]verbosity(Ref, Verbosity) -> void()format_reason(Reason) -> string()format_reason(Prefix, Reason) -> string()"
  ],
  [
    "snmpm_conf",
    "manager_entry(Tag, Val) -> manager_entry()write_manager_config(Dir, Conf) -> okwrite_manager_config(Dir, Hdr, Conf) -> okappend_manager_config(Dir, Conf) -> okread_manager_config(Dir) -> Confusers_entry(UserId) -> users_entry()users_entry(UserId, UserMod) -> users_entry()users_entry(UserId, UserMod, UserData) -> users_entry()write_users_config(Dir, Conf) -> okwrite_users_config(Dir, Hdr, Conf) -> okappend_users_config(Dir, Conf) -> okread_users_config(Dir) -> Confagents_entry(UserId, TargetName, Comm, Domain, Addr, EngineID, Timeout, MaxMessageSize, Version, SecModel, SecName, SecLevel) -> agents_entry()write_agents_config(Dir, Conf) -> okwrite_agents_config(Dir, Hdr, Conf) -> okappend_agents_config(Dir, Conf) -> okread_agents_config(Dir) -> Confusm_entry(EngineID, UserName, AuthP, AuthKey, PrivP, PrivKey) -> usm_entry()usm_entry(EngineID, UserName, SecName, AuthP, AuthKey, PrivP, PrivKey) -> usm_entry()write_usm_config(Dir, Conf) -> okwrite_usm_config(Dir, Hdr, Conf) -> okappend_usm_config(Dir, Conf) -> okread_usm_config(Dir) -> Conf"
  ],
  [
    "snmpm_mpd",
    "init_mpd(Vsns) -> mpd_state()process_msg(Msg, Domain, Addr, State, NoteStore, Logger) -> {ok, Vsn, Pdu, PduMS, MsgData} | {discarded, Reason}generate_msg(Vsn, NoteStore, Pdu, MsgData, Logger) -> {ok, Packet} | {discarded, Reason}generate_response_msg(Vsn, Pdu, MsgData, Logger) -> {ok, Packet} | {discarded, Reason}"
  ],
  [
    "snmpm_network_interface",
    "start_link(Server, NoteStore) -> {ok, Pid} | {error, Reason}stop(Pid) -> void()send_pdu(Pid, Pdu, Vsn, MsgData, Domain, Addr, ExtraInfo) -> void()inform_response(Pid, Ref, Addr, Port) -> void()note_store(Pid, NoteStore) -> void()info(Pid) -> [{Key, Value}]verbosity(Pid, Verbosity) -> void()get_log_type(Pid) -> {ok, LogType} | {error, Reason}set_log_type(Pid, NewType) -> {ok, OldType} | {error, Reason}"
  ],
  [
    "snmpm_network_interface_filter",
    "accept_recv(Domain, Addr) -> boolean()accept_send(Domain, Addr) -> boolean()accept_recv_pdu(Domain, Addr, PduType) -> boolean()accept_send_pdu(Domain, Addr, PduType) -> boolean()"
  ],
  [
    "snmpm_user",
    "handle_error(ReqId, Reason, UserData) -> void()handle_agent(Domain, Addr, Type, SnmpInfo, UserData) -> Replyhandle_pdu(TargetName, ReqId, SnmpPduInfo, UserData) -> void()handle_trap(TargetName, SnmpTrapInfo, UserData) -> Replyhandle_inform(TargetName, SnmpInformInfo, UserData) -> Replyhandle_report(TargetName, SnmpReportInfo, UserData) -> Replyhandle_invalid_result(IN, OUT) -> void()"
  ],
  [
    "socket",
    "accept(LSocket) -> {ok, Socket} | {error, Reason}accept(LSocket, Timeout) -> {ok, Socket} | {error, Reason}accept(LSocket, Timeout :: nowait) -> {ok, Socket} | {select, SelectInfo} | {error, Reason}bind(Socket, Addr) -> {ok, Port} | {error, Reason}cancel(Socket, SelectInfo) -> ok | {error, Reason}close(Socket) -> ok | {error, Reason}connect(Socket, SockAddr) -> ok | {error, Reason}connect(Socket, SockAddr, Timeout) -> ok | {error, Reason}connect(Socket, SockAddr, Timeout :: nowait) -> ok | {select, SelectInfo} | {error, Reason}getopt(Socket, Level :: otp, Key :: otp_socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level :: socket, Key :: socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level :: ip, Key :: ip_socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level :: ipv6, Key :: ipv6_socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level :: tcp, Key :: tcp_socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level :: udp, Key :: udp_socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level :: sctp, Key :: sctp_socket_option()) -> {ok, Value} | {error, Reason}getopt(Socket, Level, Key) -> ok | {ok, Value} | {error, Reason}info(Socket) -> socket_info() listen(Socket) -> ok | {error, Reason}listen(Socket, Backlog) -> ok | {error, Reason}open(Domain, Type) -> {ok, Socket} | {error, Reason}open(Domain, Type, Protocol) -> {ok, Socket} | {error, Reason}open(Domain, Type, Protocol, Extra) -> {ok, Socket} | {error, Reason}peername(Socket) -> {ok, SockAddr} | {error, Reason}recv(Socket) -> {ok, Data} | {error, Reason}recv(Socket, Length) -> {ok, Data} | {error, Reason}recv(Socket, Length, Flags) -> {ok, Data} | {error, Reason}recv(Socket, Length, Timeout) -> {ok, Data} | {error, Reason}recv(Socket, Length, Flags, Timeout) -> {ok, Data} | {error, Reason}recv(Socket, Length, Timeout :: nowait) -> {ok, Data} | {select, SelectInfo} | {ok, {Data, SelectInfo}} | {error, Reason}recv(Socket, Length, Flags, Timeout :: nowait) -> {ok, Data} | {select, SelectInfo} | {ok, {Data, SelectInfo}} | {error, Reason}recvfrom(Socket) -> {ok, {Source, Data}} | {error, Reason}recvfrom(Socket, BufSz) -> {ok, {Source, Data}} | {error, Reason}recvfrom(Socket, Flags, Timeout) -> {ok, {Source, Data}} | {error, Reason}recvfrom(Socket, BufSz, Flags) -> {ok, {Source, Data}} | {error, Reason}recvfrom(Socket, BufSz, Timeout) -> {ok, {Source, Data}} | {error, Reason}recvfrom(Socket, BufSz, Flags, Timeout) -> {ok, {Source, Data}} | {error, Reason}recvfrom(Socket, Flags, Timeout :: nowait) -> {ok, {Source, Data}} | {select, SelectInfo} | {error, Reason}recvfrom(Socket, BufSz, Timeout :: nowait) -> {ok, {Source, Data}} | {select, SelectInfo} | {error, Reason}recvfrom(Socket, BufSz, Flags, Timeout :: nowait) -> {ok, {Source, Data}} | {select, SelectInfo} | {error, Reason}recvmsg(Socket) -> {ok, MsgHdr} | {error, Reason}recvmsg(Socket, Flags) -> {ok, MsgHdr} | {error, Reason}recvmsg(Socket, Timeout) -> {ok, MsgHdr} | {error, Reason}recvmsg(Socket, Flags, Timeout) -> {ok, MsgHdr} | {error, Reason}recvmsg(Socket, BufSz, CtrlSz) -> {ok, MsgHdr} | {error, Reason}recvmsg(Socket, BufSz, CtrlSz, Flags, Timeout) -> {ok, MsgHdr} | {error, Reason}recvmsg(Socket, Timeout :: nowait) -> {ok, MsgHdr} | {select, SelectInfo} | {error, Reason}recvmsg(Socket, Flags, Timeout :: nowait) -> {ok, MsgHdr} | {select, SelectInfo} | {error, Reason}recvmsg(Socket, BufSz, CtrlSz, Flags, Timeout :: nowait) -> {ok, MsgHdr} | {select, SelectInfo} | {error, Reason}send(Socket, Data) -> ok | {error, Reason}send(Socket, Data, Flags) -> ok | {error, Reason}send(Socket, Data, Timeout) -> ok | {error, Reason}send(Socket, Data, Flags, Timeout) -> ok | {error, Reason}send(Socket, Data, Timeout :: nowait) -> ok | {select, SelectInfo} | {ok, {RestData, SelectInfo}} | {error, Reason}send(Socket, Data, Flags, Timeout :: nowait) -> ok | {select, SelectInfo} | {ok, {RestData, SelectInfo}} | {error, Reason}sendmsg(Socket, MsgHdr) -> ok | {error, Reason}sendmsg(Socket, MsgHdr, Flags) -> ok | {error, Reason}sendmsg(Socket, MsgHdr, Timeout) -> ok | {error, Reason}sendmsg(Socket, MsgHdr, Flags, Timeout) -> ok | {ok, Remaining} | {error, Reason}sendmsg(Socket, MsgHdr, Timeout :: nowait) -> ok | {select, SelectInfo} | {error, Reason}sendmsg(Socket, MsgHdr, Flags, Timeout :: nowait) -> ok | {ok, Remaining} | {select, SelectInfo} | {error, Reason}sendto(Socket, Data, Dest) -> ok | {error, Reason}sendto(Socket, Data, Dest, Flags) -> ok | {error, Reason}sendto(Socket, Data, Dest, Timeout) -> ok | {error, Reason}sendto(Socket, Data, Dest, Flags, Timeout) -> ok | {error, Reason}sendto(Socket, Data, Dest, Timeout :: nowait) -> ok | {select, SelectInfo} | {error, Reason}sendto(Socket, Data, Dest, Flags, Timeout :: nowait) -> ok | {select, SelectInfo} | {error, Reason}setopt(Socket, Level :: otp, Key :: otp_socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level :: socket, Key :: socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level :: ip, Key :: ip_socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level :: ipv6, Key :: ipv6_socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level :: tcp, Key :: tcp_socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level :: udp, Key :: udp_socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level :: sctp, Key :: sctp_socket_option(), Value) -> ok | {error, Reason}setopt(Socket, Level, Key, Value) -> ok | {error, Reason}shutdown(Socket, How) -> ok | {error, Reason}sockname(Socket) -> {ok, SockAddr} | {error, Reason}supports() -> [{options, supports_options()} | {sctp, boolean()} | {ipv6, boolean()} | {local, boolean()} | {send_flags, supports_send_flags()} | {recv_flags, supports_recv_flags()}]supports(Key1 :: options) -> supports_options() supports(Key1 :: sctp) -> boolean()supports(Key1 :: ipv6) -> boolean()supports(Key1 :: local) -> boolean()supports(Key1 :: send_flags) -> supports_send_flags() supports(Key1 :: recv_flags) -> supports_recv_flags() supports(Key1) -> falsesupports(Key1 :: options, Level :: socket) -> supports_options_socket() supports(Key1 :: options, Level :: ip) -> supports_options_ip() supports(Key1 :: options, Level :: ipv6) -> supports_options_ipv6() supports(Key1 :: options, Level :: tcp) -> supports_options_tcp() supports(Key1 :: options, Level :: udp) -> supports_options_udp() supports(Key1 :: options, Level :: sctp) -> supports_options_sctp() supports(Key1 :: send_flags, SendFlag :: send_flag()) -> boolean()supports(Key1 :: recv_flags, RecvFlag :: recv_flag()) -> boolean()supports(Key1, Key2) -> falsesupports(Key1 :: options, Level :: socket, Opt :: socket_option()) -> boolean()supports(Key1 :: options, Level :: ip, Opt :: ip_socket_option()) -> boolean()supports(Key1 :: options, Level :: ipv6, Opt :: ipv6_socket_option()) -> boolean()supports(Key1 :: options, Level :: tcp, Opt :: tcp_socket_option()) -> boolean()supports(Key1 :: options, Level :: udp, Opt :: udp_socket_option()) -> boolean()supports(Key1 :: options, Level :: sctp, Opt :: sctp_socket_option()) -> boolean()supports(Key1, Key2, Key3) -> false"
  ],
  [
    "sofs",
    "a_function(Tuples) -> Functiona_function(Tuples, Type) -> Functioncanonical_relation(SetOfSets) -> BinRelcomposite(Function1, Function2) -> Function3constant_function(Set, AnySet) -> Functionconverse(BinRel1) -> BinRel2difference(Set1, Set2) -> Set3digraph_to_family(Graph) -> Familydigraph_to_family(Graph, Type) -> Familydomain(BinRel) -> Setdrestriction(BinRel1, Set) -> BinRel2drestriction(SetFun, Set1, Set2) -> Set3empty_set() -> Setextension(BinRel1, Set, AnySet) -> BinRel2family(Tuples) -> Familyfamily(Tuples, Type) -> Familyfamily_difference(Family1, Family2) -> Family3family_domain(Family1) -> Family2family_field(Family1) -> Family2family_intersection(Family1) -> Family2family_intersection(Family1, Family2) -> Family3family_projection(SetFun, Family1) -> Family2family_range(Family1) -> Family2family_specification(Fun, Family1) -> Family2family_to_digraph(Family) -> Graphfamily_to_digraph(Family, GraphType) -> Graphfamily_to_relation(Family) -> BinRelfamily_union(Family1) -> Family2family_union(Family1, Family2) -> Family3field(BinRel) -> Setfrom_external(ExternalSet, Type) -> AnySetfrom_sets(ListOfSets) -> Setfrom_sets(TupleOfSets) -> Ordsetfrom_term(Term) -> AnySetfrom_term(Term, Type) -> AnySetimage(BinRel, Set1) -> Set2intersection(SetOfSets) -> Setintersection(Set1, Set2) -> Set3intersection_of_family(Family) -> Setinverse(Function1) -> Function2inverse_image(BinRel, Set1) -> Set2is_a_function(BinRel) -> Boolis_disjoint(Set1, Set2) -> Boolis_empty_set(AnySet) -> Boolis_equal(AnySet1, AnySet2) -> Boolis_set(AnySet) -> Boolis_sofs_set(Term) -> Boolis_subset(Set1, Set2) -> Boolis_type(Term) -> Booljoin(Relation1, I, Relation2, J) -> Relation3multiple_relative_product(TupleOfBinRels, BinRel1) -> BinRel2no_elements(ASet) -> NoElementspartition(SetOfSets) -> Partitionpartition(SetFun, Set) -> Partitionpartition(SetFun, Set1, Set2) -> {Set3, Set4}partition_family(SetFun, Set) -> Familyproduct(TupleOfSets) -> Relationproduct(Set1, Set2) -> BinRelprojection(SetFun, Set1) -> Set2range(BinRel) -> Setrelation(Tuples) -> Relationrelation(Tuples, Type) -> Relationrelation_to_family(BinRel) -> Familyrelative_product(ListOfBinRels) -> BinRel2relative_product(ListOfBinRels, BinRel1) -> BinRel2relative_product(BinRel1, BinRel2) -> BinRel3relative_product1(BinRel1, BinRel2) -> BinRel3restriction(BinRel1, Set) -> BinRel2restriction(SetFun, Set1, Set2) -> Set3set(Terms) -> Setset(Terms, Type) -> Setspecification(Fun, Set1) -> Set2strict_relation(BinRel1) -> BinRel2substitution(SetFun, Set1) -> Set2symdiff(Set1, Set2) -> Set3symmetric_partition(Set1, Set2) -> {Set3, Set4, Set5}to_external(AnySet) -> ExternalSetto_sets(ASet) -> Setstype(AnySet) -> Typeunion(SetOfSets) -> Setunion(Set1, Set2) -> Set3union_of_family(Family) -> Setweak_relation(BinRel1) -> BinRel2"
  ],
  [
    "ssh",
    "close(ConnectionRef) -> ok | {error, term()}connection_info(ConnectionRef) -> InfoTupleListconnection_info(ConnectionRef, Key :: ItemList | Item) -> InfoTupleList | InfoTupledaemon_info(DaemonRef) -> {ok, InfoTupleList} | {error, bad_daemon_ref}daemon_info(DaemonRef, Key :: ItemList | Item) -> InfoTupleList | InfoTuple | {error, bad_daemon_ref}default_algorithms() -> algs_list() start() -> ok | {error, term()}start(Type) -> ok | {error, term()}stop() -> ok | {error, term()}stop_daemon(DaemonRef :: daemon_ref()) -> okstop_daemon(Address :: inet:ip_address(), Port :: inet:port_number()) -> okstop_daemon(Address :: any | inet:ip_address(), Port :: inet:port_number(), Profile :: atom()) -> okstop_listener(SysSup :: daemon_ref()) -> okstop_listener(Address :: inet:ip_address(), Port :: inet:port_number()) -> okstop_listener(Address :: any | inet:ip_address(), Port :: inet:port_number(), Profile :: term()) -> ok",
    "connect(Host, Port, Options) -> Result connect(Host, Port, Options, NegotiationTimeout) -> Result connect(TcpSocket, Options) -> Resultconnect(TcpSocket, Options, NegotiationTimeout) -> Resultdaemon(Port | TcpSocket) -> Resultdaemon(Port | TcpSocket, Options) -> Resultdaemon(HostAddress, Port, Options) -> Resultshell(Host | TcpSocket) -> Result shell(Host | TcpSocket, Options) -> Result shell(Host, Port, Options) -> Result "
  ],
  ["SSH_app"],
  [
    "ssh_client_channel",
    "call(ChannelRef, Msg) ->call(ChannelRef, Msg, Timeout) -> Reply | {error, Reason}cast(ChannelRef, Msg) -> ok enter_loop(State) -> _ init(Options) -> {ok, State} | {ok, State, Timeout} | {stop, Reason} reply(Client, Reply) -> _start(SshConnection, ChannelId, ChannelCb, CbInitArgs) -> start_link(SshConnection, ChannelId, ChannelCb, CbInitArgs) -> {ok, ChannelRef} | {error, Reason}Module:code_change(OldVsn, State, Extra) -> {ok, NewState}Module:init(Args) -> {ok, State} | {ok, State, timeout()} | {stop, Reason}Module:handle_call(Msg, From, State) -> ResultModule:handle_cast(Msg, State) -> ResultModule:handle_msg(Msg, State) -> {ok, State} | {stop, ChannelId, State}Module:handle_ssh_msg(Msg, State) -> {ok, State} | {stop, ChannelId, State}Module:terminate(Reason, State) -> _"
  ],
  [
    "ssh_client_key_api",
    "Module:add_host_key(HostNames, PublicHostKey, ConnectOptions) -> ok | {error, Reason}Module:is_host_key(Key, Host, Algorithm, ConnectOptions) -> ResultModule:user_key(Algorithm, ConnectOptions) -> {ok, PrivateKey} | {error, Reason}"
  ],
  [
    "ssh_connection",
    "adjust_window(ConnectionRef, ChannelId, NumOfBytes) -> okclose(ConnectionRef, ChannelId) -> okexec(ConnectionRef, ChannelId, Command, Timeout) -> result() exit_status(ConnectionRef, ChannelId, Status) -> okptty_alloc(ConnectionRef, ChannelId, Options) -> result() ptty_alloc(ConnectionRef, ChannelId, Options, Timeout) -> result() reply_request(ConnectionRef, WantReply, Status, ChannelId) -> oksend_eof(ConnectionRef, ChannelId) -> ok | {error, closed}session_channel(ConnectionRef, Timeout) -> Resultsession_channel(ConnectionRef, InitialWindowSize, MaxPacketSize, Timeout) -> Resultsetenv(ConnectionRef, ChannelId, Var, Value, Timeout) -> result() shell(ConnectionRef, ChannelId) -> Resultsubsystem(ConnectionRef, ChannelId, Subsystem, Timeout) -> result()",
    "send(ConnectionRef, ChannelId, Data) ->send(ConnectionRef, ChannelId, Data, Timeout) ->send(ConnectionRef, ChannelId, Type, Data) ->send(ConnectionRef, ChannelId, Type, Data, TimeOut) -> ok | Error"
  ],
  [
    "ssh_file",
    "host_key(Algorithm, DaemonOptions) -> {ok, Key} | {error, Reason}is_auth_key(PublicUserKey, User, DaemonOptions) -> Resultadd_host_key(HostNames, PublicHostKey, ConnectOptions) -> ok | {error, Reason}is_host_key(Key, Host, Algorithm, ConnectOptions) -> Resultuser_key(Algorithm, ConnectOptions) -> {ok, PrivateKey} | {error, Reason}"
  ],
  [
    "ssh_server_channel",
    "Module:init(Args) -> {ok, State} | {ok, State, timeout()} | {stop, Reason}Module:handle_msg(Msg, State) -> {ok, State} | {stop, ChannelId, State}Module:handle_ssh_msg(Msg, State) -> {ok, State} | {stop, ChannelId, State}Module:terminate(Reason, State) -> _"
  ],
  [
    "ssh_server_key_api",
    "Module:host_key(Algorithm, DaemonOptions) -> {ok, Key} | {error, Reason}Module:is_auth_key(PublicUserKey, User, DaemonOptions) -> Result"
  ],
  [
    "ssh_sftp",
    "apread(ChannelPid, Handle, Position, Len) -> {async, N} | Errorapwrite(ChannelPid, Handle, Position, Data) -> {async, N} | Erroraread(ChannelPid, Handle, Len) -> {async, N} | Errorawrite(ChannelPid, Handle, Data) -> {async, N} | Errorclose(ChannelPid, Handle) -> ok | Errorclose(ChannelPid, Handle, Timeout) -> ok | Errordelete(ChannelPid, Name) -> ok | Errordelete(ChannelPid, Name, Timeout) -> ok | Errordel_dir(ChannelPid, Name) -> ok | Errordel_dir(ChannelPid, Name, Timeout) -> ok | Errorlist_dir(ChannelPid, Path) -> {ok, FileNames} | Errorlist_dir(ChannelPid, Path, Timeout) -> {ok, FileNames} | Errormake_dir(ChannelPid, Name) -> ok | Errormake_dir(ChannelPid, Name, Timeout) -> ok | Errormake_symlink(ChannelPid, Name, Target) -> ok | Errormake_symlink(ChannelPid, Name, Target, Timeout) -> ok | Erroropen(ChannelPid, Name, Mode) -> {ok, Handle} | Erroropen(ChannelPid, Name, Mode, Timeout) -> {ok, Handle} | Erroropendir(ChannelPid, Path) -> {ok, Handle} | Erroropendir(ChannelPid, Path, Timeout) -> {ok, Handle} | Erroropen_tar(ChannelPid, Path, Mode) -> {ok, Handle} | Erroropen_tar(ChannelPid, Path, Mode, Timeout) -> {ok, Handle} | Errorposition(ChannelPid, Handle, Location) -> {ok, NewPosition} | Errorposition(ChannelPid, Handle, Location, Timeout) -> {ok, NewPosition} | Errorpread(ChannelPid, Handle, Position, Len) -> {ok, Data} | eof | Errorpread(ChannelPid, Handle, Position, Len, Timeout) -> {ok, Data} | eof | Errorpwrite(ChannelPid, Handle, Position, Data) -> ok | Errorpwrite(ChannelPid, Handle, Position, Data, Timeout) -> ok | Errorread(ChannelPid, Handle, Len) -> {ok, Data} | eof | Errorread(ChannelPid, Handle, Len, Timeout) -> {ok, Data} | eof | Errorread_file(ChannelPid, File) -> {ok, Data} | Errorread_file(ChannelPid, File, Timeout) -> {ok, Data} | Errorread_file_info(ChannelPid, Name) -> {ok, FileInfo} | Errorread_file_info(ChannelPid, Name, Timeout) -> {ok, FileInfo} | Errorread_link(ChannelPid, Name) -> {ok, Target} | Errorread_link(ChannelPid, Name, Timeout) -> {ok, Target} | Errorread_link_info(ChannelPid, Name) -> {ok, FileInfo} | Errorread_link_info(ChannelPid, Name, Timeout) -> {ok, FileInfo} | Errorrename(ChannelPid, OldName, NewName) -> ok | Errorrename(ChannelPid, OldName, NewName, Timeout) -> ok | Errorstop_channel(ChannelPid) -> okwrite(ChannelPid, Handle, Data) -> ok | Errorwrite(ChannelPid, Handle, Data, Timeout) -> ok | Errorwrite_file(ChannelPid, File, Data) -> ok | Errorwrite_file(ChannelPid, File, Data, Timeout) -> ok | Errorwrite_file_info(ChannelPid, Name, FileInfo) -> ok | Errorwrite_file_info(ChannelPid, Name, FileInfo, Timeout) -> ok | Error",
    "start_channel(ConnectionRef) ->start_channel(ConnectionRef, SftpOptions) -> {ok, ChannelPid} | Errorstart_channel(Host) ->start_channel(Host, Options) ->start_channel(Host, Port, Options) ->start_channel(TcpSocket) ->start_channel(TcpSocket, Options) -> {ok, ChannelPid, ConnectionRef} | Error"
  ],
  ["ssh_sftpd", "subsystem_spec(Options) -> Spec"],
  [
    "ssl",
    "append_cipher_suites(Deferred, Suites) -> ciphers() cipher_suites() -> [old_cipher_suite()] | [string()]cipher_suites(Type) -> [old_cipher_suite() | string()]cipher_suites(Supported, Version) -> ciphers() cipher_suites(Supported, Version, StringType :: rfc | openssl) -> [string()]eccs() -> NamedCurveseccs(Version) -> NamedCurvesclear_pem_cache() -> okconnect(TCPSocket, TLSOptions) -> {ok, sslsocket()} | {error, reason()} | {option_not_a_key_value_tuple, any()}connect(TCPSocket, TLSOptions, Timeout) -> {ok, sslsocket()} | {error, reason()}connect(Host, Port, TLSOptions) -> {ok, sslsocket()} | {ok, sslsocket(), Ext :: protocol_extensions()} | {error, reason()} | {option_not_a_key_value_tuple, any()}connect(Host, Port, TLSOptions, Timeout) -> {ok, sslsocket()} | {ok, sslsocket(), Ext :: protocol_extensions()} | {error, reason()} | {option_not_a_key_value_tuple, any()}close(SslSocket) -> ok | {error, Reason}close(SslSocket, How) -> ok | {ok, port()} | {error, Reason}controlling_process(SslSocket, NewOwner) -> ok | {error, Reason}connection_information(SslSocket) -> {ok, Result} | {error, reason()}connection_information(SslSocket, Items) -> {ok, Result} | {error, reason()}filter_cipher_suites(Suites, Filters) -> Ciphersformat_error(Reason :: {error, Reason}) -> string()getopts(SslSocket, OptionNames) -> {ok, [gen_tcp:option()]} | {error, reason()}getstat(SslSocket) -> {ok, OptionValues} | {error, inet:posix()}getstat(SslSocket, Options) -> {ok, OptionValues} | {error, inet:posix()}handshake(HsSocket) -> {ok, SslSocket} | {ok, SslSocket, Ext} | {error, Reason}handshake(HsSocket, Timeout) -> {ok, SslSocket} | {ok, SslSocket, Ext} | {error, Reason}handshake(Socket, Options) -> {ok, SslSocket} | {ok, SslSocket, Ext} | {error, Reason}handshake(Socket, Options, Timeout) -> {ok, SslSocket} | {ok, SslSocket, Ext} | {error, Reason}handshake_cancel(Sslsocket :: #sslsocket{}) -> any()handshake_continue(HsSocket, Options) -> {ok, SslSocket} | {error, Reason}handshake_continue(HsSocket, Options, Timeout) -> {ok, SslSocket} | {error, Reason}listen(Port, Options) -> {ok, ListenSocket} | {error, reason()}negotiated_protocol(SslSocket) -> {ok, Protocol} | {error, Reason}peercert(SslSocket) -> {ok, Cert} | {error, reason()}peername(SslSocket) -> {ok, {Address, Port}} | {error, reason()}prepend_cipher_suites(Preferred, Suites) -> ciphers() prf(SslSocket, Secret, Label, Seed, WantedLength) -> {ok, binary()} | {error, reason()}recv(SslSocket, Length) -> {ok, Data} | {error, reason()}recv(SslSocket, Length, Timeout) -> {ok, Data} | {error, reason()}renegotiate(SslSocket) -> ok | {error, reason()}send(SslSocket, Data) -> ok | {error, reason()}setopts(SslSocket, Options) -> ok | {error, reason()}shutdown(SslSocket, How) -> ok | {error, reason()}ssl_accept(SslSocket) -> ok | {error, Reason}ssl_accept(Socket, TimeoutOrOptions) -> ok | {ok, sslsocket()} | {error, Reason}ssl_accept(Socket, Options, Timeout) -> ok | {ok, sslsocket()} | {error, Reason}sockname(SslSocket) -> {ok, {Address, Port}} | {error, reason()}start() -> ok | {error, reason()}stop() -> okstr_to_suite(CipherSuiteName) -> erl_cipher_suite() suite_to_openssl_str(CipherSuite) -> string()suite_to_str(CipherSuite) -> string()transport_accept(ListenSocket) -> {ok, SslSocket} | {error, reason()}transport_accept(ListenSocket, Timeout) -> {ok, SslSocket} | {error, reason()}versions() -> [VersionInfo]",
    "start(Type) -> ok | {error, Reason}"
  ],
  ["ssl_app"],
  [
    "ssl_crl_cache",
    "delete(Entries) -> ok | {error, Reason} insert(CRLSrc) -> ok | {error, Reason}insert(URI, CRLSrc) -> ok | {error, Reason}"
  ],
  [
    "ssl_crl_cache_api",
    "fresh_crl(DistributionPoint, CRL) -> FreshCRL fresh_crl(DistributionPoint, CRL) -> FreshCRL | {LoggerInfo, FreshCRL}lookup(DistributionPoint, Issuer, DbHandle) -> not_available | CRLs | {LoggerInfo, CRLs} lookup(DistributionPoint, Issuer, DbHandle) -> not_available | CRLs lookup(DistributionPoint, DbHandle) -> not_available | CRLs select(Issuer, DbHandle) -> CRLs | {LoggerInfo, CRLs} select(Issuer, DbHandle) -> CRLs "
  ],
  [
    "ssl_session_cache_api",
    "delete(Cache, Key) -> _foldl(Fun, Acc0, Cache) -> Accinit(Args) -> Cache lookup(Cache, Key) -> Entryselect_session(Cache, PartialKey) -> [Session]size(Cache) -> integer()terminate(Cache) -> _update(Cache, Key, Session) -> _"
  ],
  ["start"],
  ["start_erl"],
  ["STDLIB_app"],
  [
    "string",
    "casefold(String :: unicode:chardata()) -> unicode:chardata() chomp(String :: unicode:chardata()) -> unicode:chardata() equal(A, B) -> boolean()equal(A, B, IgnoreCase) -> boolean()equal(A, B, IgnoreCase, Norm) -> boolean()find(String, SearchPattern) -> unicode:chardata() | nomatchfind(String, SearchPattern, Dir) -> unicode:chardata() | nomatchis_empty(String :: unicode:chardata()) -> boolean()length(String :: unicode:chardata()) -> integer() >= 0lexemes(String :: unicode:chardata(), SeparatorList :: [grapheme_cluster()]) -> [unicode:chardata()]lowercase(String :: unicode:chardata()) -> unicode:chardata() next_codepoint(String :: unicode:chardata()) -> maybe_improper_list(char(), unicode:chardata()) | {error, unicode:chardata()}next_grapheme(String :: unicode:chardata()) -> maybe_improper_list(grapheme_cluster(), unicode:chardata()) | {error, unicode:chardata()}nth_lexeme(String, N, SeparatorList) -> unicode:chardata() pad(String, Length) -> unicode:charlist() pad(String, Length, Dir) -> unicode:charlist() pad(String, Length, Dir, Char) -> unicode:charlist() prefix(String :: unicode:chardata(), Prefix :: unicode:chardata()) -> nomatch | unicode:chardata() replace(String, SearchPattern, Replacement) -> [unicode:chardata()]replace(String, SearchPattern, Replacement, Where) -> [unicode:chardata()]reverse(String :: unicode:chardata()) -> [grapheme_cluster()]slice(String, Start) -> Sliceslice(String, Start, Length) -> Slicesplit(String, SearchPattern) -> [unicode:chardata()]split(String, SearchPattern, Where) -> [unicode:chardata()]take(String, Characters) -> {Leading, Trailing}take(String, Characters, Complement) -> {Leading, Trailing}take(String, Characters, Complement, Dir) -> {Leading, Trailing}titlecase(String :: unicode:chardata()) -> unicode:chardata() to_float(String) -> {Float, Rest} | {error, Reason}to_integer(String) -> {Int, Rest} | {error, Reason}to_graphemes(String :: unicode:chardata()) -> [grapheme_cluster()]trim(String) -> unicode:chardata() trim(String, Dir) -> unicode:chardata() trim(String, Dir, Characters) -> unicode:chardata() uppercase(String :: unicode:chardata()) -> unicode:chardata() centre(String, Number) -> Centeredcentre(String, Number, Character) -> Centeredchars(Character, Number) -> Stringchars(Character, Number, Tail) -> Stringchr(String, Character) -> Indexconcat(String1, String2) -> String3copies(String, Number) -> Copiescspan(String, Chars) -> Lengthjoin(StringList, Separator) -> Stringleft(String, Number) -> Leftleft(String, Number, Character) -> Leftlen(String) -> Lengthrchr(String, Character) -> Indexright(String, Number) -> Rightright(String, Number, Character) -> Rightrstr(String, SubString) -> Indexspan(String, Chars) -> Lengthstr(String, SubString) -> Indexstrip(String :: string()) -> string()strip(String, Direction) -> Strippedstrip(String, Direction, Character) -> Strippedsub_string(String, Start) -> SubStringsub_string(String, Start, Stop) -> SubStringsubstr(String, Start) -> SubStringsubstr(String, Start, Length) -> SubStringsub_word(String, Number) -> Wordsub_word(String, Number, Character) -> Wordto_lower(String) -> Resultto_lower(Char) -> CharResultto_upper(String) -> Resultto_upper(Char) -> CharResulttokens(String, SeparatorList) -> Tokenswords(String) -> Countwords(String, Character) -> Count"
  ],
  [
    "supervisor",
    "check_childspecs(ChildSpecs) -> Resultcount_children(SupRef) -> PropListOfCountsdelete_child(SupRef, Id) -> Resultget_childspec(SupRef, Id) -> Resultrestart_child(SupRef, Id) -> Resultstart_child(SupRef, ChildSpec) -> startchild_ret()start_link(Module, Args) -> startlink_ret()start_link(SupName, Module, Args) -> startlink_ret()terminate_child(SupRef, Id) -> Resultwhich_children(SupRef) -> [{Id, Child, Type, Modules}]",
    "Module:init(Args) -> Result"
  ],
  [
    "supervisor_bridge",
    "start_link(Module, Args) -> Resultstart_link(SupBridgeName, Module, Args) -> Result",
    "Module:init(Args) -> ResultModule:terminate(Reason, State)"
  ],
  [
    "sys",
    "change_code(Name, Module, OldVsn, Extra) -> ok | {error, Reason}change_code(Name, Module, OldVsn, Extra, Timeout) -> ok | {error, Reason}get_state(Name) -> Stateget_state(Name, Timeout) -> Stateget_status(Name) -> Statusget_status(Name, Timeout) -> Statusinstall(Name, FuncSpec) -> okinstall(Name, FuncSpec, Timeout) -> oklog(Name, Flag) -> ok | {ok, [system_event()]}log(Name, Flag, Timeout) -> ok | {ok, [system_event()]}log_to_file(Name, Flag) -> ok | {error, open_file}log_to_file(Name, Flag, Timeout) -> ok | {error, open_file}no_debug(Name) -> okno_debug(Name, Timeout) -> okremove(Name, FuncOrFuncId :: Func | FuncId) -> okremove(Name, FuncOrFuncId :: Func | FuncId, Timeout) -> okreplace_state(Name, StateFun) -> NewStatereplace_state(Name, StateFun, Timeout) -> NewStateresume(Name) -> okresume(Name, Timeout) -> okstatistics(Name, Flag) -> ok | {ok, Statistics}statistics(Name, Flag, Timeout) -> ok | {ok, Statistics}suspend(Name) -> oksuspend(Name, Timeout) -> okterminate(Name, Reason) -> okterminate(Name, Reason, Timeout) -> oktrace(Name, Flag) -> oktrace(Name, Flag, Timeout) -> okdebug_options(Options :: [Opt :: debug_option()]) -> [dbg_opt()]get_debug(Item, Debug, Default) -> term()handle_debug(Debug, FormFunc, Extra, Event) -> [dbg_opt()]handle_system_msg(Msg, From, Parent, Module, Debug, Misc) -> no_return()print_log(Debug) -> okget_log(Debug) -> [system_event()]",
    "Module:system_code_change(Misc, Module, OldVsn, Extra) -> {ok, NMisc}Module:system_continue(Parent, Debug, Misc) -> none()Module:system_get_state(Misc) -> {ok, State}Module:system_replace_state(StateFun, Misc) -> {ok, NState, NMisc}Module:system_terminate(Reason, Parent, Debug, Misc) -> none()"
  ],
  [
    "system_information",
    "sanity_check() -> ok | {failed, Failures}to_file(FileName) -> ok | {error, Reason}"
  ],
  [
    "systools",
    "make_relup(Name, UpFrom, DownTo) -> Resultmake_relup(Name, UpFrom, DownTo, [Opt]) -> Resultmake_script(Name) -> Resultmake_script(Name, [Opt]) -> Resultmake_tar(Name) -> Resultmake_tar(Name, [Opt]) -> Resultscript2boot(File) -> ok | error"
  ],
  [
    "tags",
    "file(File [, Options])files(FileList [, Options])dir(Dir [, Options])dirs(DirList [, Options])subdir(Dir [, Options])subdirs(DirList [, Options])root([Options])"
  ],
  [
    "tftp",
    "change_config(daemons, Options) -> [{Pid, Result}]change_config(servers, Options) -> [{Pid, Result}]change_config(Pid, Options) -> Resultinfo(daemons) -> [{Pid, Options}]info(servers) -> [{Pid, Options}]info(Pid) -> {ok, Options} | {error, Reason}read_file(RemoteFilename, LocalFilename, Options) -> {ok, LastCallbackState} | {error, Reason}start(Options) -> {ok, Pid} | {error, Reason}write_file(RemoteFilename, LocalFilename, Options) -> {ok, LastCallbackState} | {error, Reason}Module:abort(Code, Text, State) -> okModule:open(Peer, Access, Filename, Mode, SuggestedOptions, State) -> {ok, AcceptedOptions, NewState} | {error, {Code, Text}}Module:prepare(Peer, Access, Filename, Mode, SuggestedOptions, InitialState) -> {ok, AcceptedOptions, NewState} | {error, {Code, Text}}Module:read(State) -> {more, Bin, NewState} | {last, Bin, FileSize} | {error, {Code, Text}}Module:write(Bin, State) -> {more, NewState} | {last, FileSize} | {error, {Code, Text}}Logger:error_msg(Format, Data) -> ok | exit(Reason)Logger:info_msg(Format, Data) -> ok | exit(Reason)Logger:warning_msg(Format, Data) -> ok | exit(Reason)"
  ],
  [
    "timer",
    "apply_after(Time, Module, Function, Arguments) -> {ok, TRef} | {error, Reason}apply_interval(Time, Module, Function, Arguments) -> {ok, TRef} | {error, Reason}cancel(TRef) -> {ok, cancel} | {error, Reason}exit_after(Time, Reason1) -> {ok, TRef} | {error, Reason2}exit_after(Time, Pid, Reason1) -> {ok, TRef} | {error, Reason2}hms(Hours, Minutes, Seconds) -> MilliSecondshours(Hours) -> MilliSecondskill_after(Time) -> {ok, TRef} | {error, Reason2}kill_after(Time, Pid) -> {ok, TRef} | {error, Reason2}minutes(Minutes) -> MilliSecondsnow_diff(T2, T1) -> Tdiffseconds(Seconds) -> MilliSecondssend_after(Time, Message) -> {ok, TRef} | {error, Reason}send_after(Time, Pid, Message) -> {ok, TRef} | {error, Reason}send_interval(Time, Message) -> {ok, TRef} | {error, Reason}send_interval(Time, Pid, Message) -> {ok, TRef} | {error, Reason}sleep(Time) -> okstart() -> oktc(Fun) -> {Time, Value}tc(Fun, Arguments) -> {Time, Value}tc(Module, Function, Arguments) -> {Time, Value}"
  ],
  [
    "ttb",
    "start_trace(Nodes, Patterns, FlagSpec, Opts) -> Resulttracer() -> Resulttracer(Shortcut) -> Resulttracer(Nodes) -> Resulttracer(Nodes,Opts) -> Resultp(Item,Flags) -> Returntp, tpl, ctp, ctpl, ctpgtpe, ctpelist_history() -> Historyrun_history(N) -> ok | {error, Reason}write_config(ConfigFile,Config)write_config(ConfigFile,Config,Opts) -> ok | {error,Reason}run_config(ConfigFile) -> ok | {error,Reason}run_config(ConfigFile,NumList) -> ok | {error,Reason}list_config(ConfigFile) -> Config | {error,Reason}write_trace_info(Key,Info) -> okseq_trigger_ms() -> MatchSpecseq_trigger_ms(Flags) -> MatchSpecstop()stop(Opts) -> stopped | {stopped, Dir}get_et_handler()format(File)format(File,Options) -> ok | {error, Reason}"
  ],
  ["typer"],
  [
    "unicode",
    "bom_to_encoding(Bin) -> {Encoding, Length}characters_to_binary(Data) -> Resultcharacters_to_binary(Data, InEncoding) -> Resultcharacters_to_binary(Data, InEncoding, OutEncoding) -> Resultcharacters_to_list(Data) -> Resultcharacters_to_list(Data, InEncoding) -> Resultcharacters_to_nfc_list(CD :: chardata()) -> [char()] | {error, [char()], chardata()}characters_to_nfc_binary(CD :: chardata()) -> unicode_binary() | {error, unicode_binary(), chardata()}characters_to_nfd_list(CD :: chardata()) -> [char()] | {error, [char()], chardata()}characters_to_nfd_binary(CD :: chardata()) -> unicode_binary() | {error, unicode_binary(), chardata()}characters_to_nfkc_list(CD :: chardata()) -> [char()] | {error, [char()], chardata()}characters_to_nfkc_binary(CD :: chardata()) -> unicode_binary() | {error, unicode_binary(), chardata()}characters_to_nfkd_list(CD :: chardata()) -> [char()] | {error, [char()], chardata()}characters_to_nfkd_binary(CD :: chardata()) -> unicode_binary() | {error, unicode_binary(), chardata()}encoding_to_bom(InEncoding) -> Bin"
  ],
  [
    "unix_telnet",
    "connect(ConnName, Ip, Port, Timeout, KeepAlive, TCPNoDelay, Extra) -> {ok, Handle} | {error, Reason}get_prompt_regexp() -> PromptRegexp"
  ],
  [
    "uri_string",
    "compose_query(QueryList) -> QueryStringcompose_query(QueryList, Options) -> QueryStringdissect_query(QueryString) -> QueryListnormalize(URI) -> NormalizedURInormalize(URI, Options) -> NormalizedURIparse(URIString) -> URIMaprecompose(URIMap) -> URIStringtranscode(URIString, Options) -> Result"
  ],
  ["user"],
  ["werl"],
  [
    "win32reg",
    "change_key(RegHandle, Key) -> ReturnValuechange_key_create(RegHandle, Key) -> ReturnValueclose(RegHandle) -> okcurrent_key(RegHandle) -> ReturnValuedelete_key(RegHandle) -> ReturnValuedelete_value(RegHandle, Name) -> ReturnValueexpand(String) -> ExpandedStringformat_error(ErrorId) -> ErrorStringopen(OpenModeList) -> ReturnValueset_value(RegHandle, Name, Value) -> ReturnValuesub_keys(RegHandle) -> ReturnValuevalue(RegHandle, Name) -> ReturnValuevalues(RegHandle) -> ReturnValue"
  ],
  [
    "wrap_log_reader",
    "chunk(Continuation) -> chunk_ret()chunk(Continuation, N) -> chunk_ret()close(Continuation) -> ok | {error, Reason}open(Filename) -> open_ret()open(Filename, N) -> open_ret()"
  ],
  [
    "wx",
    "parent_class(X1) -> term()new() -> wx_object()new(Options::[Option]) -> wx_object()destroy() -> okget_env() -> wx_env()set_env(Wx_env::wx_env()) -> oknull() -> wx_object()is_null(Wx_ref::wx_object()) -> boolean()equal(Wx_ref::wx_object(), X2::wx_object()) -> boolean()getObjectType(Wx_ref::wx_object()) -> atom()typeCast(Old::wx_object(), NewType::atom()) -> wx_object()batch(Fun::function()) -> term()foreach(Fun::function(), List::list()) -> okmap(Fun::function(), List::list()) -> list()foldl(Fun::function(), Acc::term(), List::list()) -> term()foldr(Fun::function(), Acc::term(), List::list()) -> term()create_memory(Size::integer()) -> wx_memory()get_memory_bin(Wx_mem::wx_memory()) -> binary()retain_memory(Wx_mem::wx_memory()) -> okrelease_memory(Wx_mem::wx_memory()) -> okdebug(Debug::Level | [Level]) -> okdemo() -> ok | {error, atom()}"
  ],
  [
    "wx_misc",
    "getKeyState(Key) -> boolean()getMousePosition() -> {X::integer(), Y::integer()}getMouseState() -> wx:wx_wxMouseState()setDetectableAutoRepeat(Flag) -> boolean()bell() -> okfindMenuItemId(Frame, MenuString, ItemString) -> integer()genericFindWindowAtPoint(Pt) -> wxWindow:wxWindow()findWindowAtPoint(Pt) -> wxWindow:wxWindow()beginBusyCursor() -> okbeginBusyCursor(Options::[Option]) -> okendBusyCursor() -> okisBusy() -> boolean()shutdown(WFlags) -> boolean()shell() -> boolean()shell(Options::[Option]) -> boolean()launchDefaultBrowser(Url) -> boolean()launchDefaultBrowser(Url, Options::[Option]) -> boolean()getEmailAddress() -> unicode:charlist()getUserId() -> unicode:charlist()getHomeDir() -> unicode:charlist()newId() -> integer()registerId(Id) -> okgetCurrentId() -> integer()getOsDescription() -> unicode:charlist()isPlatformLittleEndian() -> boolean()isPlatform64Bit() -> boolean()displaySize() -> {Width::integer(), Height::integer()}setCursor(Cursor) -> ok"
  ],
  [
    "wx_object",
    "start(Name, Mod, Args, Options) -> wxWindow:wxWindow() | {error, term()}start_link(Mod, Args, Options) -> wxWindow:wxWindow() | {error, term()}start_link(Name, Mod, Args, Options) -> wxWindow:wxWindow() | {error, term()}stop(Obj) -> okstop(Obj, Reason, Timeout) -> okcall(Obj, Request) -> term()call(Obj, Request, Timeout) -> term()cast(Obj, Request) -> okget_pid(Obj) -> pid()set_pid(Obj, Pid::pid()) -> wx:wx_object()reply(X1::{pid(), Tag::term()}, Reply::term()) -> pid()"
  ],
  [
    "xmerl",
    "callbacks(Module) -> Resultexport(Content, Callback) -> ExportedFormatexport(Content, Callback, RootAttributes) -> ExportedFormatexport_content(Es::Content, Callbacks) -> term()export_element(E, CB) -> term()export_element(E, CallbackModule, CallbackState) -> ExportedFormatexport_simple(Content, Callback) -> ExportedFormatexport_simple(Content, Callback, RootAttrs::RootAttributes) -> ExportedFormatexport_simple_content(Content, Callback) -> term()export_simple_element(Content, Callback) -> term()"
  ],
  [
    "xmerl_eventp",
    "file_sax(Fname::string(), CallBackModule::atom(), UserState, Options::option_list()) -> NewUserStatestream(Fname::string(), Options::option_list()) -> xmlElement()stream_sax(Fname, CallBack::CallBackModule, UserState, Options) -> xmlElement()string_sax(String::list(), CallBackModule::atom(), UserState, Options::option_list()) -> xmlElement()"
  ],
  [
    "xmerl_sax_parser",
    "file(Filename, Options) -> Resultstream(Xml, Options) -> ResultContinuationFun(State) -> {NewBytes, NewState}EventFun(Event, Location, State) -> NewState"
  ],
  [
    "xmerl_scan",
    "accumulate_whitespace(T::string(), S::global_state(), X3::atom(), Acc::string()) -> {Acc, T1, S1}cont_state(S::global_state()) -> global_state()cont_state(X::ContinuationState, S::global_state()) -> global_state()event_state(S::global_state()) -> global_state()event_state(X::EventState, S::global_state()) -> global_state()fetch_state(S::global_state()) -> global_state()fetch_state(X::FetchState, S::global_state()) -> global_state()file(Filename::string()) -> {xmlElement(), Rest}file(Filename::string(), Options::option_list()) -> {document(), Rest}hook_state(S::global_state()) -> global_state()hook_state(X::HookState, S::global_state()) -> global_state()rules_state(S::global_state()) -> global_state()rules_state(X::RulesState, S::global_state()) -> global_state()string(Text::list()) -> {xmlElement(), Rest}string(Text::list(), Options::option_list()) -> {document(), Rest}user_state(S::global_state()) -> global_state()user_state(X::UserState, S::global_state()) -> global_state()"
  ],
  [
    "xmerl_xpath",
    "string(Str, Doc) -> [docEntity()] | Scalarstring(Str, Doc, Options) -> [docEntity()] | Scalarstring(Str, Node, Parents, Doc, Options) -> [docEntity()] | Scalar"
  ],
  [
    "xmerl_xs",
    "built_in_rules(Fun, E) -> Listselect(String::string(), E) -> Evalue_of(E) -> Listxslapply(Fun::Function, EList::list()) -> List"
  ],
  [
    "xmerl_xsd",
    "file2state(FileName) -> {ok, State} | {error, Reason}format_error(L::Errors) -> Resultprocess_schema(Schema) -> Resultprocess_schema(Schema, Options) -> Resultprocess_schemas(Schemas) -> Resultprocess_schemas(Schemas, Options) -> Resultprocess_validate(Schema, Xml::Element) -> Resultprocess_validate(Schema, Xml::Element, Opts::Options) -> Resultstate2file(S::State) -> ok | {error, Reason}state2file(S::State, FileName) -> ok | {error, Reason}validate(Xml::Element, State) -> Resultvalidate(Xml::Element, State, Opts::Options) -> Result"
  ],
  [
    "xref",
    "add_application(Xref, Directory [, Options]) -> {ok, application()} | Erroradd_directory(Xref, Directory [, Options]) -> {ok, Modules} | Erroradd_module(Xref, File [, Options]) -> {ok, module()} | Erroradd_release(Xref, Directory [, Options]) -> {ok, release()} | Erroranalyze(Xref, Analysis [, Options]) -> {ok, Answer} | Errord(Directory) -> [DebugInfoResult] | [NoDebugInfoResult] | Errorforget(Xref) -> okforget(Xref, Variables) -> ok | Errorformat_error(Error) -> Charsget_default(Xref) -> [{Option, Value}]get_default(Xref, Option) -> {ok, Value} | Errorget_library_path(Xref) -> {ok, LibraryPath}info(Xref) -> [Info]info(Xref, Category) -> [{Item, [Info]}]info(Xref, Category, Items) -> [{Item, [Info]}]m(Module) -> [DebugInfoResult] | [NoDebugInfoResult] | Errorm(File) -> [DebugInfoResult] | [NoDebugInfoResult] | Errorq(Xref, Query [, Options]) -> {ok, Answer} | Errorremove_application(Xref, Applications) -> ok | Errorremove_module(Xref, Modules) -> ok | Errorremove_release(Xref, Releases) -> ok | Errorreplace_application(Xref, Application, Directory [, Options]) -> {ok, application()} | Errorreplace_module(Xref, Module, File [, Options]) -> {ok, module()} | Errorset_default(Xref, Option, Value) -> {ok, OldValue} | Errorset_default(Xref, OptionValues) -> ok | Errorset_library_path(Xref, LibraryPath [, Options]) -> ok | Errorstart(NameOrOptions) -> Returnstart(Name, Options) -> Returnstop(Xref)update(Xref [, Options]) -> {ok, Modules} | Errorvariables(Xref [, Options]) -> {ok, [VariableInfo]}"
  ],
  [
    "yecc",
    "file(Grammarfile [, Options]) -> YeccRetformat_error(Reason) -> Chars"
  ],
  [
    "zip",
    "foldl(Fun, Acc0, Archive) -> {ok, Acc1} | {error, Reason}list_dir(Archive) -> RetValuelist_dir(Archive, Options) -> RetValuetable(Archive) -> RetValuetable(Archive, Options) -> RetValuet(Archive) -> oktt(Archive) -> okunzip(Archive) -> RetValueunzip(Archive, Options) -> RetValueextract(Archive) -> RetValueextract(Archive, Options) -> RetValuezip(Name, FileList) -> RetValuezip(Name, FileList, Options) -> RetValuecreate(Name, FileList) -> RetValuecreate(Name, FileList, Options) -> RetValuezip_close(ZipHandle) -> ok | {error, einval}zip_get(ZipHandle) -> {ok, [Result]} | {error, Reason}zip_get(FileName, ZipHandle) -> {ok, Result} | {error, Reason}zip_list_dir(ZipHandle) -> {ok, Result} | {error, Reason}zip_open(Archive) -> {ok, ZipHandle} | {error, Reason}zip_open(Archive, Options) -> {ok, ZipHandle} | {error, Reason}"
  ],
  [
    "zlib",
    "adler32(Z, Data) -> CheckSumadler32(Z, PrevAdler, Data) -> CheckSumadler32_combine(Z, Adler1, Adler2, Size2) -> Adlerclose(Z) -> okcompress(Data) -> Compressedcrc32(Z) -> CRCcrc32(Z, Data) -> CRCcrc32(Z, PrevCRC, Data) -> CRCcrc32_combine(Z, CRC1, CRC2, Size2) -> CRCdeflate(Z, Data) -> Compresseddeflate(Z, Data, Flush) -> CompresseddeflateEnd(Z) -> okdeflateInit(Z) -> okdeflateInit(Z, Level) -> okdeflateInit(Z, Level, Method, WindowBits, MemLevel, Strategy) -> okdeflateParams(Z, Level, Strategy) -> okdeflateReset(Z) -> okdeflateSetDictionary(Z, Dictionary) -> Adler32getBufSize(Z) -> integer() >= 0gunzip(Data) -> Decompressedgzip(Data) -> Compressedinflate(Z, Data) -> Decompressedinflate(Z, Data, Options) -> DecompressedinflateChunk(Z) -> Decompressed | {more, Decompressed}inflateChunk(Z, Data) -> Decompressed | {more, Decompressed}inflateEnd(Z) -> okinflateGetDictionary(Z) -> DictionaryinflateInit(Z) -> okinflateInit(Z, WindowBits) -> okinflateReset(Z) -> okinflateSetDictionary(Z, Dictionary) -> okopen() -> zstream() safeInflate(Z, Data) -> ResultsetBufSize(Z, Size) -> okset_controlling_process(Z, Pid) -> okuncompress(Data) -> Decompressedunzip(Data) -> Decompressedzip(Data) -> Compressed"
  ],
  [
    "zlib",
    "adler32(Z, Data) -> CheckSumadler32(Z, PrevAdler, Data) -> CheckSumadler32_combine(Z, Adler1, Adler2, Size2) -> Adlerclose(Z) -> okcompress(Data) -> Compressedcrc32(Z) -> CRCcrc32(Z, Data) -> CRCcrc32(Z, PrevCRC, Data) -> CRCcrc32_combine(Z, CRC1, CRC2, Size2) -> CRCdeflate(Z, Data) -> Compresseddeflate(Z, Data, Flush) -> CompresseddeflateEnd(Z) -> okdeflateInit(Z) -> okdeflateInit(Z, Level) -> okdeflateInit(Z, Level, Method, WindowBits, MemLevel, Strategy) -> okdeflateParams(Z, Level, Strategy) -> okdeflateReset(Z) -> okdeflateSetDictionary(Z, Dictionary) -> Adler32getBufSize(Z) -> integer() >= 0gunzip(Data) -> Decompressedgzip(Data) -> Compressedinflate(Z, Data) -> Decompressedinflate(Z, Data, Options) -> DecompressedinflateChunk(Z) -> Decompressed | {more, Decompressed}inflateChunk(Z, Data) -> Decompressed | {more, Decompressed}inflateEnd(Z) -> okinflateGetDictionary(Z) -> DictionaryinflateInit(Z) -> okinflateInit(Z, WindowBits) -> okinflateReset(Z) -> okinflateSetDictionary(Z, Dictionary) -> okopen() -> zstream() safeInflate(Z, Data) -> ResultsetBufSize(Z, Size) -> okset_controlling_process(Z, Pid) -> okuncompress(Data) -> Decompressedunzip(Data) -> Decompressedzip(Data) -> Compressed"
  ]
]
