{"summary":"Pseudo random number generation.","description":"<p> </p><p> This module provides a pseudo random number generator. The module contains a number of algorithms. The uniform distribution algorithms are based on the <span class=\"bold_code bc-20\"><a href=\"/erldoc/docs/http://xorshift.di.unimi.it\"> Xoroshiro and Xorshift algorithms </a></span> by Sebastiano Vigna. The normal distribution algorithm uses the <span class=\"bold_code bc-20\"><a href=\"/erldoc/docs/http://www.jstatsoft.org/v05/i08\"> Ziggurat Method by Marsaglia and Tsang </a></span> on top of the uniform distribution algorithm. </p> <p> For most algorithms, jump functions are provided for generating non-overlapping sequences for parallel computations. The jump functions perform calculations equivalent to perform a large number of repeated calls for calculating new states. </p> <p>The following algorithms are provided:</p> <dl> <dt><strong><span class=\"code\">exsss</span></strong></dt> <dd> <p>Xorshift116**, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> <p> This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper by David Blackman and Sebastiano Vigna: <span class=\"bold_code bc-20\"><a href=\"/erldoc/docs/http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf\"> Scrambled Linear Pseudorandom Number Generators </a></span> </p> <p> The generator does not need 58-bit rotates so it is faster than the Xoroshiro116 generator, and when combined with the StarStar scrambler it does not have any weak low bits like <span class=\"code\">exrop</span> (Xoroshiro116+). </p> <p> Alas, this combination is about 10% slower than <span class=\"code\">exrop</span>, but is despite that the default algorithm thanks to its statistical qualities. </p> </dd> <dt><strong><span class=\"code\">exro928ss</span></strong></dt> <dd> <p>Xoroshiro928**, 58 bits precision and a period of 2^928-1</p> <p>Jump function: equivalent to 2^512 calls</p> <p> This is a 58 bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano Vigna: <span class=\"bold_code bc-20\"><a href=\"/erldoc/docs/http://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf\"> Scrambled Linear Pseudorandom Number Generators </a></span> that on a 64 bit Erlang system executes only about 40% slower than the default <span class=\"code\">exsss</span> algorithm but with much longer period and better statistical properties, and on the flip side a larger state. </p> <p> Many thanks to Sebastiano Vigna for his help with the 58 bit adaption. </p> </dd> <dt><strong><span class=\"code\">exrop</span></strong></dt> <dd> <p>Xoroshiro116+, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> </dd> <dt><strong><span class=\"code\">exs1024s</span></strong></dt> <dd> <p>Xorshift1024*, 64 bits precision and a period of 2^1024-1</p> <p>Jump function: equivalent to 2^512 calls</p> </dd> <dt><strong><span class=\"code\">exsp</span></strong></dt> <dd> <p>Xorshift116+, 58 bits precision and period of 2^116-1</p> <p>Jump function: equivalent to 2^64 calls</p> <p> This is a corrected version of the previous default algorithm, that now has been superseded by Xoroshiro116+ (<span class=\"code\">exrop</span>). Since there is no native 58 bit rotate instruction this algorithm executes a little (say &lt; 15%) faster than <span class=\"code\">exrop</span>. See the <span class=\"bold_code bc-20\"><a href=\"/erldoc/docs/http://xorshift.di.unimi.it\">algorithms&apos; homepage</a></span>. </p> </dd> </dl> <p> The default algorithm is <span class=\"code\">exsss</span> (Xorshift116**). If a specific algorithm is required, ensure to always use <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#seed-1\"><span class=\"code\">seed/1</span></a></span> to initialize the state. </p> <p> Undocumented (old) algorithms are deprecated but still implemented so old code relying on them will produce the same pseudo random sequences as before. </p> <div class=\"note\"><div class=\"label\">Note</div><div class=\"content\"><p> </p><p> There were a number of problems in the implementation of the now undocumented algorithms, which is why they are deprecated. The new algorithms are a bit slower but do not have these problems: </p> <p> Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges but for large ranges less than the generator&apos;s precision the probability to produce a low number could be twice the probability for a high. </p> <p> Uniform integer ranges larger than or equal to the generator&apos;s precision used a floating point fallback that only calculated with 52 bits which is smaller than the requested range and therefore were not all numbers in the requested range even possible to produce. </p> <p> Uniform floats had a non-uniform density so small values i.e less than 0.5 had got smaller intervals decreasing as the generated value approached 0.0 although still uniformly distributed for sufficiently large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence equally spaced. </p> <p></p></div></div> <p>Every time a random number is requested, a state is used to calculate it and a new state is produced. The state can either be implicit or be an explicit argument and return value.</p> <p>The functions with implicit state use the process dictionary variable <span class=\"code\">rand_seed</span> to remember the current state.</p> <p>If a process calls <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform-0\"><span class=\"code\">uniform/0</span></a></span>, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform-1\"><span class=\"code\">uniform/1</span></a></span> or <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_real-0\"><span class=\"code\">uniform_real/0</span></a></span> without setting a seed first, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#seed-1\"><span class=\"code\">seed/1</span></a></span> is called automatically with the default algorithm and creates a non-constant seed.</p> <p>The functions with explicit state never use the process dictionary.</p> <p><strong>Examples:</strong></p> <p>Simple use; creates and seeds the default algorithm with a non-constant seed if not already done:</p> <div class=\"example\"><pre>R0 = rand:uniform(),R1 = rand:uniform(),</pre></div> <p>Use a specified algorithm:</p> <div class=\"example\"><pre>_ = rand:seed(exs928ss),R2 = rand:uniform(),</pre></div> <p>Use a specified algorithm with a constant seed:</p> <div class=\"example\"><pre>_ = rand:seed(exs928ss, {123, 123534, 345345}),R3 = rand:uniform(),</pre></div> <p>Use the functional API with a non-constant seed:</p> <div class=\"example\"><pre>S0 = rand:seed_s(exsss),{R4, S1} = rand:uniform_s(S0),</pre></div> <p>Textbook basic form Box-Muller standard normal deviate</p> <div class=\"example\"><pre>R5 = rand:uniform_real(),R6 = rand:uniform(),SND0 = math:sqrt(-2 * math:log(R5)) * math:cos(math:pi() * R6)</pre></div> <p>Create a standard normal deviate:</p> <div class=\"example\"><pre>{SND1, S2} = rand:normal_s(S1),</pre></div> <p>Create a normal deviate with mean -3 and variance 0.5:</p> <div class=\"example\"><pre>{ND0, S3} = rand:normal_s(-3, 0.5, S2),</pre></div> <div class=\"note\"><div class=\"label\">Note</div><div class=\"content\"><p> </p><p>The builtin random number generator algorithms are not cryptographically strong. If a cryptographically strong random number generator is needed, use something like <span class=\"bold_code bc-13\"><a href=\"/erldoc/docs/crypto#rand_seed-0\"><span class=\"code\">crypto:rand_seed/0</span></a></span>. </p> <p></p></div></div> <p> For all these generators except <span class=\"code\">exro928ss</span> and <span class=\"code\">exsss</span> the lowest bit(s) has got a slightly less random behaviour than all other bits. 1 bit for <span class=\"code\">exrop</span> (and <span class=\"code\">exsp</span>), and 3 bits for <span class=\"code\">exs1024s</span>. See for example the explanation in the <span class=\"bold_code bc-20\"><a href=\"/erldoc/docs/http://xoroshiro.di.unimi.it/xoroshiro128plus.c\"> Xoroshiro128+ </a></span> generator source code: </p> <div class=\"example\"><pre>Beside passing BigCrush, this generator passes the PractRand test suiteup to (and included) 16TB, with the exception of binary rank tests,which fail due to the lowest bit being an LFSR; all other bits pass alltests. We suggest to use a sign test to extract a random Boolean value.</pre></div> <p> If this is a problem; to generate a boolean with these algorithms use something like this: </p> <div class=\"example\"><pre>(rand:uniform(16) &gt; 8)</pre></div> <p> And for a general range, with <span class=\"code\">N = 1</span> for <span class=\"code\">exrop</span>, and <span class=\"code\">N = 3</span> for <span class=\"code\">exs1024s</span>: </p> <div class=\"example\"><pre>(((rand:uniform(Range bsl N) - 1) bsr N) + 1)</pre></div> <p> The floating point generating functions in this module waste the lowest bits when converting from an integer so they avoid this snag. </p> <p></p>","funcs":" <a name=\"export_seed-0\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-export_seed-0-id359787\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L351\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>export_seed() -&gt; undefined | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-export_state\">export_state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"export_seed-0\"></a> </p><p>Returns the random number state in an external format. To be used with <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#seed-1\"><span class=\"code\">seed/1</span></a></span>.</p> <p></p></div> <a name=\"export_seed_s-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-export_seed_s-1-id359781\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L360\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>export_seed_s(State :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt; <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-export_state\">export_state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"export_seed_s-1\"></a> </p><p>Returns the random number generator state in an external format. To be used with <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#seed-1\"><span class=\"code\">seed/1</span></a></span>.</p> <p></p></div> <a name=\"jump-0\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-jump-0-id359765\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L369\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>jump() -&gt; NewState :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 20.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"jump-0\"></a> </p><p>Returns the state after performing jump calculation to the state in the process dictionary.</p> <p>This function generates a <span class=\"code\">not_implemented</span> error exception when the jump function is not implemented for the algorithm specified in the state in the process dictionary.</p> <p></p></div> <a name=\"jump-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-jump-1-id359779\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L384\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>jump(State :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt; NewState :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 20.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"jump-1\"></a> </p><p>Returns the state after performing jump calculation to the given state. </p> <p>This function generates a <span class=\"code\">not_implemented</span> error exception when the jump function is not implemented for the algorithm specified in the state.</p> <p></p></div> <a name=\"normal-0\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-normal-0-id360143\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L396\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>normal() -&gt; float()</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Returns a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and updates the state in the process dictionary.</p> <p></p></div> <a name=\"normal-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-normal-2-id360212\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L406\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>normal(Mean :: number(), Variance :: number()) -&gt; float()</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 20.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Returns a normal N(Mean, Variance) deviate float and updates the state in the process dictionary.</p> <p></p></div> <a name=\"normal_s-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-normal_s-1-id360217\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L415\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>normal_s(State :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt; {float(), NewState :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>}</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Returns, for a specified state, a standard normal deviate float (that is, the mean is 0 and the standard deviation is 1) and a new state.</p> <p></p></div> <a name=\"normal_s-3\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-normal_s-3-id360289\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L425\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>normal_s(Mean :: number(),<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Variance :: number(),<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;State0 :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{float(), NewS :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>}</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 20.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Returns, for a specified state, a normal N(Mean, Variance) deviate float and a new state.</p> <p></p></div> <a name=\"seed-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-seed-1-id360382\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L434\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>seed(AlgOrStateOrExpState ::<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-builtin_alg\">builtin_alg()</a></span> | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span> | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-export_state\">export_state()</a></span>) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> <a name=\"seed-1\"></a> </p><p> Seeds random number generation with the specifed algorithm and time-dependent data if <span class=\"code\">AlgOrStateOrExpState</span> is an algorithm. </p> <p>Otherwise recreates the exported seed in the process dictionary, and returns the state. See also <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#export_seed-0\"><span class=\"code\">export_seed/0</span></a></span>.</p> <p></p></div> <a name=\"seed-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-seed-2-id360416\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L450\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>seed(Alg :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-builtin_alg\">builtin_alg()</a></span>, Seed :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-seed\">seed()</a></span>) -&gt; <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Seeds random number generation with the specified algorithm and integers in the process dictionary and returns the state.</p> <p></p></div> <a name=\"seed_s-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-seed_s-1-id360383\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L459\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>seed_s(AlgOrStateOrExpState ::<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-builtin_alg\">builtin_alg()</a></span> | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span> | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-export_state\">export_state()</a></span>) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p> Seeds random number generation with the specifed algorithm and time-dependent data if <span class=\"code\">AlgOrStateOrExpState</span> is an algorithm. </p> <p>Otherwise recreates the exported seed and returns the state. See also <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#export_seed-0\"><span class=\"code\">export_seed/0</span></a></span>.</p> <p></p></div> <a name=\"seed_s-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-seed_s-2-id360823\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L474\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>seed_s(Alg :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-builtin_alg\">builtin_alg()</a></span>, Seed :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-seed\">seed()</a></span>) -&gt; <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span></div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Seeds random number generation with the specified algorithm and integers and returns the state.</p> <p></p></div> <a name=\"uniform-0\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-uniform-0-id360824\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L483\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>uniform() -&gt; X :: float()</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"uniform-0\"></a> </p><p> Returns a random float uniformly distributed in the value range <span class=\"code\">0.0 =&lt; X &lt; 1.0</span> and updates the state in the process dictionary. </p> <p> The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. </p> <div class=\"warning\"><div class=\"label\">Warning</div><div class=\"content\"><p> </p><p> This function may return exactly <span class=\"code\">0.0</span> which can be fatal for certain applications. If that is undesired you can use <span class=\"code\">(1.0 - rand:uniform())</span> to get the interval <span class=\"code\">0.0 &lt; X =&lt; 1.0</span>, or instead use <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_real-0\"><span class=\"code\">uniform_real/0</span></a></span>. </p> <p> If neither endpoint is desired you can test and re-try like this: </p> <div class=\"example\"><pre>my_uniform() -&gt; case rand:uniform() of 0.0 -&gt; my_uniform(); X -&gt; X endend.</pre></div> <p></p></div></div> <p></p></div> <a name=\"uniform_real-0\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-uniform_real-0-id361024\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L519\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>uniform_real() -&gt; X :: float()</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 21.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"uniform_real-0\"></a> </p><p> Returns a random float uniformly distributed in the value range <span class=\"code\">DBL_MIN =&lt; X &lt; 1.0</span> and updates the state in the process dictionary. </p> <p> Conceptually, a random real number <span class=\"code\">R</span> is generated from the interval <span class=\"code\">0 =&lt; R &lt; 1</span> and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. </p> <div class=\"note\"><div class=\"label\">Note</div><div class=\"content\"><p> </p><p> The generated numbers from this function has got better granularity for small numbers than the regular <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform-0\"><span class=\"code\">uniform/0</span></a></span> because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example <span class=\"code\">1.0 / X</span> or <span class=\"code\">math:log(X)</span>. </p> <p></p></div></div> <p> See <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_real_s-1\"><span class=\"code\">uniform_real_s/1</span></a></span> for more explanation. </p> <p></p></div> <a name=\"uniform-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-uniform-1-id361179\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L555\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>uniform(N :: integer() &gt;= 1) -&gt; X :: integer() &gt;= 1</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"uniform-1\"></a> </p><p>Returns, for a specified integer <span class=\"code\">N &gt;= 1</span>, a random integer uniformly distributed in the value range <span class=\"code\">1 =&lt; X =&lt; N</span> and updates the state in the process dictionary.</p> <p></p></div> <a name=\"uniform_s-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-uniform_s-1-id361253\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L566\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>uniform_s(State :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt; {X :: float(), NewState :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>}</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p> Returns, for a specified state, random float uniformly distributed in the value range <span class=\"code\">0.0 =&lt; X &lt; 1.0</span> and a new state. </p> <p> The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval. </p> <div class=\"warning\"><div class=\"label\">Warning</div><div class=\"content\"><p> </p><p> This function may return exactly <span class=\"code\">0.0</span> which can be fatal for certain applications. If that is undesired you can use <span class=\"code\">(1.0 - rand:uniform(State))</span> to get the interval <span class=\"code\">0.0 &lt; X =&lt; 1.0</span>, or instead use <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_real_s-1\"><span class=\"code\">uniform_real_s/1</span></a></span>. </p> <p> If neither endpoint is desired you can test and re-try like this: </p> <div class=\"example\"><pre>my_uniform(State) -&gt; case rand:uniform(State) of {0.0, NewState} -&gt; my_uniform(NewState); Result -&gt; Result endend.</pre></div> <p></p></div></div> <p></p></div> <a name=\"uniform_real_s-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-uniform_real_s-1-id361410\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L602\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>uniform_real_s(State :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{X :: float(), NewState :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>}</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 21.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p> Returns, for a specified state, a random float uniformly distributed in the value range <span class=\"code\">DBL_MIN =&lt; X &lt; 1.0</span> and updates the state in the process dictionary. </p> <p> Conceptually, a random real number <span class=\"code\">R</span> is generated from the interval <span class=\"code\">0 =&lt; R &lt; 1</span> and then the closest rounded down normalized number in the IEEE 754 Double precision format is returned. </p> <div class=\"note\"><div class=\"label\">Note</div><div class=\"content\"><p> </p><p> The generated numbers from this function has got better granularity for small numbers than the regular <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_s-1\"><span class=\"code\">uniform_s/1</span></a></span> because all bits in the mantissa are random. This property, in combination with the fact that exactly zero is never returned is useful for algoritms doing for example <span class=\"code\">1.0 / X</span> or <span class=\"code\">math:log(X)</span>. </p> <p></p></div></div> <p> The concept implicates that the probability to get exactly zero is extremely low; so low that this function is in fact guaranteed to never return zero. The smallest number that it might return is <span class=\"code\">DBL_MIN</span>, which is 2.0^(-1022). </p> <p> The value range stated at the top of this function description is technically correct, but <span class=\"code\">0.0 =&lt; X &lt; 1.0</span> is a better description of the generated numbers&apos; statistical distribution. Except that exactly 0.0 is never returned, which is not possible to observe statistically. </p> <p> For example; for all sub ranges <span class=\"code\">N*2.0^(-53) =&lt; X &lt; (N+1)*2.0^(-53)</span> where <span class=\"code\">0 =&lt; integer(N) &lt; 2.0^53</span> the probability is the same. Compare that with the form of the numbers generated by <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_s-1\"><span class=\"code\">uniform_s/1</span></a></span>. </p> <p> Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#uniform_s-1\"><span class=\"code\">uniform_s/1</span></a></span> </p> <p></p></div> <a name=\"uniform_s-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-uniform_s-2-id361639\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/rand.xml#L664\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>uniform_s(N :: integer() &gt;= 1, State :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{X :: integer() &gt;= 1, NewState :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-state\">state()</a></span>}</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 18.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>Returns, for a specified integer <span class=\"code\">N &gt;= 1</span> and a state, a random integer uniformly distributed in the value range <span class=\"code\">1 =&lt; X =&lt; N</span> and a new state.</p> <p></p></div> "}