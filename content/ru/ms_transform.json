{"summary":"A parse transformation that translates fun syntax into match\n    specifications.","description":"<p> <a name=\"top\"></a> </p><p>This module provides the parse transformation that makes calls to <span class=\"bold_code bc-19\"><a href=\"/erldoc/docs/ets\"><span class=\"code\">ets</span></a></span> and <span class=\"bold_code bc-13\"><a href=\"/erldoc/docs/dbg#fun2ms-1\"><span class=\"code\">dbg:fun2ms/1</span></a></span> translate into literal match specifications. It also provides the back end for the same functions when called from the Erlang shell.</p> <p>The translation from funs to match specifications is accessed through the two &quot;pseudo functions&quot; <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/ets#fun2ms-1\"><span class=\"code\">ets:fun2ms/1</span></a></span> and <span class=\"bold_code bc-13\"><a href=\"/erldoc/docs/dbg#fun2ms-1\"><span class=\"code\">dbg:fun2ms/1</span></a></span>.</p> <p>As everyone trying to use <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/ets#select-1\"><span class=\"code\">ets:select/2</span></a></span> or <span class=\"bold_code bc-18\"><a href=\"/erldoc/docs/dbg\"><span class=\"code\">dbg</span></a></span> seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</p> <p>Read the whole manual page if it is the first time you are using the transformations.</p> <p>Match specifications are used more or less as filters. They resemble usual Erlang matching in a list comprehension or in a fun used with <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/lists#foldl-3\"><span class=\"code\">lists:foldl/3</span></a></span>, and so on. However, the syntax of pure match specifications is awkward, as they are made up purely by Erlang terms, and the language has no syntax to make the match specifications more readable.</p> <p>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</p> <p></p>","funcs":" <a name=\"format_error-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-format_error-1-id360786\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/ms_transform.xml#L733\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>format_error(Error) -&gt; Chars</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Error = {error, module(), term()}</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Chars = <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/io_lib#type-chars\">io_lib:chars()</a></span></span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Takes an error code returned by one of the other functions in the module and creates a textual description of the error.</p> <p></p></div> <a name=\"parse_transform-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-parse_transform-2-id360824\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/ms_transform.xml#L743\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>parse_transform(Forms, Options) -&gt; Forms2 | Errors | Warnings</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Forms = Forms2 = [<span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/erl_parse#type-abstract_form\">erl_parse:abstract_form()</a></span> | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/erl_parse#type-form_info\">erl_parse:form_info()</a></span>]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\"></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Options = term()</span></div><div class=\"REFBODY rb-1\">Option list, required but not used. </div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Errors = {error, ErrInfo :: [tuple()], WarnInfo :: []}</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Warnings = {warning, Forms2, WarnInfo :: [tuple()]}</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file <span class=\"code\">ms_transform.hrl</span> is included in the source code.</p> <p>For information about how to use this parse transformation, see <span class=\"bold_code bc-19\"><a href=\"/erldoc/docs/ets\"><span class=\"code\">ets</span></a></span> and <span class=\"bold_code bc-13\"><a href=\"/erldoc/docs/dbg#fun2ms-1\"><span class=\"code\">dbg:fun2ms/1</span></a></span>.</p> <p>For a description of match specifications, see section <span class=\"bold_code bc-18\"><a href=\"/erldoc/docs/../apps/erts/match_spec\">Match Specification in Erlang</a></span> in ERTS User&apos;s Guide.</p> <p></p></div> <a name=\"transform_from_shell-3\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-transform_from_shell-3-id360961\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/ms_transform.xml#L764\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>transform_from_shell(Dialect, Clauses, BoundEnvironment) -&gt; term()</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Dialect = ets | dbg</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Clauses = [<span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/erl_parse#type-abstract_clause\">erl_parse:abstract_clause()</a></span>]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">BoundEnvironment = <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/erl_eval#type-binding_struct\">erl_eval:binding_struct()</a></span></span></div><div class=\"REFBODY rb-1\">List of variable bindings in the shell environment.</div></div><div class=\"REFBODY rb-7\"><p> </p><p>Implements the transformation when the <span class=\"code\">fun2ms/1</span> functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as <span class=\"code\">BoundEnvironment</span>. The result is a term, normalized, that is, not in abstract format.</p> <p></p></div> "}