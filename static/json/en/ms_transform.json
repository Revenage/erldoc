{
	"erlref": {
		"header": {
			"copyright": {
				"year": [
					"2002",
					"2016"
				],
				"holder": "Ericsson AB. All Rights Reserved."
			},
			"legalnotice": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
			"title": "ms_transform",
			"prepared": "Patrik Nyblom",
			"responsible": "Bjarne Dacker",
			"docno": "1",
			"approved": "Bjarne Dcker",
			"checked": {},
			"date": "1999-02-09",
			"rev": "C",
			"file": "ms_transform.xml"
		},
		"module": {
			"since": "",
			"$t": "ms_transform"
		},
		"modulesummary": "A parse transformation that translates fun syntax into match specifications.",
		"description": {
			"marker": {
				"id": "top"
			},
			"p": [
				{
					"seealso": [
						{
							"marker": "ets",
							"c": "ets"
						},
						{
							"marker": "runtime_tools:dbg#fun2ms/1",
							"c": "dbg:fun2ms/1"
						}
					]
				},
				{
					"seealso": [
						{
							"marker": "ets#fun2ms/1",
							"c": "ets:fun2ms/1"
						},
						{
							"marker": "runtime_tools:dbg#fun2ms/1",
							"c": "dbg:fun2ms/1"
						}
					]
				},
				{
					"seealso": [
						{
							"marker": "ets#select/1",
							"c": "ets:select/2"
						},
						{
							"marker": "runtime_tools:dbg",
							"c": "dbg"
						}
					]
				},
				"Read the whole manual page if it is the first time you are using the transformations.",
				{
					"seealso": {
						"marker": "lists#foldl/3",
						"c": "lists:foldl/3"
					}
				},
				"As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms."
			]
		},
		"section": [
			{
				"title": "Example 1",
				"p": [
					{
						"seealso": [
							{
								"marker": "ets#select/2",
								"c": "ets:select/2"
							},
							{
								"marker": "ets#foldl/3",
								"c": "ets:foldl/3"
							}
						],
						"c": [
							"ets:select/2",
							"ms_transform"
						]
					},
					"Consider a simple table of employees:",
					"We create the table using:",
					"We fill the table with randomly chosen data:",
					"Assuming that we want the employee numbers of everyone in the sales department, there are several ways.",
					{
						"c": "ets:match/2"
					},
					{
						"c": "ets:match/2"
					},
					{
						"seealso": [
							{
								"marker": "ets#foldl/3",
								"c": "ets:foldl/3"
							},
							{
								"marker": "ets#foldr/3",
								"c": "ets:foldr/3"
							}
						]
					},
					{
						"c": [
							"[\"011103\",\"076324\"]",
							"ets:match/2"
						]
					},
					{
						"c": [
							"ets:select/2",
							"ets:foldr"
						]
					},
					{
						"c": [
							"#emp{empno = '$1', dept = sales, _='_'}",
							"ets:match/2",
							"'$1'",
							"[\"011103\",\"076324\"]",
							"ets:foldr/3"
						]
					},
					{
						"c": [
							"ets:fun2ms/1",
							"ets:foldr/3",
							"ets:select/2"
						]
					},
					{
						"c": [
							"ets:foldr/3",
							"ets:foldr/3",
							"ets:foldr/3"
						]
					},
					{
						"c": [
							"ets:fun2ms/1",
							"ms_transform.hrl",
							"ets:fun2ms/1"
						]
					}
				],
				"code": [
					{
						"type": "none",
						"$t": "-record(emp, {empno, %Employee number as a string, the key surname, %Surname of the employee givenname, %Given name of employee dept, %Department, one of {dev,sales,prod,adm} empyear}). %Year the employee was employed"
					},
					{
						"type": "none",
						"$t": "ets:new(emp_tab, [{keypos,#emp.empno},named_table,ordered_set])."
					},
					{
						"type": "none",
						"$t": "[{emp,\"011103\",\"Black\",\"Alfred\",sales,2000}, {emp,\"041231\",\"Doe\",\"John\",prod,2001}, {emp,\"052341\",\"Smith\",\"John\",dev,1997}, {emp,\"076324\",\"Smith\",\"Ella\",sales,1995}, {emp,\"122334\",\"Weston\",\"Anna\",prod,2002}, {emp,\"535216\",\"Chalker\",\"Samuel\",adm,1998}, {emp,\"789789\",\"Harrysson\",\"Joe\",adm,1996}, {emp,\"963721\",\"Scott\",\"Juliana\",dev,2003}, {emp,\"989891\",\"Brown\",\"Gabriel\",prod,1999}]"
					},
					{
						"type": "none",
						"$t": "ets:foldr(fun(#emp{empno = E, dept = sales},Acc) -> [E | Acc]; (_,Acc) -> Acc end, [], emp_tab)."
					},
					{
						"type": "none",
						"$t": "ets:select(emp_tab, [{#emp{empno = '$1', dept = sales, _='_'},[],['$1']}])."
					},
					{
						"type": "none",
						"$t": "-include_lib(\"stdlib/include/ms_transform.hrl\").ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = E, dept = sales}) -> E end))."
					}
				],
				"pre": {
					"input": "ets:match(emp_tab, {'_', '$1', '_', '_', sales, '_'})."
				}
			},
			{
				"title": "Example 2",
				"p": [
					{
						"c": [
							"ets:match/2",
							"ets:foldr/3"
						]
					},
					{
						"c": "[\"052341\",\"076324\",\"535216\",\"789789\",\"989891\"]"
					},
					{
						"c": [
							"[{'<', '$2', 2000}]",
							"empyear",
							"'$2'",
							"foldr/3"
						]
					},
					{
						"c": "ets:fun2ms/1"
					}
				],
				"code": [
					{
						"type": "none",
						"$t": "ets:foldr(fun(#emp{empno = E, empyear = Y},Acc) when Y < 2000 -> [E | Acc]; (_,Acc) -> Acc end, [], emp_tab)."
					},
					{
						"type": "none",
						"$t": "ets:select(emp_tab, [{#emp{empno = '$1', empyear = '$2', _='_'}, [{'<', '$2', 2000}], ['$1']}])."
					},
					{
						"type": "none",
						"$t": "-include_lib(\"stdlib/include/ms_transform.hrl\").ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = E, empyear = Y}) when Y < 2000 -> E end))."
					}
				]
			},
			{
				"title": "Example 3",
				"p": [
					"Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:",
					{
						"c": [
							"=",
							"object/0"
						],
						"em": "whole",
						"seealso": {
							"marker": "#warnings_and_restrictions",
							"$t": "Warnings and Restrictions"
						}
					}
				],
				"code": {
					"type": "none",
					"$t": "ets:select(emp_tab, ets:fun2ms( fun(Obj = #emp{empno = E, empyear = Y}) when Y < 2000 -> Obj end))."
				}
			},
			{
				"title": "Example 4",
				"p": [
					{
						"c": [
							"0",
							"1",
							"[{<Old empno>,<New empno>}]"
						]
					},
					{
						"c": [
							"ordered_set",
							"0"
						]
					}
				],
				"code": {
					"type": "none",
					"$t": "ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = [$0 | Rest] }) -> {[$0|Rest],[$1|Rest]} end))."
				}
			},
			{
				"title": "Example 5",
				"p": [
					"The fun can have many clauses. Assume that we want to do the following:",
					"This is accomplished as follows:",
					"The result is as follows:"
				],
				"list": {
					"type": "bulleted",
					"item": [
						{
							"p": {
								"c": "{inventory, <employee number>}"
							}
						},
						{
							"p": {
								"c": "{rookie, <employee number>}"
							}
						},
						{
							"p": {
								"c": [
									"{newbie, <employee number>}",
									"Smith",
									"guru",
									"{guru, <employee number>}"
								]
							}
						}
					]
				},
				"code": [
					{
						"type": "none",
						"$t": "ets:select(emp_tab, ets:fun2ms( fun(#emp{empno = E, surname = \"Smith\" }) -> {guru,E}; (#emp{empno = E, empyear = Y}) when Y < 1997 -> {inventory, E}; (#emp{empno = E, empyear = Y}) when Y > 2001 -> {newbie, E}; (#emp{empno = E, empyear = Y}) -> % 1997 -- 2001 {rookie, E} end))."
					},
					{
						"type": "none",
						"$t": "[{rookie,\"011103\"}, {rookie,\"041231\"}, {guru,\"052341\"}, {guru,\"076324\"}, {newbie,\"122334\"}, {rookie,\"535216\"}, {inventory,\"789789\"}, {newbie,\"963721\"}, {rookie,\"989891\"}]"
					}
				]
			},
			{
				"title": "Useful BIFs",
				"p": [
					{
						"seealso": [
							{
								"marker": "erts:match_spec",
								"$t": "match specifications"
							},
							{
								"marker": "ets#fun2ms/1",
								"c": "ets:fun2ms/1"
							}
						],
						"c": [
							"ets:fun2ms/1",
							"ets:select/2",
							"ets:foldl/foldr"
						]
					},
					{
						"em": "one",
						"c": [
							"_",
							"ets:fun2ms/1",
							"dets:select/2",
							"mnesia:select/2",
							"ets:select/2",
							"="
						]
					},
					"The guard section can contain any guard expression of Erlang. The following is a list of BIFs and expressions:",
					{
						"c": "is_record"
					},
					{
						"c": ";"
					},
					{
						"c": [
							"object",
							"bindings"
						]
					},
					{
						"c": [
							"dbg",
							"ets:fun2ms/1",
							"="
						]
					}
				],
				"list": {
					"type": "bulleted",
					"item": [
						{
							"p": {
								"c": [
									"is_atom",
									"is_float",
									"is_integer",
									"is_list",
									"is_number",
									"is_pid",
									"is_port",
									"is_reference",
									"is_tuple",
									"is_binary",
									"is_function",
									"is_record"
								]
							}
						},
						{
							"p": {
								"c": [
									"not",
									"and",
									"or",
									"andalso",
									"orelse"
								]
							}
						},
						{
							"p": "Relational operators: >, >=, <, =<, =:=, ==, =/=, /="
						},
						{
							"p": {
								"c": [
									"+",
									"-",
									"*",
									"div",
									"rem"
								]
							}
						},
						{
							"p": {
								"c": [
									"band",
									"bor",
									"bxor",
									"bnot",
									"bsl",
									"bsr"
								]
							}
						},
						{
							"p": {
								"c": [
									"abs",
									"element",
									"hd",
									"length",
									"node",
									"round",
									"size",
									"tl",
									"trunc",
									"self"
								]
							}
						}
					]
				}
			},
			{
				"title": "Example with dbg",
				"p": [
					{
						"seealso": {
							"marker": "runtime_tools:dbg#fun2ms/1",
							"c": "dbg:fun2ms/1"
						}
					},
					{
						"c": [
							"dbg",
							"ets:fun2ms/1",
							"ets:fun2ms/1"
						]
					},
					"The following is an example module to trace on:",
					{
						"c": [
							"{badmatch,16}",
							"{toy,start,1}"
						]
					},
					{
						"c": [
							"ets:new/2",
							"new/2",
							"toy_table"
						]
					},
					"We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not):",
					{
						"c": "ets:new(toy_table, <something>)"
					},
					{
						"c": [
							"dbg:fun2ms/1",
							"true"
						]
					},
					"The following trace output is received during test:",
					{
						"c": "ets:new/2"
					},
					"The following trace output is received during test:",
					{
						"c": [
							"return_trace",
							"dbg"
						]
					},
					{
						"c": [
							"{badmatch,24}",
							"toy_table",
							"named_table"
						]
					},
					"With the same tracing turned on, the following trace output is received:",
					{
						"c": "toy_table"
					},
					{
						"c": "dbg:tpl/3"
					},
					{
						"c": [
							"ets:insert/2",
							"caller",
							"message",
							"ets:insert/2"
						]
					},
					"The caller is now displayed in the \"additional message\" part of the trace output, and the following is displayed after a while:",
					{
						"c": [
							"evil_fun",
							"evil_mod",
							"2"
						]
					},
					{
						"c": "dbg",
						"seealso": {
							"marker": "erts:match_spec",
							"$t": "Match specifications in Erlang"
						}
					}
				],
				"code": [
					{
						"type": "none",
						"$t": "-module(toy).-export([start/1, store/2, retrieve/1]).start(Args) -> toy_table = ets:new(toy_table, Args).store(Key, Value) -> ets:insert(toy_table, {Key,Value}).retrieve(Key) -> [{Key, Value}] = ets:lookup(toy_table, Key), Value."
					},
					{
						"type": "none",
						"$t": "(<0.86.0>) call ets:new(toy_table, [ordered_set])"
					},
					{
						"type": "none",
						"$t": "(<0.86.0>) call ets:new(toy_table,[ordered_set])(<0.86.0>) returned from ets:new/2 -> 24"
					},
					{
						"type": "none",
						"$t": "start(Args) -> toy_table = ets:new(toy_table, [named_table|Args])."
					},
					{
						"type": "none",
						"$t": "(<0.86.0>) call ets:new(toy_table,[named_table,ordered_set])(<0.86.0>) returned from ets:new/2 -> toy_table"
					},
					{
						"type": "none",
						"$t": "(<0.86.0>) call ets:insert(toy_table,{garbage,can}) ({evil_mod,evil_fun,2})"
					}
				],
				"pre": [
					{
						"input": "dbg:tracer()."
					},
					{
						"input": "dbg:p(all,call)."
					},
					{
						"input": "dbg:tp(ets,new,dbg:fun2ms(fun([toy_table,_]) -> true end))."
					},
					{
						"input": "dbg:tp(ets,new,dbg:fun2ms(fun([toy_table,_]) -> return_trace() end))."
					},
					{
						"input": [
							"dbg:tracer().",
							"dbg:p(all,call).",
							"dbg:tpl(toy,store,dbg:fun2ms(fun([A,_]) when is_atom(A) -> true end))."
						]
					},
					{
						"input": [
							"dbg:tpl(ets,insert,dbg:fun2ms(fun([toy_table,{A,_}]) when is_atom(A) ->",
							"message(caller())",
							"end))."
						]
					}
				]
			},
			{
				"title": "Warnings and Restrictions",
				"marker": {
					"id": "warnings_and_restrictions"
				},
				"p": [
					{
						"c": [
							"ets:fun2ms/1",
							"dbg:fun2ms/1"
						]
					},
					"Many restrictions apply to the fun that is translated into a match specification. To put it simple: you cannot use anything in the fun that you cannot use in a match specification. This means that, among others, the following restrictions apply to the fun itself:",
					"The translation from funs to match specifications is done at compile time, so runtime performance is not affected by using these pseudo functions.",
					{
						"seealso": {
							"marker": "erts:match_spec",
							"$t": "Match specifications in Erlang"
						}
					}
				],
				"warning": [
					{
						"p": {
							"c": "ms_transform.hrl"
						}
					},
					{
						"p": {
							"c": [
								"ets:fun2ms/1",
								"dbg:fun2ms/1",
								"ets:fun2ms(fun(A) -> A end)",
								"F = fun(A) -> A end, ets:fun2ms(F)"
							]
						}
					}
				],
				"list": {
					"type": "bulleted",
					"item": [
						{
							"p": "Functions written in Erlang cannot be called, neither can local functions, global functions, or real funs."
						},
						{
							"p": {
								"c": [
									"is_list(X)",
									"{'is_list', '$1'}",
									"'$1'"
								]
							}
						},
						{
							"p": {
								"c": [
									"fun({A,B,C})",
									"{'$1', '$2', '$3'}",
									"fun({A,B}) when is_atom(A) -> B end",
									"[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]"
								]
							}
						},
						{
							"p": {
								"c": "const"
							},
							"pre": {
								"input": [
									"X = 25.",
									"ets:fun2ms(fun({A,B}) when A > X -> B end)."
								]
							}
						},
						{
							"p": [
								{
									"c": "="
								},
								{
									"c": [
										"'$_'",
										"object()"
									]
								},
								"The following expressions are translated equally:"
							],
							"pre": {
								"input": [
									"ets:fun2ms(fun({A,[B|C]} = D) when A > B -> D end).",
									"ets:fun2ms(fun({A,[B|C]=D}) when A > B -> D end).",
									"ets:fun2ms(fun({A,[B|C]}) when A > B -> D = [B|C], D end)."
								]
							},
							"code": {
								"type": "none",
								"$t": "ets:fun2ms(fun({a,_} = A) -> A end).ets:fun2ms(fun({a,_}) -> object() end)."
							}
						},
						{
							"p": [
								{
									"c": [
										"'$_'",
										"'$*'",
										"object()",
										"'$_'",
										"bindings()",
										"'$*'",
										"ets:match_object/2",
										"ets:select/2"
									]
								},
								"This is the same as:",
								"In this simple case, the former expression is probably preferable in terms of readability.",
								{
									"c": "ets:select/2"
								},
								{
									"c": "'$_'"
								}
							],
							"code": [
								{
									"type": "none",
									"$t": "ets:match_object(Table, {'$1',test,'$2'})."
								},
								{
									"type": "none",
									"$t": "ets:select(Table, ets:fun2ms(fun({A,test,B}) -> object() end))."
								},
								{
									"type": "none",
									"$t": "ets:select(Table, [{{'$1',test,'$2'},[],['$_']}])."
								}
							]
						},
						{
							"p": {
								"c": [
									"is_record/2",
									"is_record(A,t)",
									"{is_record,'$1',t,5}",
									"t"
								]
							}
						},
						{
							"p": {
								"c": [
									"case",
									"if",
									"catch"
								]
							}
						},
						{
							"p": [
								{
									"c": "ms_transform.hrl",
									"em": "runtime error"
								},
								{
									"c": [
										"ets",
										"dbg:fun2ms/1"
									]
								}
							]
						},
						{
							"p": {
								"c": [
									"ets:fun2ms/1",
									"dbg:fun2ms/1"
								]
							}
						}
					]
				}
			}
		],
		"funcs": {
			"func": [
				{
					"name": {
						"name": "format_error",
						"arity": "1",
						"since": ""
					},
					"fsummary": "Error formatting function as required by the parse transformation interface.",
					"desc": {
						"p": "Takes an error code returned by one of the other functions in the module and creates a textual description of the error."
					}
				},
				{
					"name": {
						"name": "parse_transform",
						"arity": "2",
						"since": ""
					},
					"fsummary": "Transforms Erlang abstract format containing calls to ets/dbg:fun2ms/1 into literal match specifications.",
					"type_desc": {
						"variable": "Options",
						"$t": "Option list, required but not used."
					},
					"desc": {
						"p": [
							{
								"c": "ms_transform.hrl"
							},
							{
								"seealso": [
									{
										"marker": "ets",
										"c": "ets"
									},
									{
										"marker": "runtime_tools:dbg#fun2ms/1",
										"c": "dbg:fun2ms/1"
									}
								]
							},
							{
								"seealso": {
									"marker": "erts:match_spec",
									"$t": "Match Specification in Erlang"
								}
							}
						]
					}
				},
				{
					"name": {
						"name": "transform_from_shell",
						"arity": "3",
						"since": ""
					},
					"fsummary": "Used when transforming funs created in the shell into match_specifications.",
					"type_desc": {
						"variable": "BoundEnvironment",
						"$t": "List of variable bindings in the shell environment."
					},
					"desc": {
						"p": {
							"c": [
								"fun2ms/1",
								{
									"anno": "BoundEnvironment"
								}
							]
						}
					}
				}
			]
		}
	}
}