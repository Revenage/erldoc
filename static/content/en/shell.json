{
	"erlref": {
		"header": {
			"copyright": {
				"year": [
					"1996",
					"2017"
				],
				"holder": "Ericsson AB. All Rights Reserved."
			},
			"legalnotice": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
			"title": "shell",
			"prepared": "Bjorn Gustavsson",
			"responsible": "Bjarne Dcker",
			"docno": "1",
			"approved": "Bjarne Dcker",
			"checked": {},
			"date": "1997-01-24",
			"rev": "A",
			"file": "shell.xml"
		},
		"module": {
			"since": "",
			"$t": "shell"
		},
		"modulesummary": "The Erlang shell.",
		"description": {
			"p": [
				"This module provides an Erlang shell.",
				{
					"seealso": [
						{
							"marker": "#history/1",
							"c": "history/1"
						},
						{
							"marker": "#results/1",
							"c": "results/1"
						}
					],
					"c": [
						"shell_history_length",
						"shell_saved_results"
					]
				},
				{
					"seealso": {
						"marker": "#catch_exception/1",
						"c": "catch_exception/1"
					},
					"c": "shell_catch_exception"
				},
				"Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.",
				"The special shell commands all have the syntax of (local) function calls. They are evaluated as normal function calls and many commands can be used in one expression sequence.",
				{
					"c": [
						"user_default",
						"shell_default",
						"user_default"
					]
				},
				"The shell also permits the user to start multiple concurrent jobs. A job can be regarded as a set of processes that can communicate with the shell.",
				"There is some support for reading and printing records in the shell. During compilation record expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents a record, and the record definitions used by the compiler are unavailable at runtime. So, to read the record syntax and print tuples as records when possible, record definitions must be maintained by the shell itself.",
				{
					"c": [
						"shell_default",
						"user_default",
						"user_default",
						"file_info"
					]
				},
				"The shell runs in two modes:",
				"Only the currently connected job can 'talk' to the shell."
			],
			"code": {
				"type": "none",
				"$t": "-include_lib(\"kernel/include/file.hrl\")."
			},
			"list": {
				"type": "bulleted",
				"item": [
					{
						"p": {
							"c": "Normal (possibly restricted)"
						}
					},
					{
						"p": {
							"c": "JCL"
						}
					}
				]
			}
		},
		"section": [
			{
				"title": "Shell Commands",
				"taglist": {
					"tag": [
						{
							"c": "b()"
						},
						{
							"c": "f()"
						},
						{
							"c": "f(X)"
						},
						{
							"c": "h()"
						},
						{
							"c": "history(N)"
						},
						{
							"c": "results(N)"
						},
						{
							"c": "e(N)"
						},
						{
							"c": "v(N)"
						},
						{
							"c": "help()"
						},
						{
							"c": "c(Mod)"
						},
						{
							"c": "catch_exception(Bool)"
						},
						{
							"c": "rd(RecordName, RecordDefinition)"
						},
						{
							"c": "rf()"
						},
						{
							"c": "rf(RecordNames)"
						},
						{
							"c": "rl()"
						},
						{
							"c": "rl(RecordNames)"
						},
						{
							"c": "rp(Term)"
						},
						{
							"c": "rr(Module)"
						},
						{
							"c": "rr(Wildcard)"
						},
						{
							"c": "rr(WildcardOrModule, RecordNames)"
						},
						{
							"c": "rr(WildcardOrModule, RecordNames, Options)"
						}
					],
					"item": [
						{
							"p": "Prints the current variable bindings."
						},
						{
							"p": "Removes all variable bindings."
						},
						{
							"p": {
								"c": "X"
							}
						},
						{
							"p": "Prints the history list."
						},
						{
							"p": {
								"c": "N"
							}
						},
						{
							"p": {
								"c": "N"
							}
						},
						{
							"p": {
								"c": [
									"N",
									"N",
									"N",
									"e(-1)"
								]
							}
						},
						{
							"p": {
								"c": [
									"N",
									"N",
									"N",
									"v(-1)"
								]
							}
						},
						{
							"p": {
								"c": "shell_default:help()"
							}
						},
						{
							"p": {
								"c": [
									"shell_default:c(Mod)",
									"Mod",
									"Mod",
									".erl"
								]
							}
						},
						{
							"p": {
								"c": [
									"false",
									"true"
								]
							}
						},
						{
							"p": {
								"c": [
									"RecordName",
									"RecordDefinition",
									"rr/1,2,3"
								]
							}
						},
						{
							"p": {
								"c": [
									"shell_default",
									"user_default"
								]
							}
						},
						{
							"p": {
								"c": [
									"RecordNames",
									"'_'"
								]
							}
						},
						{
							"p": "Prints all record definitions."
						},
						{
							"p": {
								"c": "RecordNames"
							}
						},
						{
							"p": {
								"c": "Term"
							}
						},
						{
							"p": {
								"c": "Module"
							}
						},
						{
							"p": {
								"c": "Wildcard",
								"seealso": {
									"marker": "filelib",
									"c": "filelib(3)"
								}
							}
						},
						{
							"p": {
								"c": "RecordNames"
							}
						},
						{
							"p": {
								"c": [
									"{i,Dir}",
									"{d,Macro}",
									"{d,Macro,Value}",
									"'_'",
									"RecordNames"
								]
							}
						}
					]
				}
			},
			{
				"title": "Example",
				"p": [
					{
						"c": ">"
					},
					{
						"c": [
							"Str",
							"\"abcd\""
						]
					},
					{
						"c": [
							"L",
							"Str"
						]
					},
					{
						"c": "Descriptor",
						"seealso": {
							"marker": "erts:erlang#list_to_atom/1",
							"c": "list_to_atom/1"
						}
					},
					{
						"c": "L"
					},
					{
						"c": [
							"b()",
							"ok",
							"b()"
						]
					},
					{
						"c": [
							"f(L)",
							"L"
						]
					},
					"Command 7 prints the new bindings.",
					{
						"c": "L"
					},
					{
						"c": [
							"Descriptor",
							"L"
						]
					},
					{
						"c": "L"
					},
					{
						"c": [
							"{P, Q, R}",
							"Descriptor",
							"{4, abc}",
							"** exception error:",
							"L",
							"Str"
						]
					},
					{
						"c": [
							"P",
							"Descriptor"
						]
					},
					{
						"c": [
							"P",
							"Q"
						]
					},
					"Command 16 clears all bindings.",
					{
						"c": "test1:demo(X)"
					},
					{
						"c": [
							"demo(X) ->",
							"put(aa, worked),",
							"X = 1,",
							"X + 10."
						],
						"br": [
							{},
							{},
							{}
						]
					},
					{
						"c": "aa"
					},
					{
						"c": [
							"test1:demo(1)",
							"aa"
						]
					},
					{
						"c": [
							"aa",
							"hello",
							"test1:demo(2)",
							"test1:demo(2)"
						]
					},
					{
						"c": [
							"Z",
							"aa"
						]
					},
					{
						"c": "test1:demo(1)"
					},
					"Commands 28, 29 and 30 use the history facilities of the shell. Command 29 re-evaluates command 28. Command 30 uses the value (result) of command 28. In the cases of a pure function (a function with no side effects), the result is the same. For a function with side effects, the result can be different.",
					{
						"c": "ex.erl"
					},
					{
						"c": "-record(rec, {a, b = val()})."
					},
					{
						"c": [
							"val() ->",
							"3."
						],
						"br": {}
					},
					{
						"c": [
							"ex.erl",
							"ex.beam",
							"rr(ex)"
						]
					},
					{
						"c": "rec"
					},
					{
						"c": [
							"rec",
							"val/0"
						]
					},
					"Command 35 shows the workaround: explicitly assign values to record fields that cannot otherwise be initialized.",
					"Command 36 prints the newly created record using record definitions maintained by the shell.",
					{
						"c": "ex.beam"
					},
					"Command 38 creates a record using the new definition, and prints the result.",
					{
						"c": "rec"
					},
					{
						"c": "test1:loop(N)"
					},
					{
						"c": [
							"loop(N) ->",
							"io:format(\"Hello Number: ~w~n\", [N]),",
							"loop(N+1)."
						],
						"br": [
							{},
							{}
						]
					},
					{
						"c": [
							"test1:loop(0)",
							"^G",
							"JCL",
							"JCL"
						]
					},
					{
						"c": [
							"i",
							"c",
							"** exception exit: killed"
						]
					},
					"Command 42 creates an ETS table.",
					"Command 43 tries to insert a tuple into the ETS table, but the first argument (the table) is missing. The exception kills the evaluator process.",
					"Command 44 corrects the mistake, but the ETS table has been destroyed as it was owned by the killed evaluator process.",
					{
						"c": [
							"true",
							"erl -stdlib shell_catch_exception true"
						]
					},
					"Command 48 makes the same mistake as in command 43, but this time the evaluator process lives on. The single star at the beginning of the printout signals that the exception has been caught.",
					"Command 49 successfully inserts the tuple into the ETS table.",
					{
						"c": [
							"<0.60.0>",
							"#Port<0.536>",
							"#Ref<0.1662103692.2407792644.214210>",
							"#Fun<a.b.1>"
						]
					},
					"Command 51 exits the Erlang runtime system."
				],
				"pre": [
					{
						"input": [
							"erl",
							"Str = \"abcd\"."
						]
					},
					{
						"input": "L = length(Str)."
					},
					{
						"input": "Descriptor = {L, list_to_atom(Str)}."
					},
					{
						"input": "L."
					},
					{
						"input": "b()."
					},
					{
						"input": "f(L)."
					},
					{
						"input": "b()."
					},
					{
						"input": "f(L)."
					},
					{
						"input": "{L, _} = Descriptor."
					},
					{
						"input": "L."
					},
					{
						"input": "{P, Q, R} = Descriptor."
					},
					{
						"input": [
							"P.",
							"Descriptor."
						]
					},
					{
						"input": [
							"{P, Q} = Descriptor.",
							"P."
						]
					},
					{
						"input": "f()."
					},
					{
						"input": [
							"put(aa, hello).",
							"get(aa)."
						]
					},
					{
						"input": "Y = test1:demo(1)."
					},
					{
						"input": [
							"get().",
							"put(aa, hello).",
							"Z = test1:demo(2)."
						]
					},
					{
						"input": [
							"Z.",
							"get(aa)."
						]
					},
					{
						"input": [
							"erase(), put(aa, hello).",
							"spawn(test1, demo, [1]).",
							"get(aa)."
						]
					},
					{
						"input": [
							"io:format(\"hello hello\\n\").",
							"e(28).",
							"v(28)."
						]
					},
					{
						"input": [
							"c(ex).",
							"rr(ex)."
						]
					},
					{
						"input": "rl(rec)."
					},
					{
						"input": "#rec{}."
					},
					{
						"input": "#rec{b = 3}."
					},
					{
						"input": "rp(v(-1))."
					},
					{
						"input": "rd(rec, {f = orddict:new()})."
					},
					{
						"input": "#rec{}."
					},
					{
						"input": [
							"rd(rec, {c}), A.",
							"#rec{}."
						]
					},
					{
						"input": "test1:loop(0)."
					},
					{
						"input": "E = ets:new(t, [])."
					},
					{
						"input": "ets:insert({d,1,2})."
					},
					{
						"input": "ets:insert(E, {d,1,2})."
					},
					{
						"input": [
							"f(E).",
							"catch_exception(true)."
						]
					},
					{
						"input": [
							"E = ets:new(t, []).",
							"ets:insert({d,1,2})."
						]
					},
					{
						"input": "ets:insert(E, {d,1,2})."
					},
					{
						"input": "ets:insert(#Ref<0.1662103692.2407923716.214197>, {e,3,4})."
					},
					{
						"input": "halt()."
					}
				]
			},
			{
				"title": "JCL Mode",
				"p": [
					{
						"c": [
							"job",
							"connected",
							"detached",
							"blocked"
						]
					},
					"All jobs that do not use standard I/O run in the normal way.",
					{
						"c": [
							"^G",
							"JCL",
							"JCL",
							"\"-->\"",
							"\"?\""
						]
					},
					{
						"c": "JCL"
					},
					{
						"c": [
							"shell_esc",
							"jcl",
							"erl -stdlib shell_esc jcl",
							"abort",
							"erl -stdlib shell_esc abort",
							"^G",
							"JCL",
							"^G",
							"JCL",
							"shell_esc",
							"abort"
						]
					},
					{
						"c": [
							"-remsh",
							"erl -sname this_node -remsh other_node@other_host"
						]
					}
				],
				"pre": "--> ?c [nn] - connect to jobi [nn] - interrupt jobk [nn] - kill jobj - list all jobss [shell] - start local shellr [node [shell]] - start remote shellq - quit erlang? | h - this message",
				"taglist": {
					"tag": [
						{
							"c": "c [nn]"
						},
						{
							"c": "i [nn]"
						},
						{
							"c": "k [nn]"
						},
						{
							"c": "j"
						},
						{
							"c": "s"
						},
						{
							"c": "s [shell]"
						},
						{
							"c": "r [node]"
						},
						{
							"c": "q"
						},
						{
							"c": "?"
						}
					],
					"item": [
						{
							"p": {
								"c": "<nn>"
							}
						},
						{
							"p": {
								"c": "nn"
							}
						},
						{
							"p": {
								"c": [
									"nn",
									"group_leader/1"
								]
							}
						},
						{
							"p": "Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'."
						},
						{
							"p": {
								"c": "[nn]"
							}
						},
						{
							"p": {
								"c": [
									"[nn]",
									"shell"
								]
							}
						},
						{
							"p": {
								"c": [
									"node",
									"shell"
								]
							}
						},
						{
							"p": {
								"c": "+Bi"
							}
						},
						{
							"p": "Displays the help message above."
						}
					]
				}
			},
			{
				"title": "Restricted Shell",
				"p": [
					{
						"c": "+Bi"
					},
					{
						"c": [
							"true",
							"false"
						]
					},
					{
						"seealso": {
							"marker": "erl_eval",
							"c": "erl_eval"
						},
						"c": "ArgList"
					},
					{
						"c": [
							"State",
							"{ShellState,ExprState}",
							"NewState",
							"ShellState",
							"ExprState"
						]
					},
					"There are two ways to start a restricted shell session:",
					{
						"em": "Notes:"
					},
					"Errors when loading the callback module is handled in different ways depending on how the restricted shell is activated:"
				],
				"list": [
					{
						"type": "bulleted",
						"item": [
							{
								"p": [
									{
										"c": "local_allowed(Func, ArgList, State) -> {boolean(),NewState}"
									},
									{
										"c": [
											"Func",
											"ArgList"
										]
									}
								]
							},
							{
								"p": [
									{
										"c": "non_local_allowed(FuncSpec, ArgList, State) -> {boolean(),NewState} | {{redirect,NewFuncSpec,NewArgList},NewState}"
									},
									{
										"c": [
											"FuncSpec",
											"{Module,Func}",
											"ArgList",
											"{redirect,NewFuncSpec,NewArgList}",
											"FuncSpec",
											"ArgList"
										]
									}
								]
							}
						]
					},
					{
						"type": "bulleted",
						"item": [
							{
								"p": {
									"c": [
										"restricted_shell",
										"callback_mod.erl",
										"$ erl -stdlib restricted_shell callback_mod"
									]
								}
							},
							{
								"p": {
									"seealso": {
										"marker": "#start_restricted/1",
										"c": "start_restricted/1"
									}
								}
							}
						]
					},
					{
						"type": "bulleted",
						"item": [
							{
								"p": "When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively."
							},
							{
								"p": "If restricted mode has been enabled on a particular node, remote shells connecting to this node also run in restricted mode."
							},
							{
								"p": "The callback functions cannot be used to allow or disallow execution of functions called from compiled code (only functions called from expressions entered at the shell prompt)."
							}
						]
					},
					{
						"type": "bulleted",
						"item": [
							{
								"p": {
									"c": [
										"q()",
										"init:stop()"
									]
								}
							},
							{
								"p": {
									"seealso": {
										"marker": "#start_restricted/1",
										"c": "start_restricted/1"
									},
									"c": "{error,Reason}"
								}
							}
						]
					}
				]
			},
			{
				"title": "Prompting",
				"p": [
					{
						"seealso": {
							"marker": "#prompt_func/1",
							"c": "prompt_func/1"
						},
						"c": "shell_prompt_func"
					},
					{
						"c": [
							"{Mod,Func}",
							"Mod:Func(L)",
							"L",
							"{history, N}",
							"N",
							"Mod:Func(L)"
						]
					}
				]
			}
		],
		"funcs": {
			"func": [
				{
					"name": {
						"since": "",
						"$t": "catch_exception(Bool) -> boolean()"
					},
					"fsummary": "Set the exception handling of the shell.",
					"type": {
						"v": "Bool = boolean()"
					},
					"desc": {
						"p": {
							"c": [
								"false",
								"true"
							]
						}
					}
				},
				{
					"name": {
						"name": "history",
						"arity": "1",
						"since": ""
					},
					"fsummary": "Set the number of previous commands to keep.",
					"desc": {
						"p": {
							"c": {
								"anno": "N"
							}
						}
					}
				},
				{
					"name": {
						"name": "prompt_func",
						"arity": "1",
						"since": "OTP R13B04"
					},
					"fsummary": "Set the shell prompt.",
					"desc": {
						"p": {
							"c": {
								"anno": "PromptFunc"
							}
						}
					}
				},
				{
					"name": {
						"name": "results",
						"arity": "1",
						"since": ""
					},
					"fsummary": "Set the number of previous results to keep.",
					"desc": {
						"p": {
							"c": {
								"anno": "N"
							}
						}
					}
				},
				{
					"name": {
						"name": "start_restricted",
						"arity": "1",
						"since": ""
					},
					"fsummary": "Exit a normal shell and starts a restricted shell.",
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Module"
									},
									"local_allowed/3",
									"non_local_allowed/3"
								]
							},
							{
								"c": {
									"anno": "Reason"
								}
							}
						]
					}
				},
				{
					"name": {
						"name": "stop_restricted",
						"arity": "0",
						"since": ""
					},
					"fsummary": "Exit a restricted shell and starts a normal shell.",
					"desc": {
						"p": "Exits a restricted shell and starts a normal shell. The function is meant to be called from the shell."
					}
				},
				{
					"name": {
						"name": "strings",
						"arity": "1",
						"since": "OTP R16B"
					},
					"fsummary": "Set the shell's string recognition flag.",
					"desc": {
						"p": [
							{
								"c": {
									"anno": "Strings"
								}
							},
							{
								"c": [
									"shell_strings",
									"true",
									"false"
								]
							}
						]
					}
				}
			]
		}
	}
}