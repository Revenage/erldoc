{
	"erlref": {
		"header": {
			"copyright": {
				"year": [
					"1996",
					"2018"
				],
				"holder": "Ericsson AB. All Rights Reserved."
			},
			"legalnotice": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
			"title": "io",
			"prepared": {},
			"docno": {},
			"date": {},
			"rev": {}
		},
		"module": {
			"since": "",
			"$t": "io"
		},
		"modulesummary": "Standard I/O server interface functions.",
		"description": {
			"p": [
				{
					"c": "ok"
				},
				{
					"c": [
						"IoDevice",
						"IoDevice"
					],
					"seealso": {
						"marker": "kernel:file#open/2",
						"c": "file:open/2"
					}
				},
				{
					"seealso": {
						"marker": "io_protocol",
						"$t": "The Erlang I/O Protocol"
					}
				}
			],
			"warning": {
				"p": [
					{
						"seealso": [
							{
								"marker": "#put_chars/2",
								"c": "put_chars/2"
							},
							{
								"marker": "unicode#type-chardata",
								"c": "unicode:chardata()"
							}
						]
					},
					{
						"seealso": [
							{
								"marker": "#get_chars/2",
								"c": "get_chars/2,3"
							},
							{
								"marker": "#get_line/1",
								"c": "get_line/1,2"
							}
						]
					},
					{
						"seealso": {
							"marker": "kernel:file",
							"c": "file"
						}
					},
					{
						"seealso": {
							"marker": "stdlib:unicode",
							"c": "unicode"
						}
					}
				]
			}
		},
		"datatypes": {
			"datatype": [
				{
					"name": {
						"name": "device"
					},
					"desc": {
						"p": {
							"c": [
								"standard_io",
								"standard_error"
							],
							"seealso": {
								"marker": "kernel:file#open/2",
								"c": "file:open/2"
							}
						}
					}
				},
				{
					"name": {
						"name": "opt_pair"
					}
				},
				{
					"name": {
						"name": "expand_fun"
					}
				},
				{
					"name": {
						"name": "encoding"
					}
				},
				{
					"name": {
						"name": "setopt"
					}
				},
				{
					"name": {
						"name": "format"
					}
				},
				{
					"name": {
						"name": "location"
					}
				},
				{
					"name": {
						"name": "prompt"
					}
				},
				{
					"name": {
						"name": "server_no_data"
					},
					"desc": {
						"p": "What the I/O server sends when there is no data."
					}
				}
			]
		},
		"funcs": {
			"func": [
				{
					"name": [
						{
							"name": "columns",
							"arity": "0",
							"since": ""
						},
						{
							"name": "columns",
							"arity": "1",
							"since": ""
						}
					],
					"fsummary": "Get the number of columns of an I/O device.",
					"desc": {
						"p": {
							"c": [
								{
									"anno": "IoDevice"
								},
								"{error, enotsup}"
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "format",
							"arity": "1",
							"since": ""
						},
						{
							"name": "format",
							"arity": "2",
							"since": ""
						},
						{
							"name": "format",
							"arity": "3",
							"since": ""
						},
						{
							"name": "fwrite",
							"arity": "1",
							"since": ""
						},
						{
							"name": "fwrite",
							"arity": "2",
							"since": ""
						},
						{
							"name": "fwrite",
							"arity": "3",
							"since": ""
						}
					],
					"fsummary": "Write formatted output.",
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Data"
									},
									"[]",
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Format"
									},
									{
										"anno": "Format"
									},
									{
										"anno": "Format"
									},
									"atom_to_list/1",
									"binary_to_list/1"
								]
							},
							{
								"c": "~F.P.PadModC"
							},
							{
								"c": [
									"C",
									"F",
									"P",
									"Pad",
									"Mod",
									"#",
									"Pad",
									"F",
									"P",
									"~..#C"
								]
							},
							{
								"c": [
									"F",
									"P",
									"Pad",
									"*",
									"Data"
								]
							},
							{
								"c": [
									"*",
									"Pad"
								]
							},
							{
								"em": "Available control sequences:"
							},
							"The function returns:",
							"If an error occurs, there is no output. Example:",
							{
								"c": "\"~s\""
							}
						],
						"pre": [
							{
								"input": "io:fwrite(\"Hello world!~n\", [])."
							},
							{
								"input": "io:fwrite(\"~*.*.0f~n\",[9, 5, 3.14159265])."
							},
							{
								"input": "io:fwrite(\"~*.*.*f~n\",[9, 5, $*, 3.14159265])."
							},
							{
								"input": [
									"io:fwrite(\"~s ~w ~i ~w ~c ~n\",['abc def', 'abc def', {foo, 1},{foo, 1}, 65]).",
									"io:fwrite(\"~s\", [65])."
								]
							}
						],
						"list": {
							"type": "bulleted",
							"item": [
								{
									"p": {
										"c": [
											"F",
											"field width",
											"*"
										]
									}
								},
								{
									"p": {
										"c": [
											"P",
											"precision",
											"within"
										]
									}
								},
								{
									"p": {
										"c": [
											"Pad",
											"' '"
										]
									}
								},
								{
									"p": {
										"c": [
											"Mod",
											"Data",
											"t",
											"l",
											"p",
											"P"
										]
									}
								}
							]
						},
						"taglist": [
							{
								"tag": [
									{
										"c": "~"
									},
									{
										"c": "c"
									},
									{
										"c": "f"
									},
									{
										"c": "e"
									},
									{
										"c": "g"
									},
									{
										"c": "s"
									},
									{
										"c": "w"
									},
									{
										"c": "p"
									},
									{
										"c": "W"
									},
									{
										"c": "P"
									},
									{
										"c": "B"
									},
									{
										"c": "X"
									},
									{
										"c": "#"
									},
									{
										"c": "b"
									},
									{
										"c": "x"
									},
									{
										"c": "+"
									},
									{
										"c": "n"
									},
									{
										"c": "i"
									}
								],
								"item": [
									{
										"p": {
											"c": "~"
										}
									},
									{
										"p": [
											"The argument is a number that is interpreted as an ASCII code. The precision is the number of times the character is printed and defaults to the field width, which in turn defaults to 1. Example:",
											{
												"c": "t"
											}
										],
										"pre": [
											{
												"input": "io:fwrite(\"|~10.5c|~-10.5c|~5c|~n\", [$a, $b, $c])."
											},
											{
												"input": [
													"io:fwrite(\"~tc~n\",[1024]).",
													"io:fwrite(\"~c~n\",[1024])."
												]
											}
										]
									},
									{
										"p": {
											"c": "[-]ddd.ddd"
										}
									},
									{
										"p": {
											"c": "[-]d.ddde+-ddd"
										}
									},
									{
										"p": {
											"c": [
												"f",
												"e",
												"f",
												"e"
											]
										}
									},
									{
										"p": [
											{
												"c": [
													"iolist()",
													"binary()",
													"atom()",
													"t",
													"unicode:chardata()"
												]
											},
											"This format can be used for printing any object and truncating the output so it fits a specified field:",
											"A list with integers > 255 is considered an error if the Unicode translation modifier is not specified:"
										],
										"pre": [
											{
												"input": [
													"io:fwrite(\"|~10w|~n\", [{hey, hey, hey}]).",
													"io:fwrite(\"|~10s|~n\", [io_lib:write({hey, hey, hey})]).",
													"io:fwrite(\"|~-10.8s|~n\", [io_lib:write({hey, hey, hey})])."
												]
											},
											{
												"input": [
													"io:fwrite(\"~ts~n\",[[1024]]).",
													"io:fwrite(\"~s~n\",[[1024]])."
												]
											}
										]
									},
									{
										"p": {
											"c": "t"
										}
									},
									{
										"p": [
											{
												"c": "~w"
											},
											{
												"em": "same",
												"seealso": [
													{
														"marker": "#write/1",
														"c": "write/1"
													},
													{
														"marker": "#format/1",
														"c": "format/1,2,3"
													}
												],
												"c": "T"
											},
											{
												"c": "0"
											},
											{
												"c": "l"
											},
											{
												"c": "t"
											},
											{
												"c": "+pc unicode",
												"seealso": {
													"marker": "#printable_range/0",
													"c": "printable_range/0"
												}
											},
											{
												"c": "+pc unicode"
											},
											{
												"c": "t"
											}
										],
										"pre": [
											{
												"input": [
													"T = [{attributes,[[{id,age,1.50000},{mode,explicit},",
													"{typename,\"INTEGER\"}], [{id,cho},{mode,explicit},{typename,'Cho'}]]},",
													"{typename,'Person'},{tag,{'PRIVATE',3}},{mode,implicit}].",
													"io:fwrite(\"~w~n\", [T]).",
													"io:fwrite(\"~62p~n\", [T])."
												]
											},
											{
												"input": "io:fwrite(\"Here T = ~62p~n\", [T])."
											},
											{
												"input": "io:fwrite(\"~0p~n\", [lists:seq(1, 30)])."
											},
											{
												"input": [
													"S = [{a,\"a\"}, {b, \"b\"}], io:fwrite(\"~15p~n\", [S]).",
													"io:fwrite(\"~15lp~n\", [S])."
												]
											},
											{
												"input": [
													"io:fwrite(\"~p~n\",[list_to_atom([1024])]).",
													"io:fwrite(\"~tp~n\",[list_to_atom([1024])])."
												]
											},
											{
												"input": [
													"io:fwrite(\"~p~n\",[[214]]).",
													"io:fwrite(\"~p~n\",[[1024]]).",
													"io:fwrite(\"~tp~n\",[[1024]])."
												]
											},
											{
												"input": [
													"io:fwrite(\"~p~n\",[[1024]]).",
													"io:fwrite(\"~tp~n\",[[1024]])."
												]
											},
											{
												"input": [
													"io:fwrite(\"~p~n\", [<<208,128>>]).",
													"io:fwrite(\"~tp~n\", [<<208,128>>]).",
													"io:fwrite(\"~tp~n\", [<<128,128>>])."
												]
											}
										]
									},
									{
										"p": [
											{
												"c": [
													"~w",
													"...",
													"T"
												]
											},
											{
												"c": ",..."
											}
										],
										"pre": {
											"input": "io:fwrite(\"~W~n\", [T,9])."
										}
									},
									{
										"p": {
											"c": [
												"~p",
												"..."
											]
										},
										"pre": {
											"input": "io:fwrite(\"~62P~n\", [T,9])."
										}
									},
									{
										"p": [
											"Writes an integer in base 2-36, the default base is 10. A leading dash is printed for negative integers.",
											"The precision field selects base, for example:"
										],
										"pre": {
											"input": [
												"io:fwrite(\"~.16B~n\", [31]).",
												"io:fwrite(\"~.2B~n\", [-19]).",
												"io:fwrite(\"~.36B~n\", [5*36+35])."
											]
										}
									},
									{
										"p": [
											{
												"c": "B"
											},
											"The prefix can be a possibly deep list of characters or an atom. Example:"
										],
										"pre": {
											"input": [
												"io:fwrite(\"~X~n\", [31,\"10#\"]).",
												"io:fwrite(\"~.16X~n\", [-31,\"0x\"])."
											]
										}
									},
									{
										"p": {
											"c": [
												"B",
												"#"
											]
										},
										"pre": {
											"input": [
												"io:fwrite(\"~.10#~n\", [31]).",
												"io:fwrite(\"~.16#~n\", [-31])."
											]
										}
									},
									{
										"p": {
											"c": "B"
										}
									},
									{
										"p": {
											"c": "X"
										}
									},
									{
										"p": {
											"c": "#"
										}
									},
									{
										"p": "Writes a new line."
									},
									{
										"p": "Ignores the next term."
									}
								]
							},
							{
								"tag": {
									"c": "ok"
								},
								"item": {
									"p": "The formatting succeeded."
								}
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "fread",
							"arity": "2",
							"since": ""
						},
						{
							"name": "fread",
							"arity": "3",
							"since": ""
						}
					],
					"fsummary": "Read formatted input.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									},
									{
										"anno": "Format"
									},
									{
										"anno": "Format"
									}
								]
							},
							{
								"c": {
									"anno": "Format"
								}
							},
							{
								"em": "Examples:"
							}
						],
						"list": {
							"type": "bulleted",
							"item": [
								{
									"p": {
										"em": [
											"Space",
											"Tab",
											"Newline"
										]
									}
								},
								{
									"p": "Ordinary characters that must match the next input character."
								},
								{
									"p": [
										{
											"c": "~*FMC"
										},
										"Unless otherwise specified, leading whitespace is ignored for all control sequences. An input field cannot be more than one line wide.",
										{
											"em": "Available control sequences:"
										},
										"The function returns:"
									],
									"list": {
										"type": "bulleted",
										"item": [
											{
												"p": {
													"c": "*"
												}
											},
											{
												"p": {
													"c": [
														"F",
														"field width"
													]
												}
											},
											{
												"p": {
													"c": [
														"M",
														"t"
													]
												}
											},
											{
												"p": {
													"c": "C"
												}
											}
										]
									},
									"taglist": [
										{
											"tag": [
												{
													"c": "~"
												},
												{
													"c": "d"
												},
												{
													"c": "u"
												},
												{
													"c": "-"
												},
												{
													"c": "#"
												},
												{
													"c": "f"
												},
												{
													"c": "s"
												},
												{
													"c": "a"
												},
												{
													"c": "c"
												},
												{
													"c": "l"
												}
											],
											"item": [
												{
													"p": {
														"c": "~"
													}
												},
												{
													"p": "A decimal integer is expected."
												},
												{
													"p": "An unsigned integer in base 2-36 is expected. The field width parameter is used to specify base. Leading whitespace characters are not skipped."
												},
												{
													"p": {
														"c": [
															"-",
															"-1",
															"+",
															"1"
														]
													}
												},
												{
													"p": {
														"c": "\"16#ffff\""
													}
												},
												{
													"p": "A floating point number is expected. It must follow the Erlang floating point number syntax."
												},
												{
													"p": [
														"A string of non-whitespace characters is read. If a field width has been specified, this number of characters are read and all trailing whitespace characters are stripped. An Erlang string (list of characters) is returned.",
														{
															"c": "~ts"
														}
													],
													"pre": {
														"input": [
															"io:fread(\"Prompt> \",\"~s\").",
															"<Characters beyond latin1 range not printable in this medium>",
															"io:fread(\"Prompt> \",\"~ts\").",
															"<Characters beyond latin1 range not printable in this medium>"
														]
													}
												},
												{
													"p": {
														"c": "s"
													}
												},
												{
													"p": [
														{
															"c": "s"
														},
														{
															"c": "s"
														}
													],
													"pre": {
														"input": [
															"io:fread(\"Prompt> \",\"~c\").",
															"<Character beyond latin1 range not printable in this medium>",
															"io:fread(\"Prompt> \",\"~tc\").",
															"<Character beyond latin1 range not printable in this medium>"
														]
													}
												},
												{
													"p": "Returns the number of characters that have been scanned up to that point, including whitespace characters."
												}
											]
										},
										{
											"tag": [
												{
													"c": {
														"anno": "Terms"
													}
												},
												{
													"c": "eof"
												},
												{
													"c": {
														"anno": "FreadError"
													}
												},
												{
													"c": {
														"anno": "ErrorDescription"
													}
												}
											],
											"item": [
												{
													"p": {
														"c": {
															"anno": "Terms"
														}
													}
												},
												{
													"p": "End of file was encountered."
												},
												{
													"p": {
														"c": "FreadError"
													}
												},
												{
													"p": {
														"c": {
															"anno": "ErrorDescription"
														}
													}
												}
											]
										}
									]
								}
							]
						},
						"pre": {
							"input": [
								"io:fread('enter>', \"~f~f~f\").",
								"1.9 35.5e3 15.0",
								"io:fread('enter>', \"~10f~d\").",
								"5.67899",
								"io:fread('enter>', \":~10s:~10c:\").",
								":",
								"alan",
								":",
								"joe",
								":"
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "get_chars",
							"arity": "2",
							"since": ""
						},
						{
							"name": "get_chars",
							"arity": "3",
							"since": ""
						}
					],
					"fsummary": "Read a specified number of characters.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Count"
									},
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									}
								]
							},
							"The function returns:"
						],
						"taglist": {
							"tag": [
								{
									"c": {
										"anno": "Data"
									}
								},
								{
									"c": "eof"
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": {
										"c": "latin1"
									}
								},
								{
									"p": "End of file was encountered."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "get_line",
							"arity": "1",
							"since": ""
						},
						{
							"name": "get_line",
							"arity": "2",
							"since": ""
						}
					],
					"fsummary": "Read a line.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									}
								]
							},
							"The function returns:"
						],
						"taglist": {
							"tag": [
								{
									"c": {
										"anno": "Data"
									}
								},
								{
									"c": "eof"
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": {
										"c": "latin1"
									}
								},
								{
									"p": "End of file was encountered."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "getopts",
							"arity": "0",
							"since": ""
						},
						{
							"name": "getopts",
							"arity": "1",
							"since": ""
						}
					],
					"fsummary": "Get the supported options and values from an I/O server.",
					"desc": {
						"p": [
							"Requests all available options and their current values for a specific I/O device, for example:",
							{
								"c": [
									"encoding",
									"binary"
								]
							},
							"This example is, as can be seen, run in an environment where the terminal supports Unicode input and output."
						],
						"pre": [
							{
								"input": [
									"{ok,F} = file:open(\"/dev/null\",[read]).",
									"io:getopts(F)."
								]
							},
							"3> io:getopts().[{expand_fun,#Fun<group.0.120017273>}, {echo,true}, {binary,false}, {encoding,unicode}]"
						]
					}
				},
				{
					"name": [
						{
							"name": "nl",
							"arity": "0",
							"since": ""
						},
						{
							"name": "nl",
							"arity": "1",
							"since": ""
						}
					],
					"fsummary": "Write a newline.",
					"desc": {
						"p": {
							"c": {
								"anno": "IoDevice"
							}
						}
					}
				},
				{
					"name": [
						{
							"name": "parse_erl_exprs",
							"arity": "1",
							"since": ""
						},
						{
							"name": "parse_erl_exprs",
							"arity": "2",
							"since": ""
						},
						{
							"name": "parse_erl_exprs",
							"arity": "3",
							"since": ""
						},
						{
							"name": "parse_erl_exprs",
							"arity": "4",
							"since": "OTP R16B"
						}
					],
					"fsummary": "Read, tokenize, and parse Erlang expressions.",
					"type": [
						{
							"name": "parse_ret"
						},
						{
							"name": "server_no_data"
						}
					],
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									},
									{
										"anno": "StartLocation"
									},
									"1",
									{
										"anno": "Options"
									},
									"Options",
									"."
								],
								"seealso": {
									"marker": "erl_scan#tokens/4",
									"c": "erl_scan:tokens/4"
								}
							},
							"The function returns:",
							"Example:"
						],
						"taglist": {
							"tag": [
								{
									"c": "{ok, ExprList, EndLocation}"
								},
								{
									"c": "{eof, EndLocation}"
								},
								{
									"c": "eof"
								},
								{
									"c": "{error, ErrorInfo, ErrorLocation}"
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": "The parsing was successful."
								},
								{
									"p": "End of file was encountered by the tokenizer."
								},
								{
									"p": "End of file was encountered by the I/O server."
								},
								{
									"p": "An error occurred while tokenizing or parsing."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						},
						"pre": {
							"input": [
								"io:parse_erl_exprs('enter>').",
								"abc(), \"hey\".",
								"io:parse_erl_exprs ('enter>').",
								"abc(\"hey\"."
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "parse_erl_form",
							"arity": "1",
							"since": ""
						},
						{
							"name": "parse_erl_form",
							"arity": "2",
							"since": ""
						},
						{
							"name": "parse_erl_form",
							"arity": "3",
							"since": ""
						},
						{
							"name": "parse_erl_form",
							"arity": "4",
							"since": "OTP R16B"
						}
					],
					"fsummary": "Read, tokenize, and parse an Erlang form.",
					"type": [
						{
							"name": "parse_form_ret"
						},
						{
							"name": "server_no_data"
						}
					],
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									},
									{
										"anno": "StartLocation"
									},
									"1",
									{
										"anno": "Options"
									},
									"Options",
									"."
								],
								"seealso": {
									"marker": "erl_scan#tokens/4",
									"c": "erl_scan:tokens/4"
								}
							},
							"The function returns:"
						],
						"taglist": {
							"tag": [
								{
									"c": "{ok, AbsForm, EndLocation}"
								},
								{
									"c": "{eof, EndLocation}"
								},
								{
									"c": "eof"
								},
								{
									"c": "{error, ErrorInfo, ErrorLocation}"
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": "The parsing was successful."
								},
								{
									"p": "End of file was encountered by the tokenizer."
								},
								{
									"p": "End of file was encountered by the I/O server."
								},
								{
									"p": "An error occurred while tokenizing or parsing."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						}
					}
				},
				{
					"name": {
						"name": "printable_range",
						"arity": "0",
						"since": "OTP R16B"
					},
					"fsummary": "Get user-requested printable character range.",
					"desc": {
						"p": [
							"Returns the user-requested range of printable Unicode characters.",
							{
								"c": "+pc <range>"
							},
							{
								"c": [
									"<range>",
									"latin1",
									"unicode",
									"latin1",
									"unicode"
								]
							},
							{
								"c": "latin1"
							},
							{
								"seealso": {
									"marker": "io_lib#printable_list/1",
									"c": "io_lib:printable_list/1"
								}
							}
						],
						"note": {
							"p": {
								"seealso": {
									"marker": "io_lib#printable_list/1",
									"c": "io_lib:printable_list/1"
								}
							}
						}
					}
				},
				{
					"name": [
						{
							"name": "put_chars",
							"arity": "1",
							"since": ""
						},
						{
							"name": "put_chars",
							"arity": "2",
							"since": ""
						}
					],
					"fsummary": "Write a list of characters.",
					"desc": {
						"p": {
							"c": [
								{
									"anno": "CharData"
								},
								{
									"anno": "IoDevice"
								}
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "read",
							"arity": "1",
							"since": ""
						},
						{
							"name": "read",
							"arity": "2",
							"since": ""
						}
					],
					"fsummary": "Read a term.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Term"
									},
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									}
								]
							},
							"The function returns:"
						],
						"taglist": {
							"tag": [
								{
									"c": {
										"anno": "Term"
									}
								},
								{
									"c": "eof"
								},
								{
									"c": {
										"anno": "ErrorInfo"
									}
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": "The parsing was successful."
								},
								{
									"p": "End of file was encountered."
								},
								{
									"p": "The parsing failed."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "read",
							"arity": "3",
							"since": ""
						},
						{
							"name": "read",
							"arity": "4",
							"since": "OTP R16B"
						}
					],
					"fsummary": "Read a term.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Term"
									},
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									},
									{
										"anno": "StartLocation"
									},
									{
										"anno": "Options"
									},
									"Options"
								],
								"seealso": {
									"marker": "erl_scan#tokens/4",
									"c": "erl_scan:tokens/4"
								}
							},
							"The function returns:"
						],
						"taglist": {
							"tag": [
								{
									"c": {
										"anno": "EndLocation"
									}
								},
								{
									"c": {
										"anno": "EndLocation"
									}
								},
								{
									"c": {
										"anno": [
											"ErrorInfo",
											"ErrorLocation"
										]
									}
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": "The parsing was successful."
								},
								{
									"p": "End of file was encountered."
								},
								{
									"p": "The parsing failed."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "rows",
							"arity": "0",
							"since": ""
						},
						{
							"name": "rows",
							"arity": "1",
							"since": ""
						}
					],
					"fsummary": "Get the number of rows of an I/O device.",
					"desc": {
						"p": {
							"c": [
								{
									"anno": "IoDevice"
								},
								"{error, enotsup}"
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "scan_erl_exprs",
							"arity": "1",
							"since": ""
						},
						{
							"name": "scan_erl_exprs",
							"arity": "2",
							"since": ""
						},
						{
							"name": "scan_erl_exprs",
							"arity": "3",
							"since": ""
						},
						{
							"name": "scan_erl_exprs",
							"arity": "4",
							"since": "OTP R16B"
						}
					],
					"fsummary": "Read and tokenize Erlang expressions.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									"IoDevice",
									"Prompt",
									"StartLocation",
									"1",
									{
										"anno": "Options"
									},
									"Options",
									"."
								],
								"seealso": {
									"marker": "erl_scan#tokens/4",
									"c": "erl_scan:tokens/4"
								}
							},
							"The function returns:",
							{
								"em": "Example:"
							}
						],
						"taglist": {
							"tag": [
								{
									"c": "{ok, Tokens, EndLocation}"
								},
								{
									"c": "{eof, EndLocation}"
								},
								{
									"c": "eof"
								},
								{
									"c": "{error, ErrorInfo, ErrorLocation}"
								},
								{
									"c": {
										"anno": "ErrorDescription"
									}
								}
							],
							"item": [
								{
									"p": "The tokenization succeeded."
								},
								{
									"p": "End of file was encountered by the tokenizer."
								},
								{
									"p": "End of file was encountered by the I/O server."
								},
								{
									"p": "An error occurred while tokenizing."
								},
								{
									"p": {
										"c": "{error, estale}"
									}
								}
							]
						},
						"pre": {
							"input": [
								"io:scan_erl_exprs('enter>').",
								"abc(), \"hey\".",
								"io:scan_erl_exprs('enter>').",
								"1.0er."
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "scan_erl_form",
							"arity": "1",
							"since": ""
						},
						{
							"name": "scan_erl_form",
							"arity": "2",
							"since": ""
						},
						{
							"name": "scan_erl_form",
							"arity": "3",
							"since": ""
						},
						{
							"name": "scan_erl_form",
							"arity": "4",
							"since": "OTP R16B"
						}
					],
					"fsummary": "Read and tokenize an Erlang form.",
					"type": {
						"name": "server_no_data"
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "IoDevice"
									},
									{
										"anno": "Prompt"
									},
									{
										"anno": "StartLocation"
									},
									"1",
									{
										"anno": "Options"
									},
									"Options",
									"."
								],
								"seealso": {
									"marker": "erl_scan#tokens/4",
									"c": "erl_scan:tokens/4"
								}
							},
							{
								"seealso": {
									"marker": "#scan_erl_exprs/1",
									"c": "scan_erl_exprs/1,2,3,4"
								}
							}
						]
					}
				},
				{
					"name": [
						{
							"name": "setopts",
							"arity": "1",
							"since": ""
						},
						{
							"name": "setopts",
							"arity": "2",
							"since": ""
						}
					],
					"fsummary": "Set options.",
					"desc": {
						"p": [
							{
								"c": {
									"anno": "IoDevice"
								}
							},
							{
								"seealso": {
									"marker": "#getopts/1",
									"c": "getopts/1"
								}
							},
							"The options and values supported by the OTP I/O devices are as follows:"
						],
						"taglist": {
							"tag": [
								{
									"c": [
										"binary",
										"list",
										"{binary, boolean()}"
									]
								},
								{
									"c": "{echo, boolean()}"
								},
								{
									"c": "{expand_fun, expand_fun()}"
								},
								{
									"c": "{encoding, latin1 | unicode}"
								},
								{
									"c": "{encoding, utf8 | utf16 | utf32 | {utf16,big} | {utf16,little} | {utf32,big} | {utf32,little}}"
								}
							],
							"item": [
								{
									"p": [
										{
											"c": [
												"binary",
												"{binary, true}",
												"get_line",
												"get_chars",
												"get_until"
											],
											"seealso": [
												{
													"marker": "io_protocol",
													"$t": "The Erlang I/O Protocol"
												},
												{
													"marker": "#get_chars/2",
													"c": "get_chars/2,3"
												},
												{
													"marker": "#get_line/1",
													"c": "get_line/1,2"
												}
											]
										},
										{
											"c": "list"
										},
										{
											"c": [
												"group.erl",
												"user.erl"
											]
										}
									]
								},
								{
									"p": {
										"c": "group.erl"
									}
								},
								{
									"p": [
										{
											"em": "Tab",
											"seealso": {
												"marker": "#get_line/1",
												"c": "get_line/1,2"
											}
										},
										{
											"c": [
												"{yes|no, string(), [string(), ...]}",
												"no"
											]
										},
										{
											"c": "\"quit\""
										},
										{
											"c": "group.erl"
										}
									],
									"code": {
										"type": "none",
										"$t": "fun(\"\") -> {yes, \"quit\", []}; (_) -> {no, \"\", [\"quit\"]} end"
									}
								},
								{
									"p": [
										"Specifies how characters are input or output from or to the I/O device, implying that, for example, a terminal is set to handle Unicode input and output or a file is set to handle UTF-8 data encoding.",
										{
											"em": "does not"
										},
										{
											"c": [
												"unicode",
												"latin1",
												"LANG",
												"LC_CTYPE",
												"{encoding, unicode}"
											]
										},
										{
											"c": "latin1"
										},
										{
											"c": "{encoding, unicode}"
										},
										{
											"c": [
												"{encoding, unicode | latin1}",
												"group.erl",
												"werl",
												"user.erl"
											]
										}
									]
								},
								{
									"p": [
										"For disk files, the encoding can be set to various UTF variants. This has the effect that data is expected to be read as the specified encoding from the file, and the data is written in the specified encoding to the disk file.",
										{
											"c": [
												"{encoding, utf8}",
												"{encoding, unicode}"
											]
										},
										{
											"seealso": {
												"marker": "kernel:file#open/2",
												"c": "file:open/2"
											}
										}
									]
								}
							]
						}
					}
				},
				{
					"name": [
						{
							"name": "write",
							"arity": "1",
							"since": ""
						},
						{
							"name": "write",
							"arity": "2",
							"since": ""
						}
					],
					"fsummary": "Write a term.",
					"desc": {
						"p": {
							"c": [
								{
									"anno": "Term"
								},
								{
									"anno": "IoDevice"
								}
							]
						}
					}
				}
			]
		},
		"section": [
			{
				"title": "Standard Input/Output",
				"p": [
					{
						"c": [
							"IoDevice",
							"IoDevice",
							"standard_io"
						]
					},
					{
						"c": "user"
					}
				],
				"pre": {
					"input": [
						"io:read('enter>').",
						"foo.",
						"io:read(standard_io, 'enter>').",
						"bar."
					]
				}
			},
			{
				"title": "Standard Error",
				"p": {
					"c": "standard_error"
				},
				"pre": {
					"input": [
						"erl -noshell -noinput -eval 'io:format(standard_error,\"Error: ~s~n\",[\"error 11\"]),'\\",
						"'init:stop().' > /dev/null"
					]
				}
			},
			{
				"title": "Error Information",
				"p": [
					{
						"c": [
							"ErrorInfo",
							"ErrorInfo"
						]
					},
					"A string that describes the error is obtained with the following call:"
				],
				"code": [
					{
						"type": "none",
						"$t": "{ErrorLocation, Module, ErrorDescriptor}"
					},
					{
						"type": "none",
						"$t": "Module:format_error(ErrorDescriptor)"
					}
				]
			}
		]
	}
}