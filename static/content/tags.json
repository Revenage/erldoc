[
  [
    "array",
    "default(Array :: array(Type)) -> Value :: Typefix(Array :: array(Type)) -> array(Type)foldl(Function, InitialAcc :: A, Array :: array(Type)) -> Bfoldr(Function, InitialAcc :: A, Array :: array(Type)) -> Bfrom_list(List :: [Value :: Type]) -> array(Type)from_list(List :: [Value :: Type], Default :: term()) -> array(Type)from_orddict(Orddict :: indx_pairs(Value :: Type)) -> array(Type)from_orddict(Orddict :: indx_pairs(Value :: Type), Default :: Type) -> array(Type)get(I :: array_indx(), Array :: array(Type)) -> Value :: Typeis_array(X :: term()) -> boolean()is_fix(Array :: array()) -> boolean()map(Function, Array :: array(Type1)) -> array(Type2)new() -> array() new(Options :: array_opts()) -> array() new(Size :: integer() >= 0, Options :: array_opts()) -> array() relax(Array :: array(Type)) -> array(Type)reset(I :: array_indx(), Array :: array(Type)) -> array(Type)resize(Array :: array(Type)) -> array(Type)resize(Size :: integer() >= 0, Array :: array(Type)) -> array(Type)set(I :: array_indx(), Value :: Type, Array :: array(Type)) -> array(Type)size(Array :: array()) -> integer() >= 0sparse_foldl(Function, InitialAcc :: A, Array :: array(Type)) -> Bsparse_foldr(Function, InitialAcc :: A, Array :: array(Type)) -> Bsparse_map(Function, Array :: array(Type1)) -> array(Type2)sparse_size(Array :: array()) -> integer() >= 0sparse_to_list(Array :: array(Type)) -> [Value :: Type]sparse_to_orddict(Array :: array(Type)) -> indx_pairs(Value :: Type)to_list(Array :: array(Type)) -> [Value :: Type]to_orddict(Array :: array(Type)) -> indx_pairs(Value :: Type)"
  ],
  [
    "re",
    "version() -> binary()compile(Regexp) -> {ok, MP} | {error, ErrSpec}compile(Regexp, Options) -> {ok, MP} | {error, ErrSpec}inspect(MP, Item) -> {namelist, [binary()]}replace(Subject, RE, Replacement) -> iodata() | unicode:charlist() replace(Subject, RE, Replacement, Options) -> iodata() | unicode:charlist() run(Subject, RE) -> {match, Captured} | nomatchrun(Subject, RE, Options) -> {match, Captured} | match | nomatch | {error, ErrType}split(Subject, RE) -> SplitListsplit(Subject, RE, Options) -> SplitList"
  ],
  [
    "alarm_handler",
    "clear_alarm(AlarmId) -> void()get_alarms() -> [alarm()]set_alarm(alarm())"
  ]
]
