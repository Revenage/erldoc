{"summary":"Utility functions for Core Erlang case/receive clauses.","description":"<p></p><p>Utility functions for Core Erlang case/receive clauses.</p> <p>Syntax trees are defined in the module <span class=\"bold_code bc-19\"><a href=\"/erldoc/docs/cerl\">cerl</a></span>.</p> <p></p>","funcs":"<table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-any_catchall-1-id98868\"></span><a class=\"title_link\" name=\"any_catchall-1\" href=\"/erldoc/docs/#any_catchall-1\">any_catchall(Clauses::[cerl()]) -&gt; boolean()</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"any_catchall-1\"></a> </p><p>Returns <span class=\"code\">true</span> if any of the abstract clauses in the list is a catch-all, otherwise <span class=\"code\">false</span>. See <span class=\"code\">is_catchall/1</span> for details.</p> <p>Note: each node in <span class=\"code\">Clauses</span> must have type <span class=\"code\">clause</span>.</p> <p><strong>See also:</strong> <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#is_catchall-1\">is_catchall/1</a></span>.</p><p></p></div><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-eval_guard-1-id98930\"></span><a class=\"title_link\" name=\"eval_guard-1\" href=\"/erldoc/docs/#eval_guard-1\">eval_guard(Expr::cerl()) -&gt; none | {value, term()}</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"eval_guard-1\"></a> </p><p>Tries to reduce a guard expression to a single constant value, if possible. The returned value is <span class=\"code\">{value, Term}</span> if the guard expression <span class=\"code\">Expr</span> always yields the constant value <span class=\"code\">Term</span>, and is otherwise <span class=\"code\">none</span>.</p> <p>Note that although guard expressions should only yield boolean values, this function does not guarantee that <span class=\"code\">Term</span> is either <span class=\"code\">true</span> or <span class=\"code\">false</span>. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</p> <p><strong>See also:</strong> <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#is_catchall-1\">is_catchall/1</a></span>.</p><p></p></div><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-is_catchall-1-id99002\"></span><a class=\"title_link\" name=\"is_catchall-1\" href=\"/erldoc/docs/#is_catchall-1\">is_catchall(Clause::cerl()) -&gt; boolean()</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"is_catchall-1\"></a> </p><p>Returns <span class=\"code\">true</span> if an abstract clause is a catch-all, otherwise <span class=\"code\">false</span>. A clause is a catch-all if all its patterns are variables, and its guard expression always evaluates to <span class=\"code\">true</span>; cf. <span class=\"code\">eval_guard/1</span>.</p> <p>Note: <span class=\"code\">Clause</span> must have type <span class=\"code\">clause</span>.</p> <p><strong>See also:</strong> <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#any_catchall-1\">any_catchall/1</a></span>, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#eval_guard-1\">eval_guard/1</a></span>.</p><p></p></div><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-match-2-id99075\"></span><a class=\"title_link\" name=\"match-2\" href=\"/erldoc/docs/#match-2\">match(Pattern::cerl(), E::Expr) -&gt; none | {true, Bindings} | {false, Bindings}</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-5\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Expr = any | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span></span><br></div><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Bindings = [{<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span>, Expr}]</span><br></div></div><div class=\"REFBODY rb-7\"><p><a name=\"match-2\"></a> </p><p>Matches a pattern against an expression. The returned value is <span class=\"code\">none</span> if a match is impossible, <span class=\"code\">{true, Bindings}</span> if <span class=\"code\">Pattern</span> definitely matches <span class=\"code\">Expr</span>, and <span class=\"code\">{false, Bindings}</span> if a match is not definite, but cannot be excluded. <span class=\"code\">Bindings</span> is then a list of pairs <span class=\"code\">{Var, SubExpr}</span>, associating each variable in the pattern with either the corresponding subexpression of <span class=\"code\">Expr</span>, or with the atom <span class=\"code\">any</span> if no matching subexpression exists. (Recall that variables may not be repeated in a Core Erlang pattern.) The list of bindings is given in innermost-first order; this should only be of interest if <span class=\"code\">Pattern</span> contains one or more alias patterns. If the returned value is <span class=\"code\">{true, []}</span>, it implies that the pattern and the expression are syntactically identical.</p> <p>Instead of a syntax tree, the atom <span class=\"code\">any</span> can be passed for <span class=\"code\">Expr</span> (or, more generally, be used for any subtree of <span class=\"code\">Expr</span>, in as much the abstract syntax tree implementation allows it); this means that it cannot be decided whether the pattern will match or not, and the corresponding variable bindings will all map to <span class=\"code\">any</span>. The typical use is for producing bindings for <span class=\"code\">receive</span> clauses.</p> <p>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</p> <p>Examples: </p><ul> <li><p>Matching a pattern &quot;<span class=\"code\">{X, Y}</span>&quot; against the expression &quot;<span class=\"code\">{foo, f(Z)}</span>&quot; yields <span class=\"code\">{true, Bindings}</span> where <span class=\"code\">Bindings</span> associates &quot;<span class=\"code\">X</span>&quot; with the subtree &quot;<span class=\"code\">foo</span>&quot; and &quot;<span class=\"code\">Y</span>&quot; with the subtree &quot;<span class=\"code\">f(Z)</span>&quot;.</p></li> <li><p>Matching pattern &quot;<span class=\"code\">{X, {bar, Y}}</span>&quot; against expression &quot;<span class=\"code\">{foo, f(Z)}</span>&quot; yields <span class=\"code\">{false, Bindings}</span> where <span class=\"code\">Bindings</span> associates &quot;<span class=\"code\">X</span>&quot; with the subtree &quot;<span class=\"code\">foo</span>&quot; and &quot;<span class=\"code\">Y</span>&quot; with <span class=\"code\">any</span> (because it is not known if &quot;<span class=\"code\">{foo, Y}</span>&quot; might match the run-time value of &quot;<span class=\"code\">f(Z)</span>&quot; or not).</p></li> <li><p>Matching pattern &quot;<span class=\"code\">{foo, bar}</span>&quot; against expression &quot;<span class=\"code\">{foo, f()}</span>&quot; yields <span class=\"code\">{false, []}</span>, telling us that there might be a match, but we cannot deduce any bindings.</p></li> <li><p>Matching <span class=\"code\">{foo, X = {bar, Y}}</span> against expression &quot;<span class=\"code\">{foo, {bar, baz}}</span>&quot; yields <span class=\"code\">{true, Bindings}</span> where <span class=\"code\">Bindings</span> associates &quot;<span class=\"code\">Y</span>&quot; with &quot;<span class=\"code\">baz</span>&quot;, and &quot;<span class=\"code\">X</span>&quot; with &quot;<span class=\"code\">{bar, baz}</span>&quot;.</p></li> <li><p>Matching a pattern &quot;<span class=\"code\">{X, Y}</span>&quot; against <span class=\"code\">any</span> yields <span class=\"code\">{false, Bindings}</span> where <span class=\"code\">Bindings</span> associates both &quot;<span class=\"code\">X</span>&quot; and &quot;<span class=\"code\">Y</span>&quot; with <span class=\"code\">any</span>.</p></li> </ul><p></p></div><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-match_list-2-id99364\"></span><a class=\"title_link\" name=\"match_list-2\" href=\"/erldoc/docs/#match_list-2\">match_list(Patterns::[cerl()], Exprs::[Expr]) -&gt; none | {true, Bindings} | {false, Bindings}</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-5\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Expr = any | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span></span><br></div><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Bindings = [{<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span>, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span>}]</span><br></div></div><div class=\"REFBODY rb-7\"><p><a name=\"match_list-2\"></a> </p><p>Like <span class=\"code\">match/2</span>, but matching a sequence of patterns against a sequence of expressions. Passing an empty list for <span class=\"code\">Exprs</span> is equivalent to passing a list of <span class=\"code\">any</span> atoms of the same length as <span class=\"code\">Patterns</span>. </p><p><strong>See also:</strong> <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#match-2\">match/2</a></span>.</p><p></p></div><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-reduce-1-id99445\"></span><a class=\"title_link\" name=\"reduce-1\" href=\"/erldoc/docs/#reduce-1\">reduce(Cs::Clauses) -&gt; {true, {Clause, Bindings}} | {false, Clauses}</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p><a name=\"reduce-1\"></a></p><p>Equivalent to <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#reduce-2\">reduce(Cs, [])</a></span>.</p><p></p></div><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code fun-type\"><span ><span id=\"ghlink-reduce-2-id99472\"></span><a class=\"title_link\" name=\"reduce-2\" href=\"/erldoc/docs/#reduce-2\">reduce(Clauses::[Clause], Exprs::[Expr]) -&gt; {true, {Clause, Bindings}} | {false, [Clause]}</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY rb-5\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Clause = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span></span><br></div><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Expr = any | <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span></span><br></div><div class=\"REFTYPES rt-4\"><span class=\"bold_code fun-param-type\">Bindings = [{<span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span>, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-cerl\">cerl()</a></span>}]</span><br></div></div><div class=\"REFBODY rb-7\"><p><a name=\"reduce-2\"></a> </p><p>Selects a single clause, if possible, or otherwise reduces the list of selectable clauses. The input is a list <span class=\"code\">Clauses</span> of abstract clauses (i.e., syntax trees of type <span class=\"code\">clause</span>), and a list of switch expressions <span class=\"code\">Exprs</span>. The function tries to uniquely select a single clause or discard unselectable clauses, with respect to the switch expressions. All abstract clauses in the list must have the same number of patterns. If <span class=\"code\">Exprs</span> is not the empty list, it must have the same length as the number of patterns in each clause; see <span class=\"code\">match_list/2</span> for details.</p> <p>A clause can only be selected if its guard expression always yields the atom <span class=\"code\">true</span>, and a clause whose guard expression always yields the atom <span class=\"code\">false</span> can never be selected. Other guard expressions are considered to have unknown value; cf. <span class=\"code\">eval_guard/1</span>.</p> <p>If a particular clause can be selected, the function returns <span class=\"code\">{true, {Clause, Bindings}}</span>, where <span class=\"code\">Clause</span> is the selected clause and <span class=\"code\">Bindings</span> is a list of pairs <span class=\"code\">{Var, SubExpr}</span> associating the variables occurring in the patterns of <span class=\"code\">Clause</span> with the corresponding subexpressions in <span class=\"code\">Exprs</span>. The list of bindings is given in innermost-first order; see the <span class=\"code\">match/2</span> function for details.</p> <p>If no clause could be definitely selected, the function returns <span class=\"code\">{false, NewClauses}</span>, where <span class=\"code\">NewClauses</span> is the list of entries in <span class=\"code\">Clauses</span> that remain after eliminating unselectable clauses, preserving the relative order.</p> <p><strong>See also:</strong> <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#eval_guard-1\">eval_guard/1</a></span>, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#match-2\">match/2</a></span>, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#match_list-2\">match_list/2</a></span>.</p><p></p></div>"}