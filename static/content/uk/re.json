{
  "summary": "Perl-like regular expressions for Erlang.",
  "description": "<p> </p><p>This module contains regular expression matching functions for strings and binaries.</p> <p>The <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#regexp_syntax\">regular expression</a></span> syntax and semantics resemble that of Perl.</p> <p>The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here.</p> <div class=\"note\"><div class=\"label\">Note</div><div class=\"content\"><p> </p><p>The Erlang literal syntax for strings uses the &quot;\\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\\\\&quot;.</p> <p></p></div></div> <p></p>",
  "funcs": " <a name=\"version-0\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-version-0-id335726\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L81\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>version() -&gt; binary()</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 20.0</span></td></tr></tbody></table><div class=\"REFBODY rb-7\"><p> </p><p>The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</p> <p></p></div> <a name=\"compile-1\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-compile-1-id357458\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L89\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>compile(Regexp) -&gt; {ok, MP} | {error, ErrSpec}</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Regexp = iodata()</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">MP = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ErrSpec = <br>&#xA0;&#xA0;&#xA0;&#xA0;{ErrString :: string(), Position :: integer() &gt;= 0}</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>The same as <span class=\"code\">compile(Regexp,[])</span></p> <p></p></div> <a name=\"compile-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-compile-2-id343908\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L97\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>compile(Regexp, Options) -&gt; {ok, MP} | {error, ErrSpec}</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Regexp = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Options = [Option]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Option = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-compile_option\">compile_option()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">MP = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ErrSpec = <br>&#xA0;&#xA0;&#xA0;&#xA0;{ErrString :: string(), Position :: integer() &gt;= 0}</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#run-2\"><span class=\"code\">run/2</span></a></span> and <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#run-3\"><span class=\"code\">run/3</span></a></span>.</p> <p>Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match.</p> <p>When option <span class=\"code\">unicode</span> is specified, the regular expression is to be specified as a valid Unicode <span class=\"code\">charlist()</span>, otherwise as any valid <span class=\"code\">iodata()</span>.</p> <a name=\"compile_options\"></a> <p>Options:</p> <dl> <dt><strong><span class=\"code\">unicode</span></strong></dt> <dd> <p>The regular expression is specified as a Unicode <span class=\"code\">charlist()</span> and the resulting regular expression code is to be run against a valid Unicode <span class=\"code\">charlist()</span> subject. Also consider option <span class=\"code\">ucp</span> when using Unicode characters.</p> </dd> <dt><strong><span class=\"code\">anchored</span></strong></dt> <dd> <p>The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself.</p> </dd> <dt><strong><span class=\"code\">caseless</span></strong></dt> <dd> <p>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option <span class=\"code\">/i</span> and can be changed within a pattern by a <span class=\"code\">(?i)</span> option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</p> </dd> <dt><strong><span class=\"code\">dollar_endonly</span></strong></dt> <dd> <p>A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option <span class=\"code\">multiline</span> is specified. There is no equivalent option in Perl, and it cannot be set within a pattern.</p> </dd> <dt><strong><span class=\"code\">dotall</span></strong></dt> <dd> <p>A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option <span class=\"code\">/s</span> and it can be changed within a pattern by a <span class=\"code\">(?s)</span> option setting. A negative class, such as <span class=\"code\">[^a]</span>, always matches newline characters, independent of the setting of this option.</p> </dd> <dt><strong><span class=\"code\">extended</span></strong></dt> <dd> <p>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as <span class=\"code\">(?&gt;</span> that introduce various parenthesized subpatterns, nor within a numerical quantifier such as <span class=\"code\">{1,3}</span>. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness. </p> <p>White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space. </p> <p>This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl&apos;s <span class=\"code\">/x</span> option, and it can be changed within a pattern by a <span class=\"code\">(?x)</span> option setting. </p> <p>With this option, comments inside complicated patterns can be included. However, notice that this applies only to data characters. Whitespace characters can never appear within special character sequences in a pattern, for example within sequence <span class=\"code\">(?(</span> that introduces a conditional subpattern.</p> </dd> <dt><strong><span class=\"code\">firstline</span></strong></dt> <dd> <p>An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline.</p> </dd> <dt><strong><span class=\"code\">multiline</span></strong></dt> <dd> <p>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (<span class=\"code\">^</span>) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (<span class=\"code\">$</span>) matches only at the end of the string, or before a terminating newline (unless option <span class=\"code\">dollar_endonly</span> is specified). This is the same as in Perl.</p> <p>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option <span class=\"code\">/m</span> and can be changed within a pattern by a <span class=\"code\">(?m)</span> option setting. If there are no newlines in a subject string, or no occurrences of <span class=\"code\">^</span> or <span class=\"code\">$</span> in a pattern, setting <span class=\"code\">multiline</span> has no effect.</p> </dd> <dt><strong><span class=\"code\">no_auto_capture</span></strong></dt> <dd> <p>Disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by <span class=\"code\">?</span> behaves as if it is followed by <span class=\"code\">?:</span>. Named parentheses can still be used for capturing (and they acquire numbers in the usual way). There is no equivalent option in Perl.</p> </dd> <dt><strong><span class=\"code\">dupnames</span></strong></dt> <dd> <p>Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below.</p> </dd> <dt><strong><span class=\"code\">ungreedy</span></strong></dt> <dd> <p>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a <span class=\"code\">(?U)</span> option setting within the pattern.</p> </dd> <dt><strong><span class=\"code\">{newline, NLSpec}</span></strong></dt> <dd> <p>Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</p> <dl> <dt><strong><span class=\"code\">cr</span></strong></dt> <dd> <p>Newline is indicated by a single character <span class=\"code\">cr</span> (ASCII 13).</p> </dd> <dt><strong><span class=\"code\">lf</span></strong></dt> <dd> <p>Newline is indicated by a single character LF (ASCII 10), the default.</p> </dd> <dt><strong><span class=\"code\">crlf</span></strong></dt> <dd> <p>Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</p> </dd> <dt><strong><span class=\"code\">anycrlf</span></strong></dt> <dd> <p>Any of the three preceding sequences is to be recognized.</p> </dd> <dt><strong><span class=\"code\">any</span></strong></dt> <dd> <p>Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</p> </dd> </dl> </dd> <dt><strong><span class=\"code\">bsr_anycrlf</span></strong></dt> <dd> <p>Specifies specifically that \\R is to match only the CR, LF, or CRLF sequences, not the Unicode-specific newline characters.</p> </dd> <dt><strong><span class=\"code\">bsr_unicode</span></strong></dt> <dd> <p>Specifies specifically that \\R is to match all the Unicode newline characters (including CRLF, and so on, the default).</p> </dd> <dt><strong><span class=\"code\">no_start_optimize</span></strong></dt> <dd> <p>Disables optimization that can malfunction if &quot;Special start-of-pattern items&quot; are present in the regular expression. A typical example would be when matching &quot;DEFABC&quot; against &quot;(*COMMIT)ABC&quot;, where the start optimization of PCRE would skip the subject up to &quot;A&quot; and never realize that the (*COMMIT) instruction is to have made the matching fail. This option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in section <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#regexp_syntax_details\">PCRE Regular Expression Details</a></span>.</p> </dd> <dt><strong><span class=\"code\">ucp</span></strong></dt> <dd> <p>Specifies that Unicode character properties are to be used when resolving \\B, \\b, \\D, \\d, \\S, \\s, \\W and \\w. Without this flag, only ISO Latin-1 properties are used. Using Unicode properties hurts performance, but is semantically correct when working with Unicode characters beyond the ISO Latin-1 range.</p> </dd> <dt><strong><span class=\"code\">never_utf</span></strong></dt> <dd> <p>Specifies that the (*UTF) and/or (*UTF8) &quot;start-of-pattern items&quot; are forbidden. This flag cannot be combined with option <span class=\"code\">unicode</span>. Useful if ISO Latin-1 patterns from an external source are to be compiled.</p> </dd> </dl> <p></p></div> <a name=\"inspect-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-inspect-2-id359523\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L306\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>inspect(MP, Item) -&gt; {namelist, [binary()]}</div></td><td class=\"func-since-td\"><span class=\"since\">OTP 17.0</span></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">MP = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Item = namelist</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is <span class=\"code\">namelist</span>, which returns the tuple <span class=\"code\">{namelist, [binary()]}</span>, containing the names of all (unique) named subpatterns in the regular expression. For example:</p> <div class=\"example example-none\"><pre>1&gt; {ok,MP} = re:compile(&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;).{ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}}2&gt; re:inspect(MP,namelist).{namelist,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]}3&gt; {ok,MPD} = re:compile(&quot;(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;,[dupnames]).{ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,8,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}}4&gt; re:inspect(MPD,namelist). {namelist,[&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]}</pre></div> <p>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if <span class=\"code\">{capture, all_names}</span> is specified as an option to <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#run-3\"><span class=\"code\">run/3</span></a></span>. You can therefore create a name-to-value mapping from the result of <span class=\"code\">run/3</span> like this:</p> <div class=\"example example-none\"><pre>1&gt; {ok,MP} = re:compile(&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;).{ok,{re_pattern,3,0,0, &lt;&lt;69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...&gt;&gt;}}2&gt; {namelist, N} = re:inspect(MP,namelist).{namelist,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&quot;C&quot;&gt;&gt;]}3&gt; {match,L} = re:run(&quot;AA&quot;,MP,[{capture,all_names,binary}]).{match,[&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&gt;&gt;]}4&gt; NameMap = lists:zip(N,L).[{&lt;&lt;&quot;A&quot;&gt;&gt;,&lt;&lt;&quot;A&quot;&gt;&gt;},{&lt;&lt;&quot;B&quot;&gt;&gt;,&lt;&lt;&gt;&gt;},{&lt;&lt;&quot;C&quot;&gt;&gt;,&lt;&lt;&gt;&gt;}]</pre></div> <p></p></div> <a name=\"replace-3\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-replace-3-id359683\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L350\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>replace(Subject, RE, Replacement) -&gt; iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Subject = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RE = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span> | iodata()</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Replacement = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Same as <span class=\"code\">replace(Subject, RE, Replacement, [])</span>.</p> <p></p></div> <a name=\"replace-4\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-replace-4-id359740\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L360\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>replace(Subject, RE, Replacement, Options) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Subject = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RE = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span> | iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Replacement = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Options = [Option]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Option = <br>&#xA0;&#xA0;&#xA0;&#xA0;anchored | global | notbol | noteol | notempty |<br>&#xA0;&#xA0;&#xA0;&#xA0;notempty_atstart |<br>&#xA0;&#xA0;&#xA0;&#xA0;{offset, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{newline, NLSpec} |<br>&#xA0;&#xA0;&#xA0;&#xA0;bsr_anycrlf |<br>&#xA0;&#xA0;&#xA0;&#xA0;{match_limit, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{match_limit_recursion, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;bsr_unicode |<br>&#xA0;&#xA0;&#xA0;&#xA0;{return, ReturnType} |<br>&#xA0;&#xA0;&#xA0;&#xA0;CompileOpt</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ReturnType = iodata | list | binary</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">CompileOpt = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-compile_option\">compile_option()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">NLSpec = cr | crlf | lf | anycrlf | any</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Replaces the matched part of the <span class=\"code\">Subject</span> string with the contents of <span class=\"code\">Replacement</span>.</p> <p>The permissible options are the same as for <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#run-3\"><span class=\"code\">run/3</span></a></span>, except that option<span class=\"code\"> capture</span> is not allowed. Instead a <span class=\"code\">{return, ReturnType}</span> is present. The default return type is <span class=\"code\">iodata</span>, constructed in a way to minimize copying. The <span class=\"code\">iodata</span> result can be used directly in many I/O operations. If a flat <span class=\"code\">list()</span> is desired, specify <span class=\"code\">{return, list}</span>. If a binary is desired, specify <span class=\"code\">{return, binary}</span>.</p> <p>As in function <span class=\"code\">run/3</span>, an <span class=\"code\">mp()</span> compiled with option <span class=\"code\">unicode</span> requires <span class=\"code\">Subject</span> to be a Unicode <span class=\"code\">charlist()</span>. If compilation is done implicitly and the <span class=\"code\">unicode</span> compilation option is specified to this function, both the regular expression and <span class=\"code\">Subject</span> are to specified as valid Unicode <span class=\"code\">charlist()</span>s.</p> <p>The replacement string can contain the special character <span class=\"code\">&amp;</span>, which inserts the whole matching expression in the result, and the special sequence <span class=\"code\">\\</span>N (where N is an integer &gt; 0), <span class=\"code\">\\g</span>N, or <span class=\"code\">\\g{</span>N<span class=\"code\">}</span>, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted.</p> <p>To insert an &amp; or a \\ in the result, precede it with a \\. Notice that Erlang already gives a special meaning to \\ in literal strings, so a single \\ must be written as <span class=\"code\">&quot;\\\\&quot;</span> and therefore a double \\ as <span class=\"code\">&quot;\\\\\\\\&quot;</span>.</p> <p><strong>Example:</strong></p> <div class=\"example example-none\"><pre>re:replace(&quot;abcd&quot;,&quot;c&quot;,&quot;[&amp;]&quot;,[{return,list}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>&quot;ab[c]d&quot;</pre></div> <p>while</p> <div class=\"example example-none\"><pre>re:replace(&quot;abcd&quot;,&quot;c&quot;,&quot;[\\\\&amp;]&quot;,[{return,list}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>&quot;ab[&amp;]d&quot;</pre></div> <p>As with <span class=\"code\">run/3</span>, compilation errors raise the <span class=\"code\">badarg</span> exception. <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#compile-2\"><span class=\"code\">compile/2</span></a></span> can be used to get more information about the error.</p> <p></p></div> <a name=\"run-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-run-2-id360296\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L410\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>run(Subject, RE) -&gt; {match, Captured} | nomatch</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Subject = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RE = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span> | iodata()</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Captured = [CaptureData]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">CaptureData = {integer(), integer()}</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Same as <span class=\"code\">run(Subject,RE,[])</span>.</p> <p></p></div> <a name=\"run-3\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-run-3-id359863\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L419\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>run(Subject, RE, Options) -&gt;<br>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{match, Captured} | match | nomatch | {error, ErrType}</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Subject = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RE = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span> | iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Options = [Option]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Option = <br>&#xA0;&#xA0;&#xA0;&#xA0;anchored | global | notbol | noteol | notempty |<br>&#xA0;&#xA0;&#xA0;&#xA0;notempty_atstart | report_errors |<br>&#xA0;&#xA0;&#xA0;&#xA0;{offset, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{match_limit, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{match_limit_recursion, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{newline, NLSpec :: <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-nl_spec\">nl_spec()</a></span>} |<br>&#xA0;&#xA0;&#xA0;&#xA0;bsr_anycrlf | bsr_unicode |<br>&#xA0;&#xA0;&#xA0;&#xA0;{capture, ValueSpec} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{capture, ValueSpec, Type} |<br>&#xA0;&#xA0;&#xA0;&#xA0;CompileOpt</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Type = index | list | binary</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ValueSpec = <br>&#xA0;&#xA0;&#xA0;&#xA0;all | all_but_first | all_names | first | none | ValueList</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ValueList = [ValueID]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ValueID = integer() | string() | atom()</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">CompileOpt = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-compile_option\">compile_option()</a></span></span></div><div class=\"REFBODY rb-1\">See <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#compile_options\"><span class=\"code\">compile/2</span></a></span>.</div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Captured = [CaptureData] | [[CaptureData]]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">CaptureData = <br>&#xA0;&#xA0;&#xA0;&#xA0;{integer(), integer()} | ListConversionData | binary()</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ListConversionData = <br>&#xA0;&#xA0;&#xA0;&#xA0;string() |<br>&#xA0;&#xA0;&#xA0;&#xA0;{error, string(), binary()} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{incomplete, string(), binary()}</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ErrType = <br>&#xA0;&#xA0;&#xA0;&#xA0;match_limit | match_limit_recursion | {compile, CompileErr}</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">CompileErr = <br>&#xA0;&#xA0;&#xA0;&#xA0;{ErrString :: string(), Position :: integer() &gt;= 0}</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Executes a regular expression matching, and returns <span class=\"code\">match/{match, Captured}</span> or <span class=\"code\">nomatch</span>. The regular expression can be specified either as <span class=\"code\">iodata()</span> in which case it is automatically compiled (as by <span class=\"code\">compile/2</span>) and executed, or as a precompiled <span class=\"code\">mp()</span> in which case it is executed against the subject directly.</p> <p>When compilation is involved, exception <span class=\"code\">badarg</span> is thrown if a compilation error occurs. Call <span class=\"code\">compile/2</span> to get information about the location of the error in the regular expression.</p> <p>If the regular expression is previously compiled, the option list can only contain the following options:</p> <ul> <li><span class=\"code\">anchored</span></li> <li><span class=\"code\">{capture, ValueSpec}/{capture, ValueSpec, Type}</span></li> <li><span class=\"code\">global</span></li> <li><span class=\"code\">{match_limit, integer() &gt;= 0}</span></li> <li><span class=\"code\">{match_limit_recursion, integer() &gt;= 0}</span></li> <li><span class=\"code\">{newline, NLSpec}</span></li> <li><span class=\"code\">notbol</span></li> <li><span class=\"code\">notempty</span></li> <li><span class=\"code\">notempty_atstart</span></li> <li><span class=\"code\">noteol</span></li> <li><span class=\"code\">{offset, integer() &gt;= 0}</span></li> <li><span class=\"code\">report_errors</span></li> </ul> <p>Otherwise all options valid for function <span class=\"code\">compile/2</span> are also allowed. Options allowed both for compilation and execution of a match, namely <span class=\"code\">anchored</span> and <span class=\"code\">{newline, NLSpec}</span>, affect both the compilation and execution if present together with a non-precompiled regular expression.</p> <p>If the regular expression was previously compiled with option <span class=\"code\">unicode</span>, <span class=\"code\">Subject</span> is to be provided as a valid Unicode <span class=\"code\">charlist()</span>, otherwise any <span class=\"code\">iodata()</span> will do. If compilation is involved and option <span class=\"code\">unicode</span> is specified, both <span class=\"code\">Subject</span> and the regular expression are to be specified as valid Unicode <span class=\"code\">charlists()</span>.</p> <p><span class=\"code\">{capture, ValueSpec}/{capture, ValueSpec, Type}</span> defines what to return from the function upon successful matching. The <span class=\"code\">capture</span> tuple can contain both a value specification, telling which of the captured substrings are to be returned, and a type specification, telling how captured substrings are to be returned (as index tuples, lists, or binaries). The options are described in detail below.</p> <p>If the capture options describe that no substring capturing is to be done (<span class=\"code\">{capture, none}</span>), the function returns the single atom <span class=\"code\">match</span> upon successful matching, otherwise the tuple <span class=\"code\">{match, ValueList}</span>. Disabling capturing can be done either by specifying <span class=\"code\">none</span> or an empty list as <span class=\"code\">ValueSpec</span>.</p> <p>Option <span class=\"code\">report_errors</span> adds the possibility that an error tuple is returned. The tuple either indicates a matching error (<span class=\"code\">match_limit</span> or <span class=\"code\">match_limit_recursion</span>), or a compilation error, where the error tuple has the format <span class=\"code\">{error, {compile, CompileErr}}</span>. Notice that if option <span class=\"code\">report_errors</span> is not specified, the function never returns error tuples, but reports compilation errors as a <span class=\"code\">badarg</span> exception and failed matches because of exceeded match limits simply as <span class=\"code\">nomatch</span>.</p> <p>The following options are relevant for execution:</p> <dl> <dt><strong><span class=\"code\">anchored</span></strong></dt> <dd> <p>Limits <span class=\"code\">run/3</span> to matching at the first matching position. If a pattern was compiled with <span class=\"code\">anchored</span>, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no <span class=\"code\">unanchored</span> option.</p></dd> <dt><strong><span class=\"code\">global</span></strong></dt> <dd> <p>Implements global (repetitive) search (flag <span class=\"code\">g</span> in Perl). Each match is returned as a separate <span class=\"code\">list()</span> containing the specific match and any matching subexpressions (or as specified by option <span class=\"code\">capture</span>. The <span class=\"code\">Captured</span> part of the return value is hence a <span class=\"code\">list()</span> of <span class=\"code\">list()</span>s when this option is specified.</p> <p>The interaction of option <span class=\"code\">global</span> with a regular expression that matches an empty string surprises some users. When option <span class=\"code\">global</span> is specified, <span class=\"code\">run/3</span> handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options <span class=\"code\">[anchored, notempty_atstart]</span>. If that search gives a result of length &gt; 0, the result is included. Example:</p> <div class=\"example example-none\"><pre>re:run(&quot;cat&quot;,&quot;(|at)&quot;,[global]).</pre></div> <p>The following matchings are performed:</p> <dl> <dt><strong>At offset <span class=\"code\">0</span></strong></dt> <dd> <p>The regular expression <span class=\"code\">(|at)</span> first match at the initial position of string <span class=\"code\">cat</span>, giving the result set <span class=\"code\">[{0,0},{0,0}]</span> (the second <span class=\"code\">{0,0}</span> is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet.</p> </dd> <dt><strong>At offset <span class=\"code\">0</span> with <span class=\"code\">[anchored, notempty_atstart]</span></strong></dt> <dd> <p>The search is retried with options <span class=\"code\">[anchored, notempty_atstart]</span> at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (<span class=\"code\">a</span>).</p> </dd> <dt><strong>At offset <span class=\"code\">1</span></strong></dt> <dd> <p>The search results in <span class=\"code\">[{1,0},{1,0}]</span>, so this search is also repeated with the extra options.</p> </dd> <dt><strong>At offset <span class=\"code\">1</span> with <span class=\"code\">[anchored, notempty_atstart]</span></strong></dt> <dd> <p>Alternative <span class=\"code\">ab</span> is found and the result is [{1,2},{1,2}]. The result is added to the list of results and the position in the search string is advanced two steps.</p> </dd> <dt><strong>At offset <span class=\"code\">3</span></strong></dt> <dd> <p>The search once again matches the empty string, giving <span class=\"code\">[{3,0},{3,0}]</span>.</p> </dd> <dt><strong>At offset <span class=\"code\">1</span> with <span class=\"code\">[anchored, notempty_atstart]</span></strong></dt> <dd> <p>This gives no result of length &gt; 0 and we are at the last position, so the global search is complete.</p> </dd> </dl> <p>The result of the call is:</p> <div class=\"example example-none\"><pre>{match,[[{0,0},{0,0}],[{1,0},{1,0}],[{1,2},{1,2}],[{3,0},{3,0}]]}</pre></div> </dd> <dt><strong><span class=\"code\">notempty</span></strong></dt> <dd> <p>An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails.</p> <p><strong>Example:</strong></p> <p>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</p> <div class=\"example example-none\"><pre>a?b?</pre></div> <p>With option <span class=\"code\">notempty</span>, this match is invalid, so <span class=\"code\">run/3</span> searches further into the string for occurrences of &quot;a&quot; or &quot;b&quot;.</p> </dd> <dt><strong><span class=\"code\">notempty_atstart</span></strong></dt> <dd> <p>Like <span class=\"code\">notempty</span>, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \\K.</p> <p>Perl has no direct equivalent of <span class=\"code\">notempty</span> or <span class=\"code\">notempty_atstart</span>, but it does make a special case of a pattern match of the empty string within its split() function, and when using modifier <span class=\"code\">/g</span>. The Perl behavior can be emulated after matching a null string by first trying the match again at the same offset with <span class=\"code\">notempty_atstart</span> and <span class=\"code\">anchored</span>, and then, if that fails, by advancing the starting offset (see below) and trying an ordinary match again.</p> </dd> <dt><strong><span class=\"code\">notbol</span></strong></dt> <dd> <p>Specifies that the first character of the subject string is not the beginning of a line, so the circumflex metacharacter is not to match before it. Setting this without <span class=\"code\">multiline</span> (at compile time) causes circumflex never to match. This option only affects the behavior of the circumflex metacharacter. It does not affect \\A.</p> </dd> <dt><strong><span class=\"code\">noteol</span></strong></dt> <dd> <p>Specifies that the end of the subject string is not the end of a line, so the dollar metacharacter is not to match it nor (except in multiline mode) a newline immediately before it. Setting this without <span class=\"code\">multiline</span> (at compile time) causes dollar never to match. This option affects only the behavior of the dollar metacharacter. It does not affect \\Z or \\z.</p> </dd> <dt><strong><span class=\"code\">report_errors</span></strong></dt> <dd> <p>Gives better control of the error handling in <span class=\"code\">run/3</span>. When specified, compilation errors (if the regular expression is not already compiled) and runtime errors are explicitly returned as an error tuple.</p> <p>The following are the possible runtime errors:</p> <dl> <dt><strong><span class=\"code\">match_limit</span></strong></dt> <dd> <p>The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If <span class=\"code\">{error, match_limit}</span> is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a <span class=\"code\">nomatch</span>, which is the default return value when this occurs, but by specifying <span class=\"code\">report_errors</span>, you are informed when the match fails because of too many internal calls.</p> </dd> <dt><strong><span class=\"code\">match_limit_recursion</span></strong></dt> <dd> <p>This error is very similar to <span class=\"code\">match_limit</span>, but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the <span class=\"code\">match_limit_recursion</span> limit, which defaults to 10,000,000 as well. Notice that as long as the <span class=\"code\">match_limit</span> and <span class=\"code\">match_limit_default</span> values are kept at the default values, the <span class=\"code\">match_limit_recursion</span> error cannot occur, as the <span class=\"code\">match_limit</span> error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#regexp_syntax_details\">PCRE Regular Eexpression Details</a></span>) or by specifying options to <span class=\"code\">run/3</span>.</p> </dd> </dl> <p>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</p> </dd> <dt><strong><span class=\"code\">{match_limit, integer() &gt;= 0}</span></strong></dt> <dd> <p>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</p> <div class=\"example example-none\"><pre>The match_limit field provides a means of preventing PCRE from usingup a vast amount of resources when running patterns that are not goingto match, but which have a very large number of possibilities in theirsearch trees. The classic example is a pattern that uses nestedunlimited repeats. Internally, pcre_exec() uses a function called match(), which it callsrepeatedly (sometimes recursively). The limit set by match_limit isimposed on the number of times this function is called during a match,which has the effect of limiting the amount of backtracking that cantake place. For patterns that are not anchored, the count restartsfrom zero for each position in the subject string.</pre></div> <p>This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM.</p> <div class=\"note\"><div class=\"label\">Note</div><div class=\"content\"><p> </p><p>This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. <span class=\"code\">run/3</span> always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system.</p> <p></p></div></div> </dd> <dt><strong><span class=\"code\">{match_limit_recursion, integer() &gt;= 0}</span></strong></dt> <dd> <p>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to <span class=\"code\">match_limit</span>. It is described as follows by the PCRE documentation:</p> <div class=\"example example-none\"><pre>The match_limit_recursion field is similar to match_limit, but insteadof limiting the total number of times that match() is called, itlimits the depth of recursion. The recursion depth is a smaller numberthan the total number of calls, because not all calls to match() arerecursive. This limit is of use only if it is set smaller thanmatch_limit. Limiting the recursion depth limits the amount of machine stack thatcan be used, or, when PCRE has been compiled to use memory on the heapinstead of the stack, the amount of heap memory that can be used.</pre></div> <p>The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</p> <p>Specifying a lower value can result in matches with deep recursion failing, when they should have matched:</p> <div class=\"example example-none\"><pre>1&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;).{match,[{0,14},{0,13}]}2&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;,[{match_limit_recursion,5}]).nomatch3&gt; re:run(&quot;aaaaaaaaaaaaaz&quot;,&quot;(a+)*z&quot;,[{match_limit_recursion,5},report_errors]).{error,match_limit_recursion}</pre></div> <p>This option and option <span class=\"code\">match_limit</span> are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits.</p> </dd> <dt><strong><span class=\"code\">{offset, integer() &gt;= 0}</span></strong></dt> <dd> <p>Start matching at the offset (position) specified in the subject string. The offset is zero-based, so that the default is <span class=\"code\">{offset,0}</span> (all of the subject string).</p> </dd> <dt><strong><span class=\"code\">{newline, NLSpec}</span></strong></dt> <dd> <p>Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</p> <dl> <dt><strong><span class=\"code\">cr</span></strong></dt> <dd> <p>Newline is indicated by a single character CR (ASCII 13).</p> </dd> <dt><strong><span class=\"code\">lf</span></strong></dt> <dd> <p>Newline is indicated by a single character LF (ASCII 10), the default.</p> </dd> <dt><strong><span class=\"code\">crlf</span></strong></dt> <dd> <p>Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</p> </dd> <dt><strong><span class=\"code\">anycrlf</span></strong></dt> <dd> <p>Any of the three preceding sequences is be recognized.</p> </dd> <dt><strong><span class=\"code\">any</span></strong></dt> <dd> <p>Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</p> </dd> </dl> </dd> <dt><strong><span class=\"code\">bsr_anycrlf</span></strong></dt> <dd> <p>Specifies specifically that \\R is to match only the CR LF, or CRLF sequences, not the Unicode-specific newline characters. (Overrides the compilation option.)</p> </dd> <dt><strong><span class=\"code\">bsr_unicode</span></strong></dt> <dd> <p>Specifies specifically that \\R is to match all the Unicode newline characters (including CRLF, and so on, the default). (Overrides the compilation option.)</p> </dd> <dt><strong><span class=\"code\">{capture, ValueSpec}</span>/<span class=\"code\">{capture, ValueSpec, Type}</span></strong></dt> <dd> <p>Specifies which captured substrings are returned and in what format. By default, <span class=\"code\">run/3</span> captures all of the matching part of the substring and all capturing subpatterns (all of the pattern is automatically captured). The default return type is (zero-based) indexes of the captured parts of the string, specified as <span class=\"code\">{Offset,Length}</span> pairs (the <span class=\"code\">index</span> <span class=\"code\">Type</span> of capturing).</p> <p>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair <span class=\"code\">{3,4}</span>, where character positions are zero-based, just as in offsets:</p> <div class=\"example example-none\"><pre>re:run(&quot;ABCabcdABC&quot;,&quot;abcd&quot;,[]).</pre></div> <p>The return value of this call is:</p> <div class=\"example example-none\"><pre>{match,[{3,4}]}</pre></div> <p>Another (and quite common) case is where the regular expression matches all of the subject:</p> <div class=\"example example-none\"><pre>re:run(&quot;ABCabcdABC&quot;,&quot;.*abcd.*&quot;,[]).</pre></div> <p>Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:</p> <div class=\"example example-none\"><pre>{match,[{0,10}]}</pre></div> <p>If the regular expression contains capturing subpatterns, like in:</p> <div class=\"example example-none\"><pre>re:run(&quot;ABCabcdABC&quot;,&quot;.*(abcd).*&quot;,[]).</pre></div> <p>all of the matched subject is captured, as well as the captured substrings:</p> <div class=\"example example-none\"><pre>{match,[{0,10},{3,4}]}</pre></div> <p>The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</p> <p>The capture tuple is built up as follows:</p> <dl> <dt><strong><span class=\"code\">ValueSpec</span></strong></dt> <dd> <p>Specifies which captured (sub)patterns are to be returned. <span class=\"code\">ValueSpec</span> can either be an atom describing a predefined set of return values, or a list containing the indexes or the names of specific subpatterns to return.</p> <p>The following are the predefined sets of subpatterns:</p> <dl> <dt><strong><span class=\"code\">all</span></strong></dt> <dd> <p>All captured subpatterns including the complete matching string. This is the default.</p> </dd> <dt><strong><span class=\"code\">all_names</span></strong></dt> <dd> <p>All <strong>named</strong> subpatterns in the regular expression, as if a <span class=\"code\">list()</span> of all the names <strong>in alphabetical order</strong> was specified. The list of all names can also be retrieved with <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#inspect-2\"><span class=\"code\">inspect/2</span></a></span>.</p> </dd> <dt><strong><span class=\"code\">first</span></strong></dt> <dd> <p>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</p> </dd> <dt><strong><span class=\"code\">all_but_first</span></strong></dt> <dd> <p>All but the first matching subpattern, that is, all explicitly captured subpatterns, but not the complete matching part of the subject string. This is useful if the regular expression as a whole matches a large part of the subject, but the part you are interested in is in an explicitly captured subpattern. If the return type is <span class=\"code\">list</span> or <span class=\"code\">binary</span>, not returning subpatterns you are not interested in is a good way to optimize.</p> </dd> <dt><strong><span class=\"code\">none</span></strong></dt> <dd> <p>Returns no matching subpatterns, gives the single atom <span class=\"code\">match</span> as the return value of the function when matching successfully instead of the <span class=\"code\">{match, list()}</span> return. Specifying an empty list gives the same behavior.</p> </dd> </dl> <p>The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use <span class=\"code\">atom()</span>s or <span class=\"code\">string()</span>s to specify the subpatterns to be returned. For example, consider the regular expression:</p> <div class=\"example example-none\"><pre>&quot;.*(abcd).*&quot;</pre></div> <p>matched against string &quot;ABCabcdABC&quot;, capturing only the &quot;abcd&quot; part (the first explicit subpattern):</p> <div class=\"example example-none\"><pre>re:run(&quot;ABCabcdABC&quot;,&quot;.*(abcd).*&quot;,[{capture,[1]}]).</pre></div> <p>The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</p> <div class=\"example example-none\"><pre>{match,[{3,4}]}</pre></div> <p>Consider the same regular expression, but with the subpattern explicitly named &apos;FOO&apos;:</p> <div class=\"example example-none\"><pre>&quot;.*(?&lt;FOO&gt;abcd).*&quot;</pre></div> <p>With this expression, we could still give the index of the subpattern with the following call:</p> <div class=\"example example-none\"><pre>re:run(&quot;ABCabcdABC&quot;,&quot;.*(?&lt;FOO&gt;abcd).*&quot;,[{capture,[1]}]).</pre></div> <p>giving the same result as before. But, as the subpattern is named, we can also specify its name in the value list:</p> <div class=\"example example-none\"><pre>re:run(&quot;ABCabcdABC&quot;,&quot;.*(?&lt;FOO&gt;abcd).*&quot;,[{capture,[&apos;FOO&apos;]}]).</pre></div> <p>This would give the same result as the earlier examples, namely:</p> <div class=\"example example-none\"><pre>{match,[{3,4}]}</pre></div> <p>The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is <span class=\"code\">index</span>, the tuple <span class=\"code\">{-1,0}</span> is returned for values with no corresponding subpattern in the regular expression, but for the other types (<span class=\"code\">binary</span> and <span class=\"code\">list</span>), the values are the empty binary or list, respectively.</p> </dd> <dt><strong><span class=\"code\">Type</span></strong></dt> <dd> <p>Optionally specifies how captured substrings are to be returned. If omitted, the default of <span class=\"code\">index</span> is used.</p> <p><span class=\"code\">Type</span> can be one of the following:</p> <dl> <dt><strong><span class=\"code\">index</span></strong></dt> <dd> <p>Returns captured substrings as pairs of byte indexes into the subject string and length of the matching string in the subject (as if the subject string was flattened with <span class=\"bold_code bc-13\"><a href=\"/erldoc/docs/erlang#iolist_to_binary-1\"><span class=\"code\">erlang:iolist_to_binary/1</span></a></span> or <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#characters_to_binary-2\"><span class=\"code\">unicode:characters_to_binary/2</span></a></span> before matching). Notice that option <span class=\"code\">unicode</span> results in <strong>byte-oriented</strong> indexes in a (possibly virtual) <strong>UTF-8 encoded</strong> binary. A byte index tuple <span class=\"code\">{0,2}</span> can therefore represent one or two characters when <span class=\"code\">unicode</span> is in effect. This can seem counter-intuitive, but has been deemed the most effective and useful way to do it. To return lists instead can result in simpler code if that is desired. This return type is the default.</p> </dd> <dt><strong><span class=\"code\">list</span></strong></dt> <dd> <p>Returns matching substrings as lists of characters (Erlang <span class=\"code\">string()</span>s). It option <span class=\"code\">unicode</span> is used in combination with the \\C sequence in the regular expression, a captured subpattern can contain bytes that are not valid UTF-8 (\\C matches bytes regardless of character encoding). In that case the <span class=\"code\">list</span> capturing can result in the same types of tuples that <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#characters_to_list-2\"><span class=\"code\">unicode:characters_to_list/2</span></a></span> can return, namely three-tuples with tag <span class=\"code\">incomplete</span> or <span class=\"code\">error</span>, the successfully converted characters and the invalid UTF-8 tail of the conversion as a binary. The best strategy is to avoid using the \\C sequence when capturing lists.</p> </dd> <dt><strong><span class=\"code\">binary</span></strong></dt> <dd> <p>Returns matching substrings as binaries. If option <span class=\"code\">unicode</span> is used, these binaries are in UTF-8. If the \\C sequence is used together with <span class=\"code\">unicode</span>, the binaries can be invalid UTF-8.</p> </dd> </dl> </dd> </dl> <p>In general, subpatterns that were not assigned a value in the match are returned as the tuple <span class=\"code\">{-1,0}</span> when <span class=\"code\">type</span> is <span class=\"code\">index</span>. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</p> <div class=\"example example-none\"><pre>&quot;.*((?&lt;FOO&gt;abdd)|a(..d)).*&quot;</pre></div> <p>There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence <span class=\"code\">((?&lt;FOO&gt;abdd)|a(..d))</span> is subpattern index 1, <span class=\"code\">(?&lt;FOO&gt;abdd)</span> is subpattern index 2, and <span class=\"code\">(..d)</span> is subpattern index 3. When matched against the following string:</p> <div class=\"example example-none\"><pre>&quot;ABCabcdABC&quot;</pre></div> <p>the subpattern at index 2 does not match, as &quot;abdd&quot; is not present in the string, but the complete pattern matches (because of the alternative <span class=\"code\">a(..d)</span>). The subpattern at index 2 is therefore unassigned and the default return value is:</p> <div class=\"example example-none\"><pre>{match,[{0,10},{3,4},{-1,0},{4,3}]}</pre></div> <p>Setting the capture <span class=\"code\">Type</span> to <span class=\"code\">binary</span> gives:</p> <div class=\"example example-none\"><pre>{match,[&lt;&lt;&quot;ABCabcdABC&quot;&gt;&gt;,&lt;&lt;&quot;abcd&quot;&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;&quot;bcd&quot;&gt;&gt;]}</pre></div> <p>Here the empty binary (<span class=\"code\">&lt;&lt;&gt;&gt;</span>) represents the unassigned subpattern. In the <span class=\"code\">binary</span> case, some information about the matching is therefore lost, as <span class=\"code\">&lt;&lt;&gt;&gt;</span> can also be an empty string captured.</p> <p>If differentiation between empty matches and non-existing subpatterns is necessary, use the <span class=\"code\">type</span> <span class=\"code\">index</span> and do the conversion to the final type in Erlang code.</p> <p>When option <span class=\"code\">global</span> is speciified, the <span class=\"code\">capture</span> specification affects each match separately, so that:</p> <div class=\"example example-none\"><pre>re:run(&quot;cacb&quot;,&quot;c(a|b)&quot;,[global,{capture,[1],list}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>{match,[[&quot;a&quot;],[&quot;b&quot;]]}</pre></div> </dd> </dl> <p>For a descriptions of options only affecting the compilation step, see <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#compile-2\"><span class=\"code\">compile/2</span></a></span>.</p> <p></p></div> <a name=\"split-2\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-split-2-id362849\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L994\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>split(Subject, RE) -&gt; SplitList</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Subject = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RE = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span> | iodata()</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">SplitList = [iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span>]</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Same as <span class=\"code\">split(Subject, RE, [])</span>.</p> <p></p></div> <a name=\"split-3\"></a><table class=\"func-table\"><tbody><tr class=\"func-tr\"><td class=\"func-td\"><div class=\"bold_code func-head\" ><span id=\"ghlink-split-3-id362904\" class=\"ghlink\"><a href=\"/erldoc/docs/https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/re.xml#L1003\" title=\"Found an issue with the documentation? Fix it by clicking here!\"><span class=\"pencil\"></span></a></span>split(Subject, RE, Options) -&gt; SplitList</div></td><td class=\"func-since-td\"></td></tr></tbody></table><div class=\"REFBODY fun-types\"><h3 class=\"func-types-title\">Types</h3><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Subject = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RE = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-mp\">mp()</a></span> | iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span></span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Options = [Option]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">Option = <br>&#xA0;&#xA0;&#xA0;&#xA0;anchored | notbol | noteol | notempty | notempty_atstart |<br>&#xA0;&#xA0;&#xA0;&#xA0;{offset, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{newline, <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-nl_spec\">nl_spec()</a></span>} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{match_limit, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{match_limit_recursion, integer() &gt;= 0} |<br>&#xA0;&#xA0;&#xA0;&#xA0;bsr_anycrlf | bsr_unicode |<br>&#xA0;&#xA0;&#xA0;&#xA0;{return, ReturnType} |<br>&#xA0;&#xA0;&#xA0;&#xA0;{parts, NumParts} |<br>&#xA0;&#xA0;&#xA0;&#xA0;group | trim | CompileOpt</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">NumParts = integer() &gt;= 0 | infinity</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">ReturnType = iodata | list | binary</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">CompileOpt = <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#type-compile_option\">compile_option()</a></span></span></div><div class=\"REFBODY rb-1\">See <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#compile_options\"><span class=\"code\">compile/2</span></a></span>.</div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">SplitList = [RetData] | [GroupedRetData]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">GroupedRetData = [RetData]</span></div><div class=\"REFTYPES rt-1\"><span class=\"bold_code bc-2\">RetData = iodata() | <span class=\"bold_code bc-15\"><a href=\"/erldoc/docs/unicode#type-charlist\">unicode:charlist()</a></span> | binary() | list()</span></div></div><div class=\"REFBODY rb-7\"><p> </p><p>Splits the input into parts by finding tokens according to the regular expression supplied. The splitting is basically done by running a global regular expression match and dividing the initial string wherever a match occurs. The matching part of the string is removed from the output.</p> <p>As in <span class=\"bold_code bc-17\"><a href=\"/erldoc/docs/#run-3\"><span class=\"code\">run/3</span></a></span>, an <span class=\"code\">mp()</span> compiled with option <span class=\"code\">unicode</span> requires <span class=\"code\">Subject</span> to be a Unicode <span class=\"code\">charlist()</span>. If compilation is done implicitly and the <span class=\"code\">unicode</span> compilation option is specified to this function, both the regular expression and <span class=\"code\">Subject</span> are to be specified as valid Unicode <span class=\"code\">charlist()</span>s.</p> <p>The result is given as a list of &quot;strings&quot;, the preferred data type specified in option <span class=\"code\">return</span> (default <span class=\"code\">iodata</span>).</p> <p>If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;[ln]&quot;,[{return,list}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>[&quot;Er&quot;,&quot;a&quot;,&quot;g&quot;]</pre></div> <p>while</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;([ln])&quot;,[{return,list}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>[&quot;Er&quot;,&quot;l&quot;,&quot;a&quot;,&quot;n&quot;,&quot;g&quot;]</pre></div> <p>The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.</p> <p>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option <span class=\"code\">group</span>, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;([ln])&quot;,[{return,list},group]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>[[&quot;Er&quot;,&quot;l&quot;],[&quot;a&quot;,&quot;n&quot;],[&quot;g&quot;]]</pre></div> <p>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found.</p> <p>By default, all parts of the string, including the empty strings, are returned from the function, for example:</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>[&quot;Er&quot;,&quot;an&quot;,[]]</pre></div> <p>as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which is also returned. This behavior differs from the default behavior of the split function in Perl, where empty strings at the end are by default removed. To get the &quot;trimming&quot; default behavior of Perl, specify <span class=\"code\">trim</span> as an option:</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list},trim]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>[&quot;Er&quot;,&quot;an&quot;]</pre></div> <p>The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying <span class=\"code\">{parts,</span>N<span class=\"code\">}</span>:</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list},{parts,2}]).</pre></div> <p>gives</p> <div class=\"example example-none\"><pre>[&quot;Er&quot;,&quot;ang&quot;]</pre></div> <p>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of <span class=\"code\">trim</span>.</p> <p>More than three parts are not possible with this indata, so</p> <div class=\"example example-none\"><pre>re:split(&quot;Erlang&quot;,&quot;[lg]&quot;,[{return,list},{parts,4}]).</pre></div> <p>gives the same result as the default, which is to be viewed as &quot;an infinite number of parts&quot;.</p> <p>Specifying <span class=\"code\">0</span> as the number of parts gives the same effect as option <span class=\"code\">trim</span>. If subexpressions are captured, empty subexpressions matched at the end are also stripped from the result if <span class=\"code\">trim</span> or <span class=\"code\">{parts,0}</span> is specified.</p> <p>The <span class=\"code\">trim</span> behavior corresponds exactly to the Perl default. <span class=\"code\">{parts,N}</span>, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of <span class=\"code\">split/3</span> corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</p> <p>Summary of options not previously described for function <span class=\"code\">run/3</span>:</p> <dl> <dt><strong><span class=\"code\">{return,ReturnType}</span></strong></dt> <dd> <p>Specifies how the parts of the original string are presented in the result list. Valid types:</p> <dl> <dt><strong><span class=\"code\">iodata</span></strong></dt> <dd> <p>The variant of <span class=\"code\">iodata()</span> that gives the least copying of data with the current implementation (often a binary, but do not depend on it).</p></dd> <dt><strong><span class=\"code\">binary</span></strong></dt> <dd> <p>All parts returned as binaries.</p></dd> <dt><strong><span class=\"code\">list</span></strong></dt> <dd> <p>All parts returned as lists of characters (&quot;strings&quot;).</p> </dd> </dl> </dd> <dt><strong><span class=\"code\">group</span></strong></dt> <dd> <p>Groups together the part of the string with the parts of the string matching the subexpressions of the regular expression.</p> <p>The return value from the function is in this case a <span class=\"code\">list()</span> of <span class=\"code\">list()</span>s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression.</p> </dd> <dt><strong><span class=\"code\">{parts,N}</span></strong></dt> <dd> <p>Specifies the number of parts the subject string is to be split into.</p> <p>The number of parts is to be a positive integer for a specific maximum number of parts, and <span class=\"code\">infinity</span> for the maximum number of parts possible (the default). Specifying <span class=\"code\">{parts,0}</span> gives as many parts as possible disregarding empty parts at the end, the same as specifying <span class=\"code\">trim</span>.</p> </dd> <dt><strong><span class=\"code\">trim</span></strong></dt> <dd> <p>Specifies that empty parts at the end of the result list are to be disregarded. The same as specifying <span class=\"code\">{parts,0}</span>. This corresponds to the default behavior of the <span class=\"code\">split</span> built-in function in Perl.</p> </dd> </dl> <p></p></div> "
}
