{
	"erlref": {
		"header": {
			"copyright": {
				"year": [
					"2007",
					"2017"
				],
				"holder": "Ericsson AB, All Rights Reserved"
			},
			"legalnotice": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. The Initial Developer of the Original Code is Ericsson AB.",
			"title": "re",
			"prepared": "Patrik Nyblom",
			"responsible": "Kenneth Lundin",
			"docno": "1",
			"approved": {},
			"checked": {},
			"date": "2008-05-27",
			"rev": "A",
			"file": "re.xml"
		},
		"module": {
			"since": "",
			"$t": "re"
		},
		"modulesummary": "Perl-like regular expressions for Erlang.",
		"description": {
			"p": [
				"This module contains regular expression matching functions for strings and binaries.",
				{
					"seealso": {
						"marker": "#regexp_syntax",
						"$t": "regular expression"
					}
				},
				"The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here."
			],
			"note": {
				"p": "The Erlang literal syntax for strings uses the \"\\\" (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, \"\\\\\"."
			}
		},
		"datatypes": {
			"datatype": [
				{
					"name": {
						"name": "mp"
					},
					"desc": {
						"p": {
							"c": [
								"mp()",
								"re_pattern"
							]
						}
					}
				},
				{
					"name": {
						"name": "nl_spec"
					}
				},
				{
					"name": {
						"name": "compile_option"
					}
				}
			]
		},
		"funcs": {
			"func": [
				{
					"name": {
						"name": "version",
						"arity": "0",
						"since": "OTP 20.0"
					},
					"fsummary": "Gives the PCRE version of the system in a string format",
					"desc": {
						"p": "The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation."
					}
				},
				{
					"name": {
						"name": "compile",
						"arity": "1",
						"since": ""
					},
					"fsummary": "Compile a regular expression into a match program",
					"desc": {
						"p": {
							"c": {
								"anno": "Regexp"
							}
						}
					}
				},
				{
					"name": {
						"name": "compile",
						"arity": "2",
						"since": ""
					},
					"fsummary": "Compile a regular expression into a match program.",
					"desc": {
						"p": [
							{
								"seealso": [
									{
										"marker": "#run/2",
										"c": "run/2"
									},
									{
										"marker": "#run/3",
										"c": "run/3"
									}
								]
							},
							"Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match.",
							{
								"c": [
									"unicode",
									"charlist()",
									"iodata()"
								]
							},
							"Options:"
						],
						"marker": {
							"id": "compile_options"
						},
						"taglist": {
							"tag": [
								{
									"c": "unicode"
								},
								{
									"c": "anchored"
								},
								{
									"c": "caseless"
								},
								{
									"c": "dollar_endonly"
								},
								{
									"c": "dotall"
								},
								{
									"c": "extended"
								},
								{
									"c": "firstline"
								},
								{
									"c": "multiline"
								},
								{
									"c": "no_auto_capture"
								},
								{
									"c": "dupnames"
								},
								{
									"c": "ungreedy"
								},
								{
									"c": "{newline, NLSpec}"
								},
								{
									"c": "bsr_anycrlf"
								},
								{
									"c": "bsr_unicode"
								},
								{
									"c": "no_start_optimize"
								},
								{
									"c": "ucp"
								},
								{
									"c": "never_utf"
								}
							],
							"item": [
								{
									"p": {
										"c": [
											"charlist()",
											"charlist()",
											"ucp"
										]
									}
								},
								{
									"p": "The pattern is forced to be \"anchored\", that is, it is constrained to match only at the first matching point in the string that is searched (the \"subject string\"). This effect can also be achieved by appropriate constructs in the pattern itself."
								},
								{
									"p": {
										"c": [
											"/i",
											"(?i)"
										]
									}
								},
								{
									"p": {
										"c": "multiline"
									}
								},
								{
									"p": {
										"c": [
											"/s",
											"(?s)",
											"[^a]"
										]
									}
								},
								{
									"p": [
										{
											"c": [
												"(?>",
												"{1,3}"
											]
										},
										"White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space.",
										{
											"c": [
												"/x",
												"(?x)"
											]
										},
										{
											"c": "(?("
										}
									]
								},
								{
									"p": "An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline."
								},
								{
									"p": [
										{
											"c": [
												"^",
												"$",
												"dollar_endonly"
											]
										},
										{
											"c": [
												"/m",
												"(?m)",
												"^",
												"$",
												"multiline"
											]
										}
									]
								},
								{
									"p": {
										"c": [
											"?",
											"?:"
										]
									}
								},
								{
									"p": "Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below."
								},
								{
									"p": {
										"c": "(?U)"
									}
								},
								{
									"p": "Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.",
									"taglist": {
										"tag": [
											{
												"c": "cr"
											},
											{
												"c": "lf"
											},
											{
												"c": "crlf"
											},
											{
												"c": "anycrlf"
											},
											{
												"c": "any"
											}
										],
										"item": [
											{
												"p": {
													"c": "cr"
												}
											},
											{
												"p": "Newline is indicated by a single character LF (ASCII 10), the default."
											},
											{
												"p": "Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence."
											},
											{
												"p": "Any of the three preceding sequences is to be recognized."
											},
											{
												"p": "Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029)."
											}
										]
									}
								},
								{
									"p": "Specifies specifically that R is to match only the CR, LF, or CRLF sequences, not the Unicode-specific newline characters."
								},
								{
									"p": "Specifies specifically that R is to match all the Unicode newline characters (including CRLF, and so on, the default)."
								},
								{
									"p": {
										"seealso": {
											"marker": "#regexp_syntax_details",
											"$t": "PCRE Regular Expression Details"
										}
									}
								},
								{
									"p": "Specifies that Unicode character properties are to be used when resolving \B, \b, \D, \d, \S, \s, \W and \w. Without this flag, only ISO Latin-1 properties are used. Using Unicode properties hurts performance, but is semantically correct when working with Unicode characters beyond the ISO Latin-1 range."
								},
								{
									"p": {
										"c": "unicode"
									}
								}
							]
						}
					}
				},
				{
					"name": {
						"name": "inspect",
						"arity": "2",
						"since": "OTP 17.0"
					},
					"fsummary": "Inspects a compiled regular expression.",
					"desc": {
						"p": [
							{
								"c": [
									"namelist",
									"{namelist, [binary()]}"
								]
							},
							{
								"c": [
									"{capture, all_names}",
									"run/3"
								],
								"seealso": {
									"marker": "#run/3",
									"c": "run/3"
								}
							}
						],
						"code": [
							{
								"type": "none",
								"$t": "1> {ok,MP} = re:compile(\"(?<A>A)|(?<B>B)|(?<C>C)\").{ok,{re_pattern,3,0,0, <<69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...>>}}2> re:inspect(MP,namelist).{namelist,[<<\"A\">>,<<\"B\">>,<<\"C\">>]}3> {ok,MPD} = re:compile(\"(?<C>A)|(?<B>B)|(?<C>C)\",[dupnames]).{ok,{re_pattern,3,0,0, <<69,82,67,80,119,0,0,0,0,0,8,0,1,0,0,0,255,255,255,255, 255,255,...>>}}4> re:inspect(MPD,namelist). {namelist,[<<\"B\">>,<<\"C\">>]}"
							},
							"1> {ok,MP} = re:compile(\"(?<A>A)|(?<B>B)|(?<C>C)\").{ok,{re_pattern,3,0,0, <<69,82,67,80,119,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255, 255,255,...>>}}2> {namelist, N} = re:inspect(MP,namelist).{namelist,[<<\"A\">>,<<\"B\">>,<<\"C\">>]}3> {match,L} = re:run(\"AA\",MP,[{capture,all_names,binary}]).{match,[<<\"A\">>,<<>>,<<>>]}4> NameMap = lists:zip(N,L).[{<<\"A\">>,<<\"A\">>},{<<\"B\">>,<<>>},{<<\"C\">>,<<>>}]"
						]
					}
				},
				{
					"name": {
						"name": "replace",
						"arity": "3",
						"since": ""
					},
					"fsummary": "Match a subject against regular expression and replace matching elements with Replacement.",
					"desc": {
						"p": {
							"c": {
								"anno": [
									"Subject",
									"RE",
									"Replacement"
								]
							}
						}
					}
				},
				{
					"name": {
						"name": "replace",
						"arity": "4",
						"since": ""
					},
					"fsummary": "Match a subject against regular expression and replace matching elements with Replacement.",
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Subject"
									},
									{
										"anno": "Replacement"
									}
								]
							},
							{
								"seealso": {
									"marker": "#run/3",
									"c": "run/3"
								},
								"c": [
									"capture",
									{
										"anno": "ReturnType"
									},
									"iodata",
									"iodata",
									"list()",
									"{return, list}",
									"{return, binary}"
								]
							},
							{
								"c": [
									"run/3",
									"mp()",
									"unicode",
									{
										"anno": "Subject"
									},
									"charlist()",
									"unicode",
									{
										"anno": "Subject"
									},
									"charlist()"
								]
							},
							{
								"c": [
									"&",
									"\\",
									"\\g",
									"\\g{",
									"}"
								]
							},
							{
								"c": [
									"\"\\\\\"",
									"\"\\\\\\\\\""
								]
							},
							{
								"em": "Example:"
							},
							"gives",
							"while",
							"gives",
							{
								"c": [
									"run/3",
									"badarg"
								],
								"seealso": {
									"marker": "#compile/2",
									"c": "compile/2"
								}
							}
						],
						"code": [
							"re:replace(\"abcd\",\"c\",\"[&]\",[{return,list}]).",
							"\"ab[c]d\"",
							"re:replace(\"abcd\",\"c\",\"[\\\\&]\",[{return,list}]).",
							"\"ab[&]d\""
						]
					}
				},
				{
					"name": {
						"name": "run",
						"arity": "2",
						"since": ""
					},
					"fsummary": "Match a subject against regular expression and capture subpatterns.",
					"desc": {
						"p": {
							"c": {
								"anno": [
									"Subject",
									"RE"
								]
							}
						}
					}
				},
				{
					"name": {
						"name": "run",
						"arity": "3",
						"since": ""
					},
					"fsummary": "Match a subject against regular expression and capture subpatterns.",
					"type_desc": {
						"variable": "CompileOpt",
						"seealso": {
							"marker": "#compile_options",
							"c": "compile/2"
						}
					},
					"desc": {
						"p": [
							{
								"c": [
									{
										"anno": "Captured"
									},
									"nomatch",
									"iodata()",
									"compile/2",
									"mp()"
								]
							},
							{
								"c": [
									"badarg",
									"compile/2"
								]
							},
							"If the regular expression is previously compiled, the option list can only contain the following options:",
							{
								"c": [
									"compile/2",
									"anchored",
									{
										"anno": "NLSpec"
									}
								]
							},
							{
								"c": [
									"unicode",
									{
										"anno": "Subject"
									},
									"charlist()",
									"iodata()",
									"unicode",
									{
										"anno": "Subject"
									},
									"charlists()"
								]
							},
							{
								"c": [
									{
										"anno": [
											"ValueSpec",
											"ValueSpec",
											"Type"
										]
									},
									"capture"
								]
							},
							{
								"c": [
									"{capture, none}",
									"match",
									{
										"anno": "ValueList"
									},
									"none",
									{
										"anno": "ValueSpec"
									}
								]
							},
							{
								"c": [
									"report_errors",
									"match_limit",
									"match_limit_recursion",
									{
										"anno": "CompileErr"
									},
									"report_errors",
									"badarg",
									"nomatch"
								]
							},
							"The following options are relevant for execution:",
							{
								"seealso": {
									"marker": "#compile/2",
									"c": "compile/2"
								}
							}
						],
						"list": {
							"type": "bulleted",
							"item": [
								{
									"c": "anchored"
								},
								{
									"c": {
										"anno": [
											"ValueSpec",
											"ValueSpec",
											"Type"
										]
									}
								},
								{
									"c": "global"
								},
								{
									"c": "{match_limit, integer() >= 0}"
								},
								{
									"c": "{match_limit_recursion, integer() >= 0}"
								},
								{
									"c": {
										"anno": "NLSpec"
									}
								},
								{
									"c": "notbol"
								},
								{
									"c": "notempty"
								},
								{
									"c": "notempty_atstart"
								},
								{
									"c": "noteol"
								},
								{
									"c": "{offset, integer() >= 0}"
								},
								{
									"c": "report_errors"
								}
							]
						},
						"taglist": {
							"tag": [
								{
									"c": "anchored"
								},
								{
									"c": "global"
								},
								{
									"c": "notempty"
								},
								{
									"c": "notempty_atstart"
								},
								{
									"c": "notbol"
								},
								{
									"c": "noteol"
								},
								{
									"c": "report_errors"
								},
								{
									"c": "{match_limit, integer() >= 0}"
								},
								{
									"c": "{match_limit_recursion, integer() >= 0}"
								},
								{
									"c": "{offset, integer() >= 0}"
								},
								{
									"c": {
										"anno": "NLSpec"
									}
								},
								{
									"c": "bsr_anycrlf"
								},
								{
									"c": "bsr_unicode"
								},
								{
									"c": [
										{
											"anno": "ValueSpec"
										},
										{
											"anno": [
												"ValueSpec",
												"Type"
											]
										}
									]
								}
							],
							"item": [
								{
									"p": {
										"c": [
											"run/3",
											"anchored",
											"unanchored"
										]
									}
								},
								{
									"p": [
										{
											"c": [
												"g",
												"list()",
												"capture",
												{
													"anno": "Captured"
												},
												"list()",
												"list()"
											]
										},
										{
											"c": [
												"global",
												"global",
												"run/3",
												"[anchored, notempty_atstart]"
											]
										},
										"The following matchings are performed:",
										"The result of the call is:"
									],
									"code": [
										"re:run(\"cat\",\"(|at)\",[global]).",
										"{match,[[{0,0},{0,0}],[{1,0},{1,0}],[{1,2},{1,2}],[{3,0},{3,0}]]}"
									],
									"taglist": {
										"tag": [
											{
												"c": "0"
											},
											{
												"c": [
													"0",
													"[anchored, notempty_atstart]"
												]
											},
											{
												"c": "1"
											},
											{
												"c": [
													"1",
													"[anchored, notempty_atstart]"
												]
											},
											{
												"c": "3"
											},
											{
												"c": [
													"1",
													"[anchored, notempty_atstart]"
												]
											}
										],
										"item": [
											{
												"p": {
													"c": [
														"(|at)",
														"cat",
														"[{0,0},{0,0}]",
														"{0,0}"
													]
												}
											},
											{
												"p": {
													"c": [
														"[anchored, notempty_atstart]",
														"a"
													]
												}
											},
											{
												"p": {
													"c": "[{1,0},{1,0}]"
												}
											},
											{
												"p": {
													"c": "ab"
												}
											},
											{
												"p": {
													"c": "[{3,0},{3,0}]"
												}
											},
											{
												"p": "This gives no result of length > 0 and we are at the last position, so the global search is complete."
											}
										]
									}
								},
								{
									"p": [
										"An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails.",
										{
											"em": "Example:"
										},
										"If the following pattern is applied to a string not beginning with \"a\" or \"b\", it would normally match the empty string at the start of the subject:",
										{
											"c": [
												"notempty",
												"run/3"
											]
										}
									],
									"code": "a?b?"
								},
								{
									"p": [
										{
											"c": "notempty"
										},
										{
											"c": [
												"notempty",
												"notempty_atstart",
												"/g",
												"notempty_atstart",
												"anchored"
											]
										}
									]
								},
								{
									"p": {
										"c": "multiline"
									}
								},
								{
									"p": {
										"c": "multiline"
									}
								},
								{
									"p": [
										{
											"c": "run/3"
										},
										"The following are the possible runtime errors:",
										"It is important to understand that what is referred to as \"recursion\" when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine \"heap\" memory to store values that must be kept over recursion in regular expression matches."
									],
									"taglist": {
										"tag": [
											{
												"c": "match_limit"
											},
											{
												"c": "match_limit_recursion"
											}
										],
										"item": [
											{
												"p": {
													"c": [
														"{error, match_limit}",
														"nomatch",
														"report_errors"
													]
												}
											},
											{
												"p": {
													"c": [
														"match_limit",
														"match_limit_recursion",
														"match_limit",
														"match_limit_default",
														"match_limit_recursion",
														"match_limit",
														"run/3"
													],
													"seealso": {
														"marker": "#regexp_syntax_details",
														"$t": "PCRE Regular Eexpression Details"
													}
												}
											}
										]
									}
								},
								{
									"p": [
										"Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:",
										"This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM."
									],
									"code": "The match_limit field provides a means of preventing PCRE from usingup a vast amount of resources when running patterns that are not goingto match, but which have a very large number of possibilities in theirsearch trees. The classic example is a pattern that uses nestedunlimited repeats.Internally, pcre_exec() uses a function called match(), which it callsrepeatedly (sometimes recursively). The limit set by match_limit isimposed on the number of times this function is called during a match,which has the effect of limiting the amount of backtracking that cantake place. For patterns that are not anchored, the count restartsfrom zero for each position in the subject string.",
									"note": {
										"p": {
											"c": "run/3"
										}
									}
								},
								{
									"p": [
										{
											"c": "match_limit"
										},
										"The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.",
										"Specifying a lower value can result in matches with deep recursion failing, when they should have matched:",
										{
											"c": "match_limit"
										}
									],
									"code": [
										"The match_limit_recursion field is similar to match_limit, but insteadof limiting the total number of times that match() is called, itlimits the depth of recursion. The recursion depth is a smaller numberthan the total number of calls, because not all calls to match() arerecursive. This limit is of use only if it is set smaller thanmatch_limit.Limiting the recursion depth limits the amount of machine stack thatcan be used, or, when PCRE has been compiled to use memory on the heapinstead of the stack, the amount of heap memory that can be used.",
										{
											"type": "none",
											"$t": "1> re:run(\"aaaaaaaaaaaaaz\",\"(a+)*z\").{match,[{0,14},{0,13}]}2> re:run(\"aaaaaaaaaaaaaz\",\"(a+)*z\",[{match_limit_recursion,5}]).nomatch3> re:run(\"aaaaaaaaaaaaaz\",\"(a+)*z\",[{match_limit_recursion,5},report_errors]).{error,match_limit_recursion}"
										}
									]
								},
								{
									"p": {
										"c": "{offset,0}"
									}
								},
								{
									"p": "Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.",
									"taglist": {
										"tag": [
											{
												"c": "cr"
											},
											{
												"c": "lf"
											},
											{
												"c": "crlf"
											},
											{
												"c": "anycrlf"
											},
											{
												"c": "any"
											}
										],
										"item": [
											{
												"p": "Newline is indicated by a single character CR (ASCII 13)."
											},
											{
												"p": "Newline is indicated by a single character LF (ASCII 10), the default."
											},
											{
												"p": "Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence."
											},
											{
												"p": "Any of the three preceding sequences is be recognized."
											},
											{
												"p": "Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029)."
											}
										]
									}
								},
								{
									"p": "Specifies specifically that R is to match only the CR LF, or CRLF sequences, not the Unicode-specific newline characters. (Overrides the compilation option.)"
								},
								{
									"p": "Specifies specifically that R is to match all the Unicode newline characters (including CRLF, and so on, the default). (Overrides the compilation option.)"
								},
								{
									"p": [
										{
											"c": [
												"run/3",
												"{Offset,Length}",
												"index",
												{
													"anno": "Type"
												}
											]
										},
										{
											"c": "{3,4}"
										},
										"The return value of this call is:",
										"Another (and quite common) case is where the regular expression matches all of the subject:",
										"Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:",
										"If the regular expression contains capturing subpatterns, like in:",
										"all of the matched subject is captured, as well as the captured substrings:",
										"The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.",
										"The capture tuple is built up as follows:",
										{
											"c": [
												"{-1,0}",
												"type",
												"index"
											]
										},
										{
											"c": [
												"((?<FOO>abdd)|a(..d))",
												"(?<FOO>abdd)",
												"(..d)"
											]
										},
										{
											"c": "a(..d)"
										},
										{
											"c": [
												{
													"anno": "Type"
												},
												"binary"
											]
										},
										{
											"c": [
												"<<>>",
												"binary",
												"<<>>"
											]
										},
										{
											"c": [
												"type",
												"index"
											]
										},
										{
											"c": [
												"global",
												"capture"
											]
										},
										"gives"
									],
									"code": [
										"re:run(\"ABCabcdABC\",\"abcd\",[]).",
										"{match,[{3,4}]}",
										"re:run(\"ABCabcdABC\",\".*abcd.*\",[]).",
										"{match,[{0,10}]}",
										"re:run(\"ABCabcdABC\",\".*(abcd).*\",[]).",
										"{match,[{0,10},{3,4}]}",
										"\".*((?<FOO>abdd)|a(..d)).*\"",
										"\"ABCabcdABC\"",
										"{match,[{0,10},{3,4},{-1,0},{4,3}]}",
										"{match,[<<\"ABCabcdABC\">>,<<\"abcd\">>,<<>>,<<\"bcd\">>]}",
										"re:run(\"cacb\",\"c(a|b)\",[global,{capture,[1],list}]).",
										"{match,[[\"a\"],[\"b\"]]}"
									],
									"taglist": {
										"tag": [
											{
												"c": {
													"anno": "ValueSpec"
												}
											},
											{
												"c": {
													"anno": "Type"
												}
											}
										],
										"item": [
											{
												"p": [
													{
														"c": {
															"anno": "ValueSpec"
														}
													},
													"The following are the predefined sets of subpatterns:",
													{
														"c": [
															"atom()",
															"string()"
														]
													},
													"matched against string \"ABCabcdABC\", capturing only the \"abcd\" part (the first explicit subpattern):",
													"The call gives the following result, as the first explicitly captured subpattern is \"(abcd)\", matching \"abcd\" in the subject, at (zero-based) position 3, of length 4:",
													"Consider the same regular expression, but with the subpattern explicitly named 'FOO':",
													"With this expression, we could still give the index of the subpattern with the following call:",
													"giving the same result as before. But, as the subpattern is named, we can also specify its name in the value list:",
													"This would give the same result as the earlier examples, namely:",
													{
														"c": [
															"index",
															"{-1,0}",
															"binary",
															"list"
														]
													}
												],
												"taglist": {
													"tag": [
														{
															"c": "all"
														},
														{
															"c": "all_names"
														},
														{
															"c": "first"
														},
														{
															"c": "all_but_first"
														},
														{
															"c": "none"
														}
													],
													"item": [
														{
															"p": "All captured subpatterns including the complete matching string. This is the default."
														},
														{
															"p": {
																"em": [
																	"named",
																	"in alphabetical order"
																],
																"c": "list()",
																"seealso": {
																	"marker": "#inspect/2",
																	"c": "inspect/2"
																}
															}
														},
														{
															"p": "Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded."
														},
														{
															"p": {
																"c": [
																	"list",
																	"binary"
																]
															}
														},
														{
															"p": {
																"c": [
																	"match",
																	"{match, list()}"
																]
															}
														}
													]
												},
												"code": [
													"\".*(abcd).*\"",
													"re:run(\"ABCabcdABC\",\".*(abcd).*\",[{capture,[1]}]).",
													"{match,[{3,4}]}",
													"\".*(?<FOO>abcd).*\"",
													"re:run(\"ABCabcdABC\",\".*(?<FOO>abcd).*\",[{capture,[1]}]).",
													"re:run(\"ABCabcdABC\",\".*(?<FOO>abcd).*\",[{capture,['FOO']}]).",
													"{match,[{3,4}]}"
												]
											},
											{
												"p": [
													{
														"c": "index"
													},
													{
														"c": {
															"anno": "Type"
														}
													}
												],
												"taglist": {
													"tag": [
														{
															"c": "index"
														},
														{
															"c": "list"
														},
														{
															"c": "binary"
														}
													],
													"item": [
														{
															"p": {
																"seealso": [
																	{
																		"marker": "erts:erlang#iolist_to_binary/1",
																		"c": "erlang:iolist_to_binary/1"
																	},
																	{
																		"marker": "unicode#characters_to_binary/2",
																		"c": "unicode:characters_to_binary/2"
																	}
																],
																"c": [
																	"unicode",
																	"{0,2}",
																	"unicode"
																],
																"em": [
																	"byte-oriented",
																	"UTF-8 encoded"
																]
															}
														},
														{
															"p": {
																"c": [
																	"string()",
																	"unicode",
																	"list",
																	"incomplete",
																	"error"
																],
																"seealso": {
																	"marker": "unicode#characters_to_list/2",
																	"c": "unicode:characters_to_list/2"
																}
															}
														},
														{
															"p": {
																"c": [
																	"unicode",
																	"unicode"
																]
															}
														}
													]
												}
											}
										]
									}
								}
							]
						}
					}
				},
				{
					"name": {
						"name": "split",
						"arity": "2",
						"since": ""
					},
					"fsummary": "Split a string by tokens specified as a regular expression.",
					"desc": {
						"p": {
							"c": {
								"anno": [
									"Subject",
									"RE"
								]
							}
						}
					}
				},
				{
					"name": {
						"name": "split",
						"arity": "3",
						"since": ""
					},
					"fsummary": "Split a string by tokens specified as a regular expression",
					"type_desc": {
						"variable": "CompileOpt",
						"seealso": {
							"marker": "#compile_options",
							"c": "compile/2"
						}
					},
					"desc": {
						"p": [
							"Splits the input into parts by finding tokens according to the regular expression supplied. The splitting is basically done by running a global regular expression match and dividing the initial string wherever a match occurs. The matching part of the string is removed from the output.",
							{
								"seealso": {
									"marker": "#run/3",
									"c": "run/3"
								},
								"c": [
									"mp()",
									"unicode",
									{
										"anno": "Subject"
									},
									"charlist()",
									"unicode",
									{
										"anno": "Subject"
									},
									"charlist()"
								]
							},
							{
								"c": [
									"return",
									"iodata"
								]
							},
							"If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:",
							"gives",
							"while",
							"gives",
							"The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.",
							{
								"c": "group"
							},
							"gives",
							"Here the regular expression first matched the \"l\", causing \"Er\" to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the \"l\", so the \"l\" is inserted in the group together with \"Er\". The next match is of the \"n\", making \"a\" the next part to be returned. As the subexpression is bound to substring \"n\" in this case, the \"n\" is inserted into this group. The last group consists of the remaining string, as no more matches are found.",
							"By default, all parts of the string, including the empty strings, are returned from the function, for example:",
							"gives",
							{
								"c": "trim"
							},
							"gives",
							{
								"c": [
									"{parts,",
									"}"
								]
							},
							"gives",
							{
								"c": "trim"
							},
							"More than three parts are not possible with this indata, so",
							"gives the same result as the default, which is to be viewed as \"an infinite number of parts\".",
							{
								"c": [
									"0",
									"trim",
									"trim",
									"{parts,0}"
								]
							},
							{
								"c": [
									"trim",
									"{parts,N}",
									"split/3"
								]
							},
							{
								"c": "run/3"
							}
						],
						"code": [
							"re:split(\"Erlang\",\"[ln]\",[{return,list}]).",
							"[\"Er\",\"a\",\"g\"]",
							"re:split(\"Erlang\",\"([ln])\",[{return,list}]).",
							"[\"Er\",\"l\",\"a\",\"n\",\"g\"]",
							"re:split(\"Erlang\",\"([ln])\",[{return,list},group]).",
							"[[\"Er\",\"l\"],[\"a\",\"n\"],[\"g\"]]",
							"re:split(\"Erlang\",\"[lg]\",[{return,list}]).",
							"[\"Er\",\"an\",[]]",
							"re:split(\"Erlang\",\"[lg]\",[{return,list},trim]).",
							"[\"Er\",\"an\"]",
							"re:split(\"Erlang\",\"[lg]\",[{return,list},{parts,2}]).",
							"[\"Er\",\"ang\"]",
							"re:split(\"Erlang\",\"[lg]\",[{return,list},{parts,4}])."
						],
						"taglist": {
							"tag": [
								{
									"c": {
										"anno": "ReturnType"
									}
								},
								{
									"c": "group"
								},
								{
									"c": "{parts,N}"
								},
								{
									"c": "trim"
								}
							],
							"item": [
								{
									"p": "Specifies how the parts of the original string are presented in the result list. Valid types:",
									"taglist": {
										"tag": [
											{
												"c": "iodata"
											},
											{
												"c": "binary"
											},
											{
												"c": "list"
											}
										],
										"item": [
											{
												"p": {
													"c": "iodata()"
												}
											},
											{
												"p": "All parts returned as binaries."
											},
											{
												"p": "All parts returned as lists of characters (\"strings\")."
											}
										]
									}
								},
								{
									"p": [
										"Groups together the part of the string with the parts of the string matching the subexpressions of the regular expression.",
										{
											"c": [
												"list()",
												"list()"
											]
										}
									]
								},
								{
									"p": [
										"Specifies the number of parts the subject string is to be split into.",
										{
											"c": [
												"infinity",
												"{parts,0}",
												"trim"
											]
										}
									]
								},
								{
									"p": {
										"c": [
											"{parts,0}",
											"split"
										]
									}
								}
							]
						}
					}
				}
			]
		},
		"section": [
			{
				"marker": {
					"id": "regexp_syntax"
				},
				"title": "Perl-Like Regular Expression Syntax",
				"p": "The following sections contain reference material for the regular expressions used by this module. The information is based on the PCRE documentation, with changes where this module behaves differently to the PCRE library."
			},
			{
				"marker": {
					"id": "regexp_syntax_details"
				},
				"title": "PCRE Regular Expression Details",
				"p": [
					"The syntax and semantics of the regular expressions supported by PCRE are described in detail in the following sections. Perl's regular expressions are described in its own documentation, and regular expressions in general are covered in many books, some with copious examples. Jeffrey Friedl's \"Mastering Regular Expressions\", published by O'Reilly, covers regular expressions in great detail. This description of the PCRE regular expressions is intended as reference material.",
					"The reference material is divided into the following sections:"
				],
				"list": {
					"type": "bulleted",
					"item": [
						{
							"seealso": {
								"marker": "#sect1",
								"$t": "Special Start-of-Pattern Items"
							}
						},
						{
							"seealso": {
								"marker": "#sect2",
								"$t": "Characters and Metacharacters"
							}
						},
						{
							"seealso": {
								"marker": "#sect3",
								"$t": "Backslash"
							}
						},
						{
							"seealso": {
								"marker": "#sect4",
								"$t": "Circumflex and Dollar"
							}
						},
						{
							"seealso": {
								"marker": "#sect5",
								"$t": "Full Stop (Period, Dot) and \\N"
							}
						},
						{
							"seealso": {
								"marker": "#sect6",
								"$t": "Matching a Single Data Unit"
							}
						},
						{
							"seealso": {
								"marker": "#sect7",
								"$t": "Square Brackets and Character Classes"
							}
						},
						{
							"seealso": {
								"marker": "#sect8",
								"$t": "Posix Character Classes"
							}
						},
						{
							"seealso": {
								"marker": "#sect9",
								"$t": "Vertical Bar"
							}
						},
						{
							"seealso": {
								"marker": "#sect10",
								"$t": "Internal Option Setting"
							}
						},
						{
							"seealso": {
								"marker": "#sect11",
								"$t": "Subpatterns"
							}
						},
						{
							"seealso": {
								"marker": "#sect12",
								"$t": "Duplicate Subpattern Numbers"
							}
						},
						{
							"seealso": {
								"marker": "#sect13",
								"$t": "Named Subpatterns"
							}
						},
						{
							"seealso": {
								"marker": "#sect14",
								"$t": "Repetition"
							}
						},
						{
							"seealso": {
								"marker": "#sect15",
								"$t": "Atomic Grouping and Possessive Quantifiers"
							}
						},
						{
							"seealso": {
								"marker": "#sect16",
								"$t": "Back References"
							}
						},
						{
							"seealso": {
								"marker": "#sect17",
								"$t": "Assertions"
							}
						},
						{
							"seealso": {
								"marker": "#sect18",
								"$t": "Conditional Subpatterns"
							}
						},
						{
							"seealso": {
								"marker": "#sect19",
								"$t": "Comments"
							}
						},
						{
							"seealso": {
								"marker": "#sect20",
								"$t": "Recursive Patterns"
							}
						},
						{
							"seealso": {
								"marker": "#sect21",
								"$t": "Subpatterns as Subroutines"
							}
						},
						{
							"seealso": {
								"marker": "#sect22",
								"$t": "Oniguruma Subroutine Syntax"
							}
						},
						{
							"seealso": {
								"marker": "#sect23",
								"$t": "Backtracking Control"
							}
						}
					]
				}
			},
			{
				"marker": [
					{
						"id": "sect1"
					},
					{
						"id": "newline_conventions"
					}
				],
				"title": "Special Start-of-Pattern Items",
				"p": [
					{
						"seealso": {
							"marker": "#compile/2",
							"c": "compile/2"
						}
					},
					{
						"em": "UTF Support"
					},
					{
						"seealso": [
							{
								"marker": "#compile/2",
								"c": "compile/2"
							},
							{
								"marker": "#run/3",
								"c": "run/3"
							}
						],
						"c": "unicode"
					},
					{
						"c": [
							"re",
							"unicode"
						],
						"seealso": {
							"marker": "#compile/2",
							"c": "compile/2"
						}
					},
					{
						"c": "never_utf"
					},
					{
						"em": "Unicode Property Support"
					},
					"The following is another special sequence that can appear at the start of a pattern:",
					{
						"c": "ucp"
					},
					{
						"em": "Disabling Startup Optimizations"
					},
					{
						"c": [
							"(*NO_START_OPT)",
							"no_start_optimize"
						]
					},
					{
						"em": "Newline Conventions"
					},
					"PCRE supports five conventions for indicating line breaks in strings: a single CR (carriage return) character, a single LF (line feed) character, the two-character sequence CRLF, any of the three preceding, and any Unicode newline sequence.",
					"A newline convention can also be specified by starting a pattern string with one of the following five sequences:",
					{
						"seealso": {
							"marker": "#compile/2",
							"c": "compile/2"
						}
					},
					{
						"c": "a\\nb"
					},
					{
						"c": "dotall",
						"seealso": {
							"marker": "#newline_sequences",
							"$t": "Newline Sequences"
						}
					},
					{
						"em": "Setting Match and Recursion Limits"
					},
					{
						"seealso": {
							"marker": "#run/3",
							"c": "run/3"
						},
						"c": "pcre_exec()"
					},
					{
						"c": "run/3"
					},
					"The default value for both the limits is 10,000,000 in the Erlang VM. Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for Erlang is compiled in such a way that the match function never does recursion on the C stack.",
					{
						"c": [
							"LIMIT_MATCH",
							"LIMIT_RECURSION"
						]
					}
				],
				"code": [
					"(*UTF8)(*UTF)",
					"(*UCP)",
					"(*CR)a.b",
					"(*LIMIT_MATCH=d)(*LIMIT_RECURSION=d)"
				],
				"taglist": {
					"tag": [
						"(*CR)",
						"(*LF)",
						"(*CRLF)",
						"(*ANYCRLF)",
						"(*ANY)"
					],
					"item": [
						"Carriage return",
						"Line feed",
						">Carriage return followed by line feed",
						"Any of the three above",
						"All Unicode newline sequences"
					]
				}
			},
			{
				"marker": {
					"id": "sect2"
				},
				"title": "Characters and Metacharacters",
				"p": [
					"A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the subject. As a trivial example, the following pattern matches a portion of a subject string that is identical to itself:",
					{
						"c": "caseless"
					},
					{
						"em": "metacharacters"
					},
					"Two sets of metacharacters exist: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized within square brackets. Outside square brackets, the metacharacters are as follows:",
					"Part of a pattern within square brackets is called a \"character class\". The following are the only metacharacters in a character class:",
					"The following sections describe the use of each metacharacter."
				],
				"code": "The quick brown fox",
				"taglist": [
					{
						"tag": [
							"\\",
							"^",
							"$",
							".",
							"[",
							"|",
							"(",
							")",
							"?",
							"*",
							"+",
							"{"
						],
						"item": [
							"General escape character with many uses",
							"Assert start of string (or line, in multiline mode)",
							"Assert end of string (or line, in multiline mode)",
							"Match any character except newline (by default)",
							"Start character class definition",
							"Start of alternative branch",
							"Start subpattern",
							"End subpattern",
							"Extends the meaning of (, also 0 or 1 quantifier, also quantifier minimizer",
							"0 or more quantifiers",
							"1 or more quantifier, also \"possessive quantifier\"",
							"Start min/max quantifier"
						]
					},
					{
						"tag": [
							"\\",
							"^",
							"-",
							"[",
							"]"
						],
						"item": [
							"General escape character",
							"Negate the class, but only if the first character",
							"Indicates character range",
							"Posix character class (only if followed by Posix syntax)",
							"Terminates the character class"
						]
					}
				]
			},
			{
				"marker": [
					{
						"id": "sect3"
					},
					{
						"id": "non_printing_characters"
					},
					{
						"id": "generic_character_types"
					},
					{
						"id": "newline_sequences"
					}
				],
				"title": "Backslash",
				"p": [
					"The backslash character has many uses. First, if it is followed by a character that is not a number or a letter, it takes away any special meaning that a character can have. This use of backslash as an escape character applies both inside and outside character classes.",
					"For example, if you want to match a * character, you write \\* in the pattern. This escaping action applies if the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, write \\\\.",
					{
						"c": "unicode"
					},
					{
						"c": "extended"
					},
					"To remove the special meaning from a sequence of characters, put them between \Q and \E. This is different from Perl in that $ and @ are handled as literals in \Q...\E sequences in PCRE, while $ and @ cause variable interpolation in Perl. Notice the following examples:",
					"The \Q...\E sequence is recognized both inside and outside character classes. An isolated \E that is not preceded by \Q is ignored. If \Q is not followed by \E later in the pattern, the literal interpretation continues to the end of the pattern (that is, \E is assumed at the end). If the isolated \Q is inside a character class, this causes an error, as the character class is not terminated.",
					{
						"em": "Non-Printing Characters"
					},
					"A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern. When a pattern is prepared by text editing, it is often easier to use one of the following escape sequences than the binary character it represents:",
					"The precise effect of \cx on ASCII characters is as follows: if x is a lowercase letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus \cA to \cZ become hex 01 to hex 1A (A is 41, Z is 5A), but \c{ becomes hex 3B ({ is 7B), and \c; becomes hex 7B (; is 3B). If the data item (byte or 16-bit value) following \c has a value > 127, a compile-time error occurs. This locks out non-ASCII characters in all modes.",
					"The \c facility was designed for use with ASCII characters, but with the extension to Unicode it is even less useful than it once was.",
					"After \0 up to two further octal digits are read. If there are fewer than two digits, just those that are present are used. Thus the sequence \0\x\015 specifies two binary zeros followed by a CR character (code value 13). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.",
					"The escape \o must be followed by a sequence of octal digits, enclosed in braces. An error occurs if this is not the case. This escape is a recent addition to Perl; it provides way of specifying character code points as octal numbers greater than 0777, and it also allows octal numbers and back references to be unambiguously specified.",
					"For greater clarity and unambiguity, it is best to avoid following \ by a digit greater than zero. Instead, use \o{} or \x{} to specify character numbers, and \g{} to specify back references. The following paragraphs describe the old, ambiguous syntax.",
					{
						"em": "back reference"
					},
					"Inside a character class, or if the decimal number following \ is > 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters \"8\" and \"9\", and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:",
					"Notice that octal values >= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.",
					"By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.",
					"Characters whose value is less than 256 can be defined by either of the two syntaxes for \\x. There is no difference in the way they are handled. For example, \\xdc is exactly the same as \\x{dc}.",
					{
						"em": "Constraints on character values"
					},
					"Characters that are specified using octal or hexadecimal numbers are limited to certain values, as follows:",
					"Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called \"surrogate\" codepoints), and 0xffef.",
					{
						"em": "Escape sequences in character classes"
					},
					"All the sequences that define a single character value can be used both inside and outside character classes. Also, inside a character class, \\b is interpreted as the backspace character (hex 08).",
					"\N is not allowed in a character class. \B, R, and \X are not special inside a character class. Like other unrecognized escape sequences, they are treated as the literal characters \"B\", \"R\", and \"X\". Outside a character class, these sequences have different meanings.",
					{
						"em": "Unsupported Escape Sequences"
					},
					"In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.",
					{
						"em": "Absolute and Relative Back References"
					},
					"The sequence \g followed by an unsigned or a negative number, optionally enclosed in braces, is an absolute or relative back reference. A named back reference can be coded as \g{name}. Back references are discussed later, following the discussion of parenthesized subpatterns.",
					{
						"em": "Absolute and Relative Subroutine Calls"
					},
					{
						"em": "not"
					},
					{
						"em": "Generic Character Types"
					},
					"Another use of backslash is for specifying generic character types:",
					{
						"c": "dotall"
					},
					"Each pair of lowercase and uppercase escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair. The sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all fail, as there is no character to match.",
					"For compatibility with Perl, \s did not used to match the VT character (code 11), which made it different from the the POSIX \"space\" class. However, Perl added VT at release 5.18, and PCRE followed suit at release 8.34. The default \s characters are now HT (9), LF (10), VT (11), FF (12), CR (13), and space (32), which are defined as white space in the \"C\" locale. This list may vary if locale-specific matching is taking place. For example, in some locales the \"non-breaking space\" character (\xA0) is recognized as white space, and in others the VT character is not.",
					{
						"c": "unicode"
					},
					{
						"c": [
							"unicode",
							"ucp"
						]
					},
					{
						"c": [
							"ucp",
							"ucp"
						]
					},
					{
						"c": "ucp"
					},
					"The following are the horizontal space characters:",
					"The following are the vertical space characters:",
					"In 8-bit, non-UTF-8 mode, only the characters with code points < 256 are relevant.",
					{
						"em": "Newline Sequences"
					},
					"Outside a character class, by default, the escape sequence R matches any Unicode newline sequence. In non-UTF-8 mode, R is equivalent to the following:",
					"This is an example of an \"atomic group\", details are provided below.",
					"This particular group matches either the two-character sequence CR followed by LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab, U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next line, U+0085). The two-character sequence is treated as a single unit that cannot be split.",
					"In Unicode mode, two more characters whose code points are > 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.",
					{
						"c": [
							"bsr_anycrlf",
							"bsr_unicode"
						]
					},
					"These override the default and the options specified to the compiling function, but they can themselves be overridden by options specified to a matching function. Notice that these special settings, which are not Perl-compatible, are recognized only at the very start of a pattern, and that they must be in upper case. If more than one of them is present, the last one is used. They can be combined with a change of newline convention; for example, a pattern can start with:",
					"They can also be combined with the (*UTF8), (*UTF), or (*UCP) special sequences. Inside a character class, R is treated as an unrecognized escape sequence, and so matches the letter \"R\" by default.",
					{
						"em": "Unicode Character Properties"
					},
					"Three more escape sequences that match characters with specific properties are available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing characters whose code points are < 256, but they do work in this mode. The following are the extra escape sequences:",
					{
						"em": "xx"
					},
					"Sets of Unicode characters are defined as belonging to certain scripts. A character from one of these sets can be matched using a script name, for example:",
					"Those that are not part of an identified script are lumped together as \"Common\". The following is the current list of scripts:",
					"Each character has exactly one Unicode general category property, specified by a two-letter acronym. For compatibility with Perl, negation can be specified by including a circumflex between the opening brace and the property name. For example, \\p{^Lu} is the same as \\P{Lu}.",
					"If only one letter is specified with \p or \P, it includes all the general category properties that start with that letter. In this case, in the absence of negation, the curly brackets in the escape sequence are optional. The following two examples have the same effect:",
					"The following general category property codes are supported:",
					"The special property L& is also supported. It matches a character that has the Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier or \"other\".",
					"The Cs (Surrogate) property applies only to characters in the range U+D800 to U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested by PCRE. Perl does not support the Cs property.",
					"The long synonyms for property names supported by Perl (such as \\p{Letter}) are not supported by PCRE. It is not permitted to prefix any of these properties with \"Is\".",
					"No character in the Unicode table has the Cn (unassigned) property. This property is instead assumed for any code point that is not in the Unicode table.",
					"Specifying caseless matching does not affect these escape sequences. For example, \p{Lu} always matches only uppercase letters. This is different from the behavior of current versions of Perl.",
					{
						"c": "ucp"
					},
					{
						"em": "Extended Grapheme Clusters"
					},
					{
						"c": "(?>\\PM\\pM*)"
					},
					"This simple definition was extended in Unicode to include more complicated kinds of composite character by giving each character a grapheme breaking property, and creating rules that use these properties to define the boundaries of extended grapheme clusters. In PCRE releases later than 8.31, \X matches one of these clusters.",
					"\X always matches at least one character. Then it decides whether to add more characters according to the following rules for ending a cluster:",
					{
						"em": "PCRE Additional Properties"
					},
					{
						"c": "ucp"
					},
					"Perl and POSIX space are now the same. Perl added VT to its space character set at release 5.18 and PCRE changed at release 8.34.",
					"Xan matches characters that have either the L (letter) or the N (number) property. Xps matches the characters tab, linefeed, vertical tab, form feed, or carriage return, and any other character that has the Z (separator) property. Xsp is the same as Xps; it used to exclude vertical tab, for Perl compatibility, but Perl changed, and so PCRE followed at release 8.34. Xwd matches the same characters as Xan, plus underscore.",
					"There is another non-standard property, Xuc, which matches any character that can be represented by a Universal Character Name in C++ and other programming languages. These are the characters $, @, ` (grave accent), and all characters with Unicode code points >= U+00A0, except for the surrogates U+D800 to U+DFFF. Notice that most base (ASCII) characters are excluded. (Universal Character Names are of the form \\uHHHH or \\UHHHHHHHH, where H is a hexadecimal digit. Notice that the Xuc property does not match these sequences but the characters that they represent.)",
					{
						"em": "Resetting the Match Start"
					},
					"The escape sequence \\K causes any previously matched characters not to be included in the final matched sequence. For example, the following pattern matches \"foobar\", but reports that it has matched \"bar\":",
					"This feature is similar to a lookbehind assertion (described below). However, in this case, the part of the subject before the real match does not have to be of fixed length, as lookbehind assertions do. The use of \\K does not interfere with the setting of captured substrings. For example, when the following pattern matches \"foobar\", the first substring is still set to \"foo\":",
					"Perl documents that the use of \K within assertions is \"not well defined\". In PCRE, \K is acted upon when it occurs inside positive assertions, but is ignored in negative assertions. Note that when a pattern such as (?=ab\K) matches, the reported start of the match can be greater than the end of the match.",
					{
						"em": "Simple Assertions"
					},
					"The final use of backslash is for certain simple assertions. An assertion specifies a condition that must be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The following are the backslashed assertions:",
					"Inside a character class, \\b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \\B matches the letter B).",
					{
						"c": "ucp"
					},
					{
						"c": [
							"notbol",
							"noteol",
							"startoffset"
						],
						"seealso": {
							"marker": "#run/3",
							"c": "run/3"
						}
					},
					{
						"c": [
							"startoffset",
							"run/3",
							"startoffset",
							"run/3",
							"/g"
						]
					},
					"Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.",
					"If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the \"anchored\" flag is set in the compiled regular expression."
				],
				"code": [
					{
						"type": "none",
						"$t": "Pattern PCRE matches Perl matches\\Qabc$xyz\\E abc$xyz abc followed by the contents of $xyz\\Qabc\\$xyz\\E abc\\$xyz abc\\$xyz\\Qabc\\E\\$\\Qxyz\\E abc$xyz abc$xyz"
					},
					"(?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85)",
					"(*ANY)(*BSR_ANYCRLF)",
					"\\p{Greek} \\P{Han}",
					"\\p{L}\\pL",
					"foo\\Kbar",
					"(foo)\\Kbar"
				],
				"taglist": [
					{
						"tag": [
							"\\a",
							"\\cx",
							"\\e",
							"\\f",
							"\\n",
							"\\r",
							"\\t",
							"\\0dd",
							"\\ddd",
							"\\o{ddd..}",
							"\\xhh",
							"\\x{hhh..}"
						],
						"item": [
							"Alarm, that is, the BEL character (hex 07)",
							"\"Control-x\", where x is any ASCII character",
							"Escape (hex 1B)",
							"Form feed (hex 0C)",
							"Line feed (hex 0A)",
							"Carriage return (hex 0D)",
							"Tab (hex 09)",
							"Character with octal code 0dd",
							"Character with octal code ddd, or back reference",
							"character with octal code ddd..",
							"Character with hex code hh",
							"Character with hex code hhh.."
						]
					},
					{
						"tag": [
							"\\040",
							"\\40",
							"\\7",
							"\\11",
							"\\011",
							"\\0113",
							"\\113",
							"\\377",
							"\\81"
						],
						"item": [
							"Another way of writing an ASCII space",
							"The same, provided there are < 40 previous capturing subpatterns",
							"Always a back reference",
							"Can be a back reference, or another way of writing a tab",
							"Always a tab",
							"A tab followed by character \"3\"",
							"Can be a back reference, otherwise the character with octal code 113",
							"Can be a back reference, otherwise value 255 (decimal)",
							"Either a back reference, or the two characters \"8\" and \"1\""
						]
					},
					{
						"tag": [
							"8-bit non-UTF mode",
							"8-bit UTF-8 mode"
						],
						"item": [
							{
								"p": "< 0x100"
							},
							{
								"p": "< 0x10ffff and a valid codepoint"
							}
						]
					},
					{
						"tag": [
							"\\d",
							"\\D",
							"\\h",
							"\\H",
							"\\s",
							"\\S",
							"\\v",
							"\\V",
							"\\w",
							"\\W"
						],
						"item": [
							"Any decimal digit",
							"Any character that is not a decimal digit",
							"Any horizontal whitespace character",
							"Any character that is not a horizontal whitespace character",
							"Any whitespace character",
							"Any character that is not a whitespace character",
							"Any vertical whitespace character",
							"Any character that is not a vertical whitespace character",
							"Any \"word\" character",
							"Any \"non-word\" character"
						]
					},
					{
						"tag": [
							"\\d",
							"\\s",
							"\\w"
						],
						"item": [
							"Any character that \\p{Nd} matches (decimal digit)",
							"Any character that \\p{Z} or \\h or \\v",
							"Any character that matches \\p{L} or \\p{N} matches, plus underscore"
						]
					},
					{
						"tag": [
							"U+0009",
							"U+0020",
							"U+00A0",
							"U+1680",
							"U+180E",
							"U+2000",
							"U+2001",
							"U+2002",
							"U+2003",
							"U+2004",
							"U+2005",
							"U+2006",
							"U+2007",
							"U+2008",
							"U+2009",
							"U+200A",
							"U+202F",
							"U+205F",
							"U+3000"
						],
						"item": [
							"Horizontal tab (HT)",
							"Space",
							"Non-break space",
							"Ogham space mark",
							"Mongolian vowel separator",
							"En quad",
							"Em quad",
							"En space",
							"Em space",
							"Three-per-em space",
							"Four-per-em space",
							"Six-per-em space",
							"Figure space",
							"Punctuation space",
							"Thin space",
							"Hair space",
							"Narrow no-break space",
							"Medium mathematical space",
							"Ideographic space"
						]
					},
					{
						"tag": [
							"U+000A",
							"U+000B",
							"U+000C",
							"U+000D",
							"U+0085",
							"U+2028",
							"U+2029"
						],
						"item": [
							"Line feed (LF)",
							"Vertical tab (VT)",
							"Form feed (FF)",
							"Carriage return (CR)",
							"Next line (NEL)",
							"Line separator",
							"Paragraph separator"
						]
					},
					{
						"tag": [
							"(*BSR_ANYCRLF)",
							"(*BSR_UNICODE)"
						],
						"item": [
							"CR, LF, or CRLF only",
							"Any Unicode newline sequence"
						]
					},
					{
						"tag": [
							{
								"em": "xx"
							},
							{
								"em": "xx"
							},
							"\\X"
						],
						"item": [
							{
								"em": "xx"
							},
							{
								"em": "xx"
							},
							"A Unicode extended grapheme cluster"
						]
					},
					{
						"tag": [
							"C",
							"Cc",
							"Cf",
							"Cn",
							"Co",
							"Cs",
							"L",
							"Ll",
							"Lm",
							"Lo",
							"Lt",
							"Lu",
							"M",
							"Mc",
							"Me",
							"Mn",
							"N",
							"Nd",
							"Nl",
							"No",
							"P",
							"Pc",
							"Pd",
							"Pe",
							"Pf",
							"Pi",
							"Po",
							"Ps",
							"S",
							"Sc",
							"Sk",
							"Sm",
							"So",
							"Z",
							"Zl",
							"Zp",
							"Zs"
						],
						"item": [
							"Other",
							"Control",
							"Format",
							"Unassigned",
							"Private use",
							"Surrogate",
							"Letter",
							"Lowercase letter",
							"Modifier letter",
							"Other letter",
							"Title case letter",
							"Uppercase letter",
							"Mark",
							"Spacing mark",
							"Enclosing mark",
							"Non-spacing mark",
							"Number",
							"Decimal number",
							"Letter number",
							"Other number",
							"Punctuation",
							"Connector punctuation",
							"Dash punctuation",
							"Close punctuation",
							"Final punctuation",
							"Initial punctuation",
							"Other punctuation",
							"Open punctuation",
							"Symbol",
							"Currency symbol",
							"Modifier symbol",
							"Mathematical symbol",
							"Other symbol",
							"Separator",
							"Line separator",
							"Paragraph separator",
							"Space separator"
						]
					},
					{
						"tag": [
							"Xan",
							"Xps",
							"Xsp",
							"Xwd"
						],
						"item": [
							{
								"p": "Any alphanumeric character. Matches characters that have either the L (letter) or the N (number) property."
							},
							{
								"p": "Any Posix space character. Matches the characters tab, line feed, vertical tab, form feed, carriage return, and any other character that has the Z (separator) property."
							},
							{
								"p": "Any Perl space character. Matches the same as Xps, except that vertical tab is excluded."
							},
							{
								"p": "Any Perl \"word\" character. Matches the same characters as Xan, plus underscore."
							}
						]
					},
					{
						"tag": [
							"\\b",
							"\\B",
							"\\A",
							"\\Z",
							"\\z",
							"\\G"
						],
						"item": [
							"Matches at a word boundary.",
							"Matches when not at a word boundary.",
							"Matches at the start of the subject.",
							"Matches at the end of the subject, and before a newline at the end of the subject.",
							"Matches only at the end of the subject.",
							"Matches at the first matching position in the subject."
						]
					}
				],
				"note": {
					"p": "Note that \\0dd is always an octal code, and that \\8 and \\9 are the literal characters \"8\" and \"9\"."
				},
				"list": [
					{
						"type": "bulleted",
						"item": [
							"Arabic",
							"Armenian",
							"Avestan",
							"Balinese",
							"Bamum",
							"Bassa_Vah",
							"Batak",
							"Bengali",
							"Bopomofo",
							"Braille",
							"Buginese",
							"Buhid",
							"Canadian_Aboriginal",
							"Carian",
							"Caucasian_Albanian",
							"Chakma",
							"Cham",
							"Cherokee",
							"Common",
							"Coptic",
							"Cuneiform",
							"Cypriot",
							"Cyrillic",
							"Deseret",
							"Devanagari",
							"Duployan",
							"Egyptian_Hieroglyphs",
							"Elbasan",
							"Ethiopic",
							"Georgian",
							"Glagolitic",
							"Gothic",
							"Grantha",
							"Greek",
							"Gujarati",
							"Gurmukhi",
							"Han",
							"Hangul",
							"Hanunoo",
							"Hebrew",
							"Hiragana",
							"Imperial_Aramaic",
							"Inherited",
							"Inscriptional_Pahlavi",
							"Inscriptional_Parthian",
							"Javanese",
							"Kaithi",
							"Kannada",
							"Katakana",
							"Kayah_Li",
							"Kharoshthi",
							"Khmer",
							"Khojki",
							"Khudawadi",
							"Lao",
							"Latin",
							"Lepcha",
							"Limbu",
							"Linear_A",
							"Linear_B",
							"Lisu",
							"Lycian",
							"Lydian",
							"Mahajani",
							"Malayalam",
							"Mandaic",
							"Manichaean",
							"Meetei_Mayek",
							"Mende_Kikakui",
							"Meroitic_Cursive",
							"Meroitic_Hieroglyphs",
							"Miao",
							"Modi",
							"Mongolian",
							"Mro",
							"Myanmar",
							"Nabataean",
							"New_Tai_Lue",
							"Nko",
							"Ogham",
							"Ol_Chiki",
							"Old_Italic",
							"Old_North_Arabian",
							"Old_Permic",
							"Old_Persian",
							"Oriya",
							"Old_South_Arabian",
							"Old_Turkic",
							"Osmanya",
							"Pahawh_Hmong",
							"Palmyrene",
							"Pau_Cin_Hau",
							"Phags_Pa",
							"Phoenician",
							"Psalter_Pahlavi",
							"Rejang",
							"Runic",
							"Samaritan",
							"Saurashtra",
							"Sharada",
							"Shavian",
							"Siddham",
							"Sinhala",
							"Sora_Sompeng",
							"Sundanese",
							"Syloti_Nagri",
							"Syriac",
							"Tagalog",
							"Tagbanwa",
							"Tai_Le",
							"Tai_Tham",
							"Tai_Viet",
							"Takri",
							"Tamil",
							"Telugu",
							"Thaana",
							"Thai",
							"Tibetan",
							"Tifinagh",
							"Tirhuta",
							"Ugaritic",
							"Vai",
							"Warang_Citi",
							"Yi"
						]
					},
					{
						"type": "ordered",
						"item": [
							{
								"p": "End at the end of the subject string."
							},
							{
								"p": "Do not end between CR and LF; otherwise end after any control character."
							},
							{
								"p": "Do not break Hangul (a Korean script) syllable sequences. Hangul characters are of five types: L, V, T, LV, and LVT. An L character can be followed by an L, V, LV, or LVT character. An LV or V character can be followed by a V or T character. An LVT or T character can be followed only by a T character."
							},
							{
								"p": "Do not end before extending characters or spacing marks. Characters with the \"mark\" property always have the \"extend\" grapheme breaking property."
							},
							{
								"p": "Do not end after prepend characters."
							},
							{
								"p": "Otherwise, end the cluster."
							}
						]
					}
				]
			},
			{
				"marker": {
					"id": "sect4"
				},
				"title": "Circumflex and Dollar",
				"p": [
					"The circumflex and dollar metacharacters are zero-width assertions. That is, they test for a particular condition to be true without consuming any characters from the subject string.",
					{
						"c": [
							"startoffset",
							"multiline"
						],
						"seealso": {
							"marker": "#run/3",
							"c": "run/3"
						}
					},
					"Circumflex needs not to be the first character of the pattern if some alternatives are involved, but it is to be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an \"anchored\" pattern. (There are also other constructs that can cause a pattern to be anchored.)",
					"The dollar character is an assertion that is true only if the current matching point is at the end of the subject string, or immediately before a newline at the end of the string (by default). Notice however that it does not match the newline. Dollar needs not to be the last character of the pattern if some alternatives are involved, but it is to be the last item in any branch in which it appears. Dollar has no special meaning in a character class.",
					{
						"c": "dollar_endonly"
					},
					{
						"c": [
							"multiline",
							"multiline"
						]
					},
					{
						"em": "startoffset",
						"c": [
							"run/3",
							"dollar_endonly",
							"multiline"
						]
					},
					{
						"c": "multiline"
					}
				]
			},
			{
				"marker": {
					"id": "sect5"
				},
				"title": "Full Stop (Period, Dot) and \\N",
				"p": [
					"Outside a character class, a dot in the pattern matches any character in the subject string except (by default) a character that signifies the end of a line.",
					"When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters.",
					{
						"c": "dotall"
					},
					"The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship is that both involve newlines. Dot has no special meaning in a character class.",
					{
						"c": "PCRE_DOTALL"
					}
				]
			},
			{
				"marker": {
					"id": "sect6"
				},
				"title": "Matching a Single Data Unit",
				"p": [
					"Outside a character class, the escape sequence \C matches any data unit, regardless if a UTF mode is set. One data unit is one byte. Unlike a dot, \C always matches line-ending characters. The feature is provided in Perl to match individual bytes in UTF-8 mode, but it is unclear how it can usefully be used. As \C breaks up characters into individual data units, matching one unit with \C in a UTF mode means that the remaining string can start with a malformed UTF character. This has undefined results, as PCRE assumes that it deals with valid UTF strings.",
					"PCRE does not allow \C to appear in lookbehind assertions (described below) in a UTF mode, as this would make it impossible to calculate the length of the lookbehind.",
					"The \\C escape sequence is best avoided. However, one way of using it that avoids the problem of malformed UTF characters is to use a lookahead to check the length of the next character, as in the following pattern, which can be used with a UTF-8 string (ignore whitespace and line breaks):",
					{
						"seealso": {
							"marker": "#sect12",
							"$t": "Duplicate Subpattern Numbers"
						}
					}
				],
				"code": {
					"type": "none",
					"$t": "(?| (?=[\\x00-\\x7f])(\\C) | (?=[\\x80-\\x{7ff}])(\\C)(\\C) | (?=[\\x{800}-\\x{ffff}])(\\C)(\\C)(\\C) | (?=[\\x{10000}-\\x{1fffff}])(\\C)(\\C)(\\C)(\\C))"
				}
			},
			{
				"marker": {
					"id": "sect7"
				},
				"title": "Square Brackets and Character Classes",
				"p": [
					{
						"c": "PCRE_JAVASCRIPT_COMPAT"
					},
					"A character class matches a single character in the subject. In a UTF mode, the character can be more than one data unit long. A matched character must be in the set of characters defined by the class, unless the first character in the class definition is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is required as a member of the class, ensure that it is not the first character, or escape it with a backslash.",
					{
						"c": [
							"[aeiou]",
							"[^aeiou]"
						]
					},
					"In UTF-8 mode, characters with values > 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.",
					{
						"c": [
							"[aeiou]",
							"[^aeiou]"
						]
					},
					{
						"c": [
							"PCRE_DOTALL",
							"PCRE_MULTILINE"
						]
					},
					"The minus (hyphen) character can be used to specify a range of characters in a character class. For example, [d-m] matches any letter between d and m, inclusive. If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class, or immediately after a range. For example, [b-d-z] matches letters in the range b to d, a hyphen character, or z.",
					"The literal character \"]\" cannot be the end character of a range. A pattern such as [W-]46] is interpreted as a class of two characters (\"W\" and \"-\") followed by a literal string \"46]\", so it would match \"W46]\" or \"-46]\". However, if \"]\" is escaped with a backslash, it is interpreted as the end of range, so [W-\]46] is interpreted as a class containing a range followed by two other characters. The octal or hexadecimal representation of \"]\" can also be used to end a range.",
					"An error is generated if a POSIX character class (see below) or an escape sequence other than one that defines a single character appears at a point where a range ending character is expected. For example, [z-\xff] is valid, but [A-\d] and [A-[:digit:]] are not.",
					"Ranges operate in the collating sequence of character values. They can also be used for characters specified numerically, for example, [\000-\037]. Ranges can include any characters that are valid for the current mode.",
					"If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values > 255 only when it is compiled with Unicode property support.",
					{
						"c": "ucp",
						"seealso": {
							"marker": "#generic_character_types",
							"$t": "Generic Character Types"
						}
					},
					"A circumflex can conveniently be used with the uppercase character types to specify a more restricted set of characters than the matching lowercase type. For example, class [^\\W_] matches any letter or digit, but not underscore, while [\\w] includes underscore. A positive character class is to be read as \"something OR something OR ...\" and a negative class as \"NOT something AND NOT something AND NOT ...\".",
					"Only the following metacharacters are recognized in character classes:",
					"However, escaping other non-alphanumeric characters does no harm."
				],
				"list": {
					"type": "bulleted",
					"item": [
						"Backslash",
						"Hyphen (only where it can be interpreted as specifying a range)",
						"Circumflex (only at the start)",
						"Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)",
						"Terminating closing square bracket"
					]
				}
			},
			{
				"marker": {
					"id": "sect8"
				},
				"title": "Posix Character Classes",
				"p": [
					"Perl supports the Posix notation for character classes. This uses names enclosed by [: and :] within the enclosing square brackets. PCRE also supports this notation. For example, the following matches \"0\", \"1\", any alphabetic character, or \"%\":",
					"The following are the supported class names:",
					"The default \"space\" characters are HT (9), LF (10), VT (11), FF (12), CR (13), and space (32). If locale-specific matching is taking place, the list of space characters may be different; there may be fewer or more of them. \"Space\" used to be different to \s, which did not include VT, for Perl compatibility. However, Perl changed at release 5.18, and PCRE followed at release 8.34. \"Space\" and \s now match the same set of characters.",
					"The name \"word\" is a Perl extension, and \"blank\" is a GNU extension from Perl 5.8. Another Perl extension is negation, which is indicated by a ^ character after the colon. For example, the following matches \"1\", \"2\", or any non-digit:",
					"PCRE (and Perl) also recognize the Posix syntax [.ch.] and [=ch=] where \"ch\" is a \"collating element\", but these are not supported, and an error is given if they are encountered.",
					{
						"c": [
							"PCRE_UCP",
							"pcre_compile()"
						]
					},
					"Negated versions, such as [:^alpha:], use \P instead of \p. Three other POSIX classes are handled specially in UCP mode:",
					"The other POSIX classes are unchanged, and match only characters with code points less than 128.",
					{
						"em": "Compatibility Feature for Word Boundaries"
					},
					"In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:<:]] and [[:>:]] is used for matching \"start of word\" and \"end of word\". PCRE treats these items as follows:",
					"Only these exact character sequences are recognized. A sequence such as [a[:<:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see \"Simple assertions\" above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour."
				],
				"code": [
					"[01[:alpha:]%]",
					"[12[:^digit:]]"
				],
				"taglist": [
					{
						"tag": [
							"alnum",
							"alpha",
							"ascii",
							"blank",
							"cntrl",
							"digit",
							"graph",
							"lower",
							"print",
							"punct",
							"space",
							"upper",
							"word",
							"xdigit"
						],
						"item": [
							"Letters and digits",
							"Letters",
							"Character codes 0-127",
							"Space or tab only",
							"Control characters",
							"Decimal digits (same as \\d)",
							"Printing characters, excluding space",
							"Lowercase letters",
							"Printing characters, including space",
							"Printing characters, excluding letters, digits, and space",
							"Whitespace (the same as \\s from PCRE 8.34)",
							"Uppercase letters",
							"\"Word\" characters (same as \\w)",
							"Hexadecimal digits"
						]
					},
					{
						"tag": [
							"[:alnum:]",
							"[:alpha:]",
							"[:blank:]",
							"[:digit:]",
							"[:lower:]",
							"[:space:]",
							"[:upper:]",
							"[:word:]"
						],
						"item": [
							{
								"em": "\\p{Xan}"
							},
							{
								"em": "\\p{L}"
							},
							{
								"em": "\\h"
							},
							{
								"em": "\\p{Nd}"
							},
							{
								"em": "\\p{Ll}"
							},
							{
								"em": "\\p{Xps}"
							},
							{
								"em": "\\p{Lu}"
							},
							{
								"em": "\\p{Xwd}"
							}
						]
					},
					{
						"tag": [
							"[:graph:]",
							"[:print:]",
							"[:punct:]"
						],
						"item": [
							{
								"p": "This matches characters that have glyphs that mark the page when printed. In Unicode property terms, it matches all characters with the L, M, N, P, S, or Cf properties, except for:",
								"taglist": {
									"tag": [
										"U+061C",
										"U+180E",
										"U+2066 - U+2069"
									],
									"item": [
										{
											"p": "Arabic Letter Mark"
										},
										{
											"p": "Mongolian Vowel Separator"
										},
										{
											"p": "Various \"isolate\"s"
										}
									]
								}
							},
							{
								"p": "This matches the same characters as [:graph:] plus space characters that are not controls, that is, characters with the Zs property."
							},
							{
								"p": "This matches all characters that have the Unicode P (punctuation) property, plus those characters whose code points are less than 128 that have the S (Symbol) property."
							}
						]
					},
					{
						"tag": [
							"[[:<:]]",
							"[[:>:]]"
						],
						"item": [
							{
								"p": "is converted to \\b(?=\\w)"
							},
							{
								"p": "is converted to \\b(?<=\\w)"
							}
						]
					}
				]
			},
			{
				"marker": {
					"id": "sect9"
				},
				"title": "Vertical Bar",
				"p": [
					"Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either \"gilbert\" or \"sullivan\":",
					{
						"seealso": {
							"marker": "#sect11",
							"$t": "Subpatterns"
						}
					}
				],
				"code": "gilbert|sullivan"
			},
			{
				"marker": {
					"id": "sect10"
				},
				"title": "Internal Option Setting",
				"p": [
					{
						"c": [
							"caseless",
							"multiline",
							"dotall",
							"extended"
						]
					},
					{
						"c": [
							"(?im)",
							"(?im-sx)",
							"caseless",
							"multiline",
							"dotall",
							"extended"
						]
					},
					{
						"c": [
							"dupnames",
							"ungreedy",
							"extra"
						]
					},
					"When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows.",
					{
						"seealso": {
							"marker": "#sect11",
							"$t": "Subpatterns"
						},
						"c": "caseless"
					},
					"By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:",
					"matches \"ab\", \"aB\", \"c\", and \"C\", although when matching \"C\" the first branch is abandoned before the option setting. This is because the effects of option settings occur at compile time. There would be some weird behavior otherwise."
				],
				"taglist": {
					"tag": [
						"i",
						"m",
						"s",
						"x"
					],
					"item": [
						{
							"c": "caseless"
						},
						{
							"c": "multiline"
						},
						{
							"c": "dotall"
						},
						{
							"c": "extended"
						}
					]
				},
				"code": [
					"(a(?i)b)c",
					"(a(?i)b|c)"
				],
				"note": {
					"p": [
						{
							"seealso": {
								"marker": "#newline_sequences",
								"$t": "Newline Sequences"
							}
						},
						{
							"c": [
								"unicode",
								"ucp",
								"never_utf"
							]
						}
					]
				}
			},
			{
				"marker": {
					"id": "sect11"
				},
				"title": "Subpatterns",
				"p": [
					"Subpatterns are delimited by parentheses (round brackets), which can be nested. Turning part of a pattern into a subpattern does two things:",
					"Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string \"the red king\" is matched against the following pattern, the captured substrings are \"red king\", \"red\", and \"king\", and are numbered 1, 2, and 3, respectively:",
					"It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string \"the white queen\" is matched against the following pattern, the captured substrings are \"white queen\" and \"queen\", and are numbered 1 and 2:",
					"The maximum number of capturing subpatterns is 65535.",
					"As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between \"?\" and \":\". Thus, the following two patterns match the same set of strings:",
					"As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both \"SUNDAY\" and \"Saturday\"."
				],
				"taglist": {
					"tag": [
						"1.",
						"2."
					],
					"item": [
						{
							"p": [
								"It localizes a set of alternatives. For example, the following pattern matches \"cataract\", \"caterpillar\", or \"cat\":",
								"Without the parentheses, it would match \"cataract\", \"erpillar\", or an empty string."
							],
							"code": "cat(aract|erpillar|)"
						},
						{
							"p": {
								"seealso": {
									"marker": "#run/3",
									"c": "run/3"
								}
							}
						}
					]
				},
				"code": [
					"the ((red|white) (king|queen))",
					"the ((?:red|white) (king|queen))",
					"(?i:saturday|sunday)(?:(?i)saturday|sunday)"
				]
			},
			{
				"marker": {
					"id": "sect12"
				},
				"title": "Duplicate Subpattern Numbers",
				"p": [
					{
						"c": "(?|"
					},
					{
						"c": [
							"(?|",
							"(?|"
						]
					},
					"A back reference to a numbered subpattern uses the most recent value that is set for that number by any subpattern. The following pattern matches \"abcabc\" or \"defdef\":",
					"In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches \"abcabc\" or \"defabc\":",
					"If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.",
					"An alternative approach using this \"branch reset\" feature is to use duplicate named subpatterns, as described in the next section."
				],
				"code": [
					"(?|(Sat)ur|(Sun))day",
					{
						"type": "none",
						"$t": "# before ---------------branch-reset----------- after/ ( a ) (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x# 1 2 2 3 2 3 4"
					},
					"/(?|(abc)|(def))\\1/",
					"/(?|(abc)|(def))(?1)/"
				]
			},
			{
				"marker": {
					"id": "sect13"
				},
				"title": "Named Subpatterns",
				"p": [
					"Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.",
					{
						"c": [
							"(?<name>...)",
							"(?'name'...)",
							"(?P<name>...)"
						]
					},
					{
						"c": "capture",
						"seealso": {
							"marker": "#run/3",
							"c": "run/3"
						}
					},
					{
						"c": "dupnames"
					},
					"There are five capturing substrings, but only one is ever set after a match. (An alternative way of solving this problem is to use a \"branch reset\" subpattern, as described in the previous section.)",
					{
						"seealso": {
							"marker": "#run/3",
							"c": "run/3"
						},
						"c": [
							"values",
							"capture",
							"all_names"
						]
					}
				],
				"code": {
					"type": "none",
					"$t": "(?<DN>Mon|Fri|Sun)(?:day)?|(?<DN>Tue)(?:sday)?|(?<DN>Wed)(?:nesday)?|(?<DN>Thu)(?:rsday)?|(?<DN>Sat)(?:urday)?"
				},
				"note": {
					"p": {
						"c": "dupnames"
					}
				}
			},
			{
				"marker": {
					"id": "sect14"
				},
				"title": "Repetition",
				"p": [
					"Repetition is specified by quantifiers, which can follow any of the following items:",
					"The general repetition quantifier specifies a minimum and maximum number of permitted matches, by giving the two numbers in curly brackets (braces), separated by a comma. The numbers must be < 65536, and the first must be less than or equal to the second. For example, the following matches \"zz\", \"zzz\", or \"zzzz\":",
					"A closing brace on its own is not a special character. If the second number is omitted, but the comma is present, there is no upper limit. If the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus, the following matches at least three successive vowels, but can match many more:",
					"The following matches exactly eight digits:",
					"An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal string of four characters.",
					"In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \\x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \\X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).",
					{
						"seealso": {
							"marker": "#defining_subpatterns",
							"$t": "Defining Subpatterns for Use by Reference Only"
						}
					},
					"For convenience, the three most common quantifiers have single-character abbreviations:",
					"Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:",
					"Earlier versions of Perl and PCRE used to give an error at compile time for such patterns. However, as there are cases where this can be useful, such patterns are now accepted. However, if any repetition of the subpattern matches no characters, the loop is forcibly broken.",
					"By default, the quantifiers are \"greedy\", that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern",
					"to the string",
					"fails, as it matches the entire string owing to the greediness of the .* item.",
					"However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:",
					"The meaning of the various quantifiers is not otherwise changed, only the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. As it has two uses, it can sometimes appear doubled, as in",
					"which matches one digit by preference, but can match two if that is the only way the remaining pattern matches.",
					{
						"c": "ungreedy"
					},
					"When a parenthesized subpattern is quantified with a minimum repeat count that is > 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum.",
					{
						"c": [
							"dotall",
							"/s"
						]
					},
					{
						"c": "dotall"
					},
					"However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:",
					"If the subject is \"xyz123abc123\", the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.",
					"Another case where implicit anchoring is not applied is when the leading .* is inside an atomic group. Once again, a match at the start can fail where a later one succeeds. Consider the following pattern:",
					"It matches \"ab\" in the subject \"aab\". The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.",
					"When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after",
					"has matched \"tweedledum tweedledee\", the value of the captured substring is \"tweedledee\". However, if there are nested capturing subpatterns, the corresponding captured values can have been set in previous iterations. For example, after",
					"matches \"aba\", the value of the second captured substring is \"b\"."
				],
				"list": {
					"type": "bulleted",
					"item": [
						"A literal data character",
						"The dot metacharacter",
						"The \\C escape sequence",
						"The \\X escape sequence",
						"The R escape sequence",
						"An escape such as \\d or \\pL that matches a single character",
						"A character class",
						"A back reference (see the next section)",
						"A parenthesized subpattern (including assertions)",
						"A subroutine call to a subpattern (recursive or otherwise)"
					]
				},
				"code": [
					"z{2,4}",
					"[aeiou]{3,}",
					"\\d{8}",
					"(a?)*",
					"/\\*.*\\*/",
					"/* first comment */ not comment /* second comment */",
					"/\\*.*?\\*/",
					"\\d??\\d",
					"(.*)abc\\1",
					"(?>.*?a)b",
					"(tweedle[dume]{3}\\s*)+",
					"/(a|(b))+/"
				],
				"taglist": {
					"tag": [
						"*",
						"+",
						"?"
					],
					"item": [
						"Equivalent to {0,}",
						"Equivalent to {1,}",
						"Equivalent to {0,1}"
					]
				}
			},
			{
				"marker": {
					"id": "sect15"
				},
				"title": "Atomic Grouping and Possessive Quantifiers",
				"p": [
					"With both maximizing (\"greedy\") and minimizing (\"ungreedy\" or \"lazy\") repetition, failure of what follows normally causes the repeated item to be re-evaluated to see if a different number of repeats allows the remaining pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it to fail earlier than it otherwise might, when the author of the pattern knows that there is no point in carrying on.",
					"Consider, for example, the pattern \d+foo when applied to the following subject line:",
					"After matching all six digits and then failing to match \"foo\", the normal action of the matcher is to try again with only five digits matching item \d+, and then with four, and so on, before ultimately failing. \"Atomic grouping\" (a term taken from Jeffrey Friedl's book) provides the means for specifying that once a subpattern has matched, it is not to be re-evaluated in this way.",
					{
						"c": "(?>"
					},
					"This kind of parenthesis \"locks up\" the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.",
					"An alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match, if anchored at the current point in the subject string.",
					{
						"c": "(?>\\d+)"
					},
					"Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a \"possessive quantifier\" can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as",
					"Notice that a possessive quantifier can be used with an entire group, for example:",
					{
						"c": "ungreedy"
					},
					"The possessive quantifier syntax is an extension to the Perl 5.8 syntax. Jeffrey Friedl originated the idea (and the name) in the first edition of his book. Mike McCloskey liked it, so implemented it when he built the Sun Java package, and PCRE copied it from there. It ultimately found its way into Perl at release 5.10.",
					"PCRE has an optimization that automatically \"possessifies\" certain simple pattern constructs. For example, the sequence A+B is treated as A++B, as there is no point in backtracking into a sequence of A:s when B must follow.",
					"When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern",
					"matches an unlimited number of substrings that either consist of non-digits, or digits enclosed in <>, followed by ! or ?. When it matches, it runs quickly. However, if it is applied to",
					"it takes a long time before reporting failure. This is because the string can be divided between the internal \D+ repeat and the external * repeat in many ways, and all must be tried. (The example uses [!?] rather than a single character at the end, as both PCRE and Perl have an optimization that allows for fast failure when a single character is used. They remember the last single character that is required for a match, and fail early if it is not present in the string.) If the pattern is changed so that it uses an atomic group, like the following, sequences of non-digits cannot be broken, and failure happens quickly:"
				],
				"code": [
					"123456bar",
					"(?>\\d+)foo",
					"\\d++foo",
					"(abc|xyz){2,3}+",
					"(\\D+|<\\d+>)*[!?]",
					"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
					"((?>\\D+)|<\\d+>)*[!?]"
				]
			},
			{
				"marker": {
					"id": "sect16"
				},
				"title": "Back References",
				"p": [
					"Outside a character class, a backslash followed by a digit > 0 (and possibly further digits) is a back reference to a capturing subpattern earlier (that is, to its left) in the pattern, provided there have been that many previous capturing left parentheses.",
					"However, if the decimal number following the backslash is < 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers < 10. A \"forward back reference\" of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.",
					{
						"seealso": {
							"marker": "#non_printing_characters",
							"$t": "Non-Printing Characters"
						}
					},
					"Another way to avoid the ambiguity inherent in the use of digits following a backslash is to use the \g escape sequence. This escape must be followed by an unsigned number or a negative number, optionally enclosed in braces. The following examples are identical:",
					"An unsigned number specifies an absolute reference without the ambiguity that is present in the older syntax. It is also useful when literal digits follow the reference. A negative number is a relative reference. Consider the following example:",
					"The sequence \g{-1} is a reference to the most recently started capturing subpattern before \g, that is, it is equivalent to \2 in this example. Similarly, \g{-2} would be equivalent to \1. The use of relative references can be helpful in long patterns, and also in patterns that are created by joining fragments containing references within themselves.",
					{
						"seealso": {
							"marker": "#sect21",
							"$t": "Subpattern as Subroutines"
						}
					},
					"If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches \"rah rah\" and \"RAH RAH\", but not \"RAH rah\", although the original capturing subpattern is matched caselessly:",
					{
						"c": [
							"\\k{name}",
							"\\k<name>",
							"\\k'name'",
							"(?P=name)"
						]
					},
					"A subpattern that is referenced by name can appear in the pattern before or after the reference.",
					"There can be more than one back reference to the same subpattern. If a subpattern has not been used in a particular match, any back references to it always fails. For example, the following pattern always fails if it starts to match \"a\" rather than \"bc\":",
					{
						"c": "extended",
						"seealso": {
							"marker": "#sect19",
							"$t": "Comments"
						}
					},
					{
						"em": "Recursive Back References"
					},
					"A back reference that occurs inside the parentheses to which it refers fails when the subpattern is first used, so, for example, (a\1) never matches. However, such references can be useful inside repeated subpatterns. For example, the following pattern matches any number of \"a\"s and also \"aba\", \"ababbaa\", and so on:",
					"At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.",
					"Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group."
				],
				"code": [
					"(ring), \\1(ring), \\g1(ring), \\g{1}",
					"(abc(def)ghi)\\g{-1}",
					"(sens|respons)e and \\1ibility",
					"((?i)rah)\\s+\\1",
					"(?<p1>(?i)rah)\\s+\\k<p1>(?'p1'(?i)rah)\\s+\\k{p1}(?P<p1>(?i)rah)\\s+(?P=p1)(?<p1>(?i)rah)\\s+\\g{p1}",
					"(a|(bc))\\2",
					"(a|b\\1)+"
				]
			},
			{
				"marker": {
					"id": "sect17"
				},
				"title": "Assertions",
				"p": [
					"An assertion is a test on the characters following or preceding the current matching point that does not consume any characters. The simple assertions coded as \b, \B, \A, \G, \Z, \z, ^, and $ are described in the previous sections.",
					"More complicated assertions are coded as subpatterns. There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it. An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed.",
					"Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)",
					"For compatibility with Perl, assertion subpatterns can be repeated. However, it makes no sense to assert the same thing many times, the side effect of capturing parentheses can occasionally be useful. In practice, there are only three cases:",
					{
						"em": "Lookahead Assertions"
					},
					"Lookahead assertions start with (?= for positive assertions and (?! for negative assertions. For example, the following matches a word followed by a semicolon, but does not include the semicolon in the match:",
					"The following matches any occurrence of \"foo\" that is not followed by \"bar\":",
					"Notice that the apparently similar pattern",
					"does not find an occurrence of \"bar\" that is preceded by something other than \"foo\". It finds any occurrence of \"bar\" whatsoever, as the assertion (?!foo) is always true when the next three characters are \"bar\". A lookbehind assertion is needed to achieve the other effect.",
					"If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).",
					{
						"em": "Lookbehind Assertions"
					},
					"Lookbehind assertions start with (?<= for positive assertions and (?<! for negative assertions. For example, the following finds an occurrence of \"bar\" that is not preceded by \"foo\":",
					"The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are many top-level alternatives, they do not all have to have the same fixed length. Thus, the following is permitted:",
					"The following causes an error at compile time:",
					"Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:",
					"However, it is acceptable to PCRE if rewritten to use two top-level branches:",
					"Sometimes the escape sequence \K (see above) can be used instead of a lookbehind assertion to get round the fixed-length restriction.",
					"The implementation of lookbehind assertions is, for each alternative, to move the current position back temporarily by the fixed length and then try to match. If there are insufficient characters before the current position, the assertion fails.",
					"In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and R escapes, which can match different numbers of data units, are not permitted either.",
					"\"Subroutine\" calls (see below), such as (?2) or (?&X), are permitted in lookbehinds, as long as the subpattern matches a fixed-length string. Recursion, however, is not supported.",
					"Possessive quantifiers can be used with lookbehind assertions to specify efficient matching of fixed-length strings at the end of subject strings. Consider the following simple pattern when applied to a long string that does not match:",
					"As matching proceeds from left to right, PCRE looks for each \"a\" in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as",
					"the initial .* matches the entire string at first. However, when this fails (as there is no following \"a\"), it backtracks to match all but the last character, then all but the last two characters, and so on. Once again the search for \"a\" covers the entire string, from right to left, so we are no better off. However, if the pattern is written as",
					"there can be no backtracking for the .*+ item; it can match only the entire string. The subsequent lookbehind assertion does a single test on the last four characters. If it fails, the match fails immediately. For long strings, this approach makes a significant difference to the processing time.",
					{
						"em": "Using Multiple Assertions"
					},
					"Many assertions (of any sort) can occur in succession. For example, the following matches \"foo\" preceded by three digits that are not \"999\":",
					{
						"em": "not"
					},
					"This time the first assertion looks at the preceding six characters, checks that the first three are digits, and then the second assertion checks that the preceding three characters are not \"999\".",
					"Assertions can be nested in any combination. For example, the following matches an occurrence of \"baz\" that is preceded by \"bar\", which in turn is not preceded by \"foo\":",
					"The following pattern matches \"foo\" preceded by three digits and any three characters that are not \"999\":"
				],
				"warning": {
					"p": "If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change."
				},
				"list": {
					"type": "bulleted",
					"item": [
						{
							"p": "If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism."
						},
						{
							"p": "If quantifier is {0,n}, where n > 0, it is treated as if it was {0,1}. At runtime, the remaining pattern match is tried with and without the assertion, the order depends on the greediness of the quantifier."
						},
						{
							"p": "If the minimum repetition is > 0, the quantifier is ignored. The assertion is obeyed only once when encountered during matching."
						}
					]
				},
				"code": [
					"\\w+(?=;)",
					"foo(?!bar)",
					"(?!foo)bar",
					"(?<!foo)bar",
					"(?<=bullock|donkey)",
					"(?<!dogs?|cats?)",
					"(?<=ab(c|de))",
					"(?<=abc|abde)",
					"abcd$",
					"^.*abcd$",
					"^.*+(?<=abcd)",
					"(?<=\\d{3})(?<!999)foo",
					"(?<=\\d{3}...)(?<!999)foo",
					"(?<=(?<!foo)bar)baz",
					"(?<=\\d{3}(?!999)...)foo"
				]
			},
			{
				"marker": [
					{
						"id": "sect18"
					},
					{
						"id": "defining_subpatterns"
					}
				],
				"title": "Conditional Subpatterns",
				"p": [
					"It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:",
					"If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern (if present). If more than two alternatives exist in the subpattern, a compile-time error occurs. Each of the two alternatives can itself contain nested subpatterns of any form, including conditional subpatterns; the restriction to two alternatives applies only at the level of the condition. The following pattern fragment is an example where the alternatives are complex:",
					"There are four kinds of condition: references to subpatterns, references to recursion, a pseudo-condition called DEFINE, and assertions.",
					{
						"em": "Checking for a Used Subpattern By Number"
					},
					{
						"seealso": {
							"marker": "#sect12",
							"$t": "Duplicate Subpattern Numbers"
						}
					},
					{
						"c": "extended"
					},
					"The first part matches an optional opening parenthesis, and if that character is present, sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did, that is, if subject started with an opening parenthesis, the condition is true, and so the yes-pattern is executed and a closing parenthesis is required. Otherwise, as no-pattern is not present, the subpattern matches nothing. That is, this pattern matches a sequence of non-parentheses, optionally enclosed in parentheses.",
					"If this pattern is embedded in a larger one, a relative reference can be used:",
					"This makes the fragment independent of the parentheses in the larger pattern.",
					{
						"em": "Checking for a Used Subpattern By Name"
					},
					"Perl uses the syntax (?(<name>)...) or (?('name')...) to test for a used subpattern by name. For compatibility with earlier versions of PCRE, which had this facility before Perl, the syntax (?(name)...) is also recognized.",
					"Rewriting the previous example to use a named subpattern gives:",
					"If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them has matched.",
					{
						"em": "Checking for Pattern Recursion"
					},
					"If the condition is the string (R), and there is no subpattern with the name R, the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R, for example:",
					"the condition is true if the most recent recursion is into a subpattern whose number or name is given. This condition does not check the entire recursion stack. If the name used in a condition of this kind is a duplicate, the test is applied to all subpatterns of the same name, and is true if any one of them is the most recent recursion.",
					"At \"top-level\", all these recursion test conditions are false. The syntax for recursive patterns is described below.",
					{
						"em": "Defining Subpatterns for Use By Reference Only"
					},
					"If the condition is the string (DEFINE), and there is no subpattern with the name DEFINE, the condition is always false. In this case, there can be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern. The idea of DEFINE is that it can be used to define \"subroutines\" that can be referenced from elsewhere. (The use of subroutines is described below.) For example, a pattern to match an IPv4 address, such as \"192.168.23.245\", can be written like this (ignore whitespace and line breaks):",
					"The first part of the pattern is a DEFINE group inside which is a another group named \"byte\" is defined. This matches an individual component of an IPv4 address (a number < 256). When matching takes place, this part of the pattern is skipped, as DEFINE acts like a false condition. The remaining pattern uses references to the named group to match the four dot-separated components of an IPv4 address, insisting on a word boundary at each end.",
					{
						"em": "Assertion Conditions"
					},
					"If the condition is not in any of the above formats, it must be an assertion. This can be a positive or negative lookahead or lookbehind assertion. Consider the following pattern, containing non-significant whitespace, and with the two alternatives on the second line:",
					"The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. That is, it tests for the presence of at least one letter in the subject. If a letter is found, the subject is matched against the first alternative, otherwise it is matched against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits."
				],
				"code": [
					"(?(condition)yes-pattern)(?(condition)yes-pattern|no-pattern)",
					"(?(1) (A|B|C) | (D | (?(2)E|F) | E) )",
					"( \\( )? [^()]+ (?(1) \\) )",
					"...other stuff... ( \\( )? [^()]+ (?(-1) \\) ) ...",
					"(?<OPEN> \\( )? [^()]+ (?(<OPEN>) \\) )",
					"(?(R3)...) or (?(R&name)...)",
					"(?(DEFINE) (?<byte> 2[0-4]\\d | 25[0-5] | 1\\d\\d | [1-9]?\\d) ) \\b (?&byte) (\\.(?&byte)){3} \\b",
					{
						"type": "none",
						"$t": "(?(?=[^a-z]*[a-z])\\d{2}-[a-z]{3}-\\d{2} | \\d{2}-\\d{2}-\\d{2} )"
					}
				]
			},
			{
				"marker": {
					"id": "sect19"
				},
				"title": "Comments",
				"p": [
					"There are two ways to include comments in patterns that are processed by PCRE. In both cases, the start of the comment must not be in a character class, or in the middle of any other sequence of related characters such as (?: or a subpattern name or number. The characters that make up a comment play no part in the pattern matching.",
					{
						"seealso": {
							"marker": "#newline_conventions",
							"$t": "Newline Conventions"
						}
					},
					{
						"c": "extended"
					},
					{
						"c": "pcre_compile()"
					}
				],
				"code": "abc #comment \\n still comment"
			},
			{
				"marker": {
					"id": "sect20"
				},
				"title": "Recursive Patterns",
				"p": [
					"Consider the problem of matching a string in parentheses, allowing for unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth.",
					"For some time, Perl has provided a facility that allows regular expressions to recurse (among other things). It does this by interpolating Perl code in the expression at runtime, and the code can refer to the expression itself. A Perl pattern using code interpolation to solve the parentheses problem can be created like this:",
					"Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.",
					"Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.",
					"A special item that consists of (? followed by a number > 0 and a closing parenthesis is a recursive subroutine call of the subpattern of the given number, if it occurs inside that subpattern. (If not, it is a non-recursive subroutine call, which is described in the next section.) The special item (?R) or (?0) is a recursive call of the entire regular expression.",
					{
						"c": "extended"
					},
					"First it matches an opening parenthesis. Then it matches any number of substrings, which can either be a sequence of non-parentheses or a recursive match of the pattern itself (that is, a correctly parenthesized substring). Finally there is a closing parenthesis. Notice the use of a possessive quantifier to avoid backtracking into sequences of non-parentheses.",
					"If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:",
					"The pattern is here within parentheses so that the recursion refers to them instead of the whole pattern.",
					"In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.",
					"It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.",
					"An alternative approach is to use named parentheses instead. The Perl syntax for this is (?&name). The earlier PCRE syntax (?P>name) is also supported. We can rewrite the above example as follows:",
					"If there is more than one subpattern with the same name, the earliest one is used.",
					"This particular example pattern that we have studied contains nested unlimited repeats, and so the use of a possessive quantifier for matching strings of non-parentheses is important when applying the pattern to strings that do not match. For example, when this pattern is applied to",
					"it gives \"no match\" quickly. However, if a possessive quantifier is not used, the match runs for a long time, as there are so many different ways the + and * repeats can carve up the subject, and all must be tested before failure can be reported.",
					"At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against",
					"the value for the inner capturing parentheses (numbered 2) is \"ef\", which is the last value taken on at the top-level. If a capturing subpattern is not matched at the top level, its final captured value is unset, even if it was (temporarily) set at a deeper level during the matching process.",
					"Do not confuse item (?R) with condition (R), which tests for recursion. Consider the following pattern, which matches text in angle brackets, allowing for arbitrary nesting. Only digits are allowed in nested brackets (that is, when recursing), while any characters are permitted at the outer level.",
					"Here (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. Item (?R) is the actual recursive call.",
					{
						"em": "Differences in Recursion Processing between PCRE and Perl"
					},
					"Recursion processing in PCRE differs from Perl in two important ways. In PCRE (like Python, but unlike Perl), a recursive subpattern call is always treated as an atomic group. That is, once it has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. This can be illustrated by the following pattern, which means to match a palindromic string containing an odd number of characters (for example, \"a\", \"aba\", \"abcba\", \"abcdcba\"):",
					"The idea is that it either matches a single character, or two identical characters surrounding a subpalindrome. In Perl, this pattern works; in PCRE it does not work if the pattern is longer than three characters. Consider the subject string \"abcba\".",
					"At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (\"b\"). (Notice that the beginning and end of line tests are not part of the recursion.)",
					"Back at the top level, the next character (\"c\") is compared with what subpattern 2 matched, which was \"a\". This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:",
					"This time, the recursing alternative is tried first, and continues to recurse until it runs out of characters, at which point the recursion fails. But this time we have another alternative to try at the higher level. That is the significant difference: in the previous case the remaining alternative is at a deeper recursion level, which PCRE cannot use.",
					"To change the pattern so that it matches all palindromic strings, not only those with an odd number of characters, it is tempting to change the pattern to this:",
					"Again, this works in Perl, but not in PCRE, and for the same reason. When a deeper recursion has matched a single character, it cannot be entered again to match an empty string. The solution is to separate the two cases, and write out the odd and even cases as alternatives at the higher level:",
					"If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:",
					{
						"c": "caseless"
					},
					"The second way in which PCRE and Perl differ in their recursion processing is in the handling of captured values. In Perl, when a subpattern is called recursively or as a subpattern (see the next section), it has no access to any values that were captured outside the recursion. In PCRE these values can be referenced. Consider the following pattern:",
					"In PCRE, it matches \"bab\". The first capturing parentheses match \"b\", then in the second group, when the back reference \1 fails to match \"b\", the second alternative matches \"a\", and then recurses. In the recursion, \1 does now match \"b\" and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value."
				],
				"code": [
					"$re = qr{\\( (?: (?>[^()]+) | (?p{$re}) )* \\)}x;",
					"\\( ( [^()]++ | (?R) )* \\)",
					"( \\( ( [^()]++ | (?1) )* \\) )",
					"(?<pn> \\( ( [^()]++ | (?&pn) )* \\) )",
					"(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()",
					"(ab(cd)ef)",
					"< (?: (?(R) \\d++ | [^<>]*+) | (?R)) * >",
					"^(.|(.)(?1)\\2)$",
					"^((.)(?1)\\2|.)$",
					"^((.)(?1)\\2|.?)$",
					"^(?:((.)(?1)\\2|)|((.)(?3)\\4|.))",
					"^\\W*+(?:((.)\\W*+(?1)\\W*+\\2|)|((.)\\W*+(?3)\\W*+\\4|\\W*+.\\W*+))\\W*+$",
					"^(.)(\\1|a(?2))"
				],
				"note": {
					"p": "The palindrome-matching patterns above work only if the subject string does not start with a palindrome that is shorter than the entire string. For example, although \"abcba\" is correctly matched, if the subject is \"ababa\", PCRE finds palindrome \"aba\" at the start, and then fails at top level, as the end of the string does not follow. Once again, it cannot jump back into the recursion to try other alternatives, so the entire match fails."
				}
			},
			{
				"marker": {
					"id": "sect21"
				},
				"title": "Subpatterns as Subroutines",
				"p": [
					"If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:",
					"An earlier example pointed out that the following pattern matches \"sense and sensibility\" and \"response and responsibility\", but not \"sense and responsibility\":",
					"If instead the following pattern is used, it matches \"sense and responsibility\" and the other two strings:",
					"Another example is provided in the discussion of DEFINE earlier.",
					"All subroutine calls, recursive or not, are always treated as atomic groups. That is, once a subroutine has matched some of the subject string, it is never re-entered, even if it contains untried alternatives and there is a subsequent matching failure. Any capturing parentheses that are set during the subroutine call revert to their previous values afterwards.",
					"Processing options such as case-independence are fixed when a subpattern is defined, so if it is used as a subroutine, such options cannot be changed for different calls. For example, the following pattern matches \"abcabc\" but not \"abcABC\", as the change of processing option does not affect the called subpattern:"
				],
				"code": [
					"(...(absolute)...)...(?2)...(...(relative)...)...(?-1)...(...(?+1)...(relative)...",
					"(sens|respons)e and \\1ibility",
					"(sens|respons)e and (?1)ibility",
					"(abc)(?i:(?-1))"
				]
			},
			{
				"marker": {
					"id": "sect22"
				},
				"title": "Oniguruma Subroutine Syntax",
				"p": [
					"For compatibility with Oniguruma, the non-Perl syntax \g followed by a name or a number enclosed either in angle brackets or single quotes, is alternative syntax for referencing a subpattern as a subroutine, possibly recursively. Here follows two of the examples used above, rewritten using this syntax:",
					"PCRE supports an extension to Oniguruma: if a number is preceded by a plus or minus sign, it is taken as a relative reference, for example:",
					{
						"em": "not"
					}
				],
				"code": [
					"(?<pn> \\( ( (?>[^()]+) | \\g<pn> )* \\) )(sens|respons)e and \\g'1'ibility",
					"(abc)(?i:\\g<-1>)"
				]
			},
			{
				"marker": {
					"id": "sect23"
				},
				"title": "Backtracking Control",
				"p": [
					"Perl 5.10 introduced some \"Special Backtracking Control Verbs\", which are still described in the Perl documentation as \"experimental and subject to change or removal in a future version of Perl\". It goes on to say: \"Their usage in production code should be noted to avoid problems during upgrades.\" The same remarks apply to the PCRE features described in this section.",
					"The new verbs make use of what was previously invalid syntax: an opening parenthesis followed by an asterisk. They are generally of the form (*VERB) or (*VERB:NAME). Some can take either form, possibly behaving differently depending on whether a name is present. A name is any sequence of characters that does not include a closing parenthesis. The maximum name length is 255 in the 8-bit library and 65535 in the 16-bit and 32-bit libraries. If the name is empty, that is, if the closing parenthesis immediately follows the colon, the effect is as if the colon was not there. Any number of these verbs can occur in a pattern.",
					"The behavior of these verbs in repeated groups, assertions, and in subpatterns called as subroutines (whether or not recursively) is described below.",
					{
						"em": "Optimizations That Affect Backtracking Verbs"
					},
					{
						"c": "no_start_optimize",
						"seealso": [
							{
								"marker": "#compile/2",
								"c": "compile/2"
							},
							{
								"marker": "#run/3",
								"c": "run/3"
							}
						]
					},
					"Experiments with Perl suggest that it too has similar optimizations, sometimes leading to anomalous results.",
					{
						"em": "Verbs That Act Immediately"
					},
					"The following verbs act as soon as they are encountered. They must not be followed by a name.",
					"This verb causes the match to end successfully, skipping the remainder of the pattern. However, when it is inside a subpattern that is called as a subroutine, only that subpattern is ended successfully. Matching then continues at the outer level. If (*ACCEPT) is triggered in a positive assertion, the assertion succeeds; in a negative assertion, the assertion fails.",
					"If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches \"AB\", \"AAD\", or \"ACD\". When it matches \"AB\", \"B\" is captured by the outer parentheses.",
					"The following verb causes a matching failure, forcing backtracking to occur. It is equivalent to (?!) but easier to read.",
					"The Perl documentation states that it is probably useful only when combined with (?{}) or (??{}). Those are Perl features that are not present in PCRE.",
					"A match with the string \"aaaa\" always fails, but the callout is taken before each backtrack occurs (in this example, 10 times).",
					{
						"em": "Recording Which Path Was Taken"
					},
					"The main purpose of this verb is to track how a match was arrived at, although it also has a secondary use in with advancing the match starting point (see (*SKIP) below).",
					"A name is always required with this verb. There can be as many instances of (*MARK) as you like in a pattern, and their names do not have to be unique.",
					{
						"c": [
							"pcre_exec()",
							"pcreapi",
							"pcretest"
						]
					},
					"The (*MARK) name is tagged with \"MK:\" in this output, and in this example it indicates which of the two alternatives matched. This is a more efficient way of obtaining this information than putting each alternative in its own capturing parentheses.",
					"If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.",
					"After a partial match or a failed match, the last encountered name in the entire match process is returned, for example:",
					"Notice that in this unanchored example, the mark is retained from the match attempt that started at letter \"X\" in the subject. Subsequent match attempts starting at \"P\" and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.",
					{
						"em": "Verbs That Act after Backtracking"
					},
					"The following verbs do nothing when they are encountered. Matching continues with what follows, but if there is no subsequent match, causing a backtrack to the verb, a failure is forced. That is, backtracking cannot pass to the left of the verb. However, when one of these verbs appears inside an atomic group or an assertion that is true, its effect is confined to that group, as once the group has been matched, there is never any backtracking into it. In this situation, backtracking can \"jump back\" to the left of the entire atomic group or assertion. (Remember also, as stated above, that this localization also applies in subroutine calls.)",
					"These verbs differ in exactly what kind of failure occurs when backtracking reaches them. The behavior described below is what occurs when the verb is not in a subroutine or an assertion. Subsequent sections cover these special cases.",
					"The following verb, which must not be followed by a name, causes the whole match to fail outright if there is a later matching failure that causes backtracking to reach it. Even if the pattern is unanchored, no further attempts to find a match by advancing the starting point take place.",
					{
						"seealso": {
							"marker": "#run/2",
							"c": "run/2,3"
						}
					},
					"This matches \"xxaab\" but not \"aacaab\". It can be thought of as a kind of dynamic anchor, or \"I've started, so I must finish\". The name of the most recently passed (*MARK) in the path is passed back when (*COMMIT) forces a match failure.",
					"If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.",
					"Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:",
					{
						"c": "no_start_optimize"
					},
					"The following verb causes the match to fail at the current starting position in the subject if there is a later matching failure that causes backtracking to reach it:",
					"If the pattern is unanchored, the normal \"bumpalong\" advance to the next starting character then occurs. Backtracking can occur as usual to the left of (*PRUNE), before it is reached, or when matching to the right of (*PRUNE), but if there is no match to the right, backtracking cannot cross (*PRUNE). In simple cases, the use of (*PRUNE) is just an alternative to an atomic group or possessive quantifier, but there are some uses of (*PRUNE) that cannot be expressed in any other way. In an anchored pattern, (*PRUNE) has the same effect as (*COMMIT).",
					"The behavior of (*PRUNE:NAME) is the not the same as (*MARK:NAME)(*PRUNE). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).",
					"The following verb, when specified without a name, is like (*PRUNE), except that if the pattern is unanchored, the \"bumpalong\" advance is not to the next character, but to the position in the subject where (*SKIP) was encountered.",
					"(*SKIP) signifies that whatever text was matched leading up to it cannot be part of a successful match. Consider:",
					"If the subject is \"aaaac...\", after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at \"c\". Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to \"c\".",
					"When (*SKIP) has an associated name, its behavior is modified:",
					"When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the \"bumpalong\" advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored.",
					"Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).",
					"The following verb causes a skip to the next innermost alternative when backtracking reaches it. That is, it cancels any further backtracking within the current alternative.",
					"The verb name comes from the observation that it can be used for a pattern-based if-then-else block:",
					"If the COND1 pattern matches, FOO is tried (and possibly further items after the end of the group if FOO succeeds). On failure, the matcher skips to the second alternative and tries COND2, without backtracking into COND1. If that succeeds and BAR fails, COND3 is tried. If BAZ then fails, there are no more alternatives, so there is a backtrack to whatever came before the entire group. If (*THEN) is not inside an alternation, it acts like (*PRUNE).",
					"The behavior of (*THEN:NAME) is the not the same as (*MARK:NAME)(*THEN). It is like (*MARK:NAME) in that the name is remembered for passing back to the caller. However, (*SKIP:NAME) searches only for names set with (*MARK).",
					"A subpattern that does not contain a | character is just a part of the enclosing alternative; it is not a nested alternation with only one alternative. The effect of (*THEN) extends beyond such a subpattern to the enclosing alternative. Consider the following pattern, where A, B, and so on, are complex pattern fragments that do not contain any | characters at this level:",
					"If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:",
					"The effect of (*THEN) is now confined to the inner subpattern. After a failure in C, matching moves to (*FAIL), which causes the whole subpattern to fail, as there are no more alternatives to try. In this case, matching does now backtrack into A.",
					"Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:",
					"If the subject is \"ba\", this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character \"b\" is matched, but \"c\" is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match \"b\", the match would succeed.)",
					"The verbs described above provide four different \"strengths\" of control when subsequent matching fails:",
					{
						"em": "More than One Backtracking Verb"
					},
					"If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:",
					"If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:",
					"If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).",
					{
						"em": "Backtracking Verbs in Repeated Groups"
					},
					"PCRE differs from Perl in its handling of backtracking verbs in repeated groups. For example, consider:",
					"If the subject is \"abac\", Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.",
					{
						"em": "Backtracking Verbs in Assertions"
					},
					"(*FAIL) in an assertion has its normal effect: it forces an immediate backtrack.",
					"(*ACCEPT) in a positive assertion causes the assertion to succeed without any further processing. In a negative assertion, (*ACCEPT) causes the assertion to fail without any further processing.",
					"The other backtracking verbs are not treated specially if they appear in a positive assertion. In particular, (*THEN) skips to the next alternative in the innermost enclosing group that has alternations, regardless if this is within the assertion.",
					"Negative assertions are, however, different, to ensure that changing a positive assertion into a negative assertion changes its result. Backtracking into (*COMMIT), (*SKIP), or (*PRUNE) causes a negative assertion to be true, without considering any further alternative branches in the assertion. Backtracking into (*THEN) causes it to skip to the next enclosing alternative within the assertion (the normal behavior), but if the assertion does not have such an alternative, (*THEN) behaves like (*PRUNE).",
					{
						"em": "Backtracking Verbs in Subroutines"
					},
					"These behaviors occur regardless if the subpattern is called recursively. The treatment of subroutines in Perl is different in some cases."
				],
				"code": [
					"(*ACCEPT)",
					"A((?:A|B(*ACCEPT)|C)D)",
					"(*FAIL) or (*F)",
					"(*MARK:NAME) or (*:NAME)",
					"re> /X(*MARK:A)Y|X(*MARK:B)Z/Kdata> XY 0: XYMK: AXZ 0: XZMK: B",
					"re> /X(*MARK:A)Y|X(*MARK:B)Z/Kdata> XPNo match, mark = B",
					"(*COMMIT)",
					"a+(*COMMIT)b",
					{
						"type": "none",
						"$t": "1> re:run(\"xyzabc\",\"(*COMMIT)abc\",[{capture,all,list}]).{match,[\"abc\"]}2> re:run(\"xyzabc\",\"(*COMMIT)abc\",[{capture,all,list},no_start_optimize]).nomatch"
					},
					"(*PRUNE) or (*PRUNE:NAME)",
					"(*SKIP)",
					"a+(*SKIP)b",
					"(*SKIP:NAME)",
					"(*THEN) or (*THEN:NAME)",
					"( COND1 (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...",
					"A (B(*THEN)C) | D",
					"A (B(*THEN)C | (*FAIL)) | D",
					"^.*? (?(?=a) a | b(*THEN)c )",
					"(A(*COMMIT)B(*THEN)C|ABD)",
					"...(*COMMIT)(*PRUNE)...",
					"/(a(*COMMIT)b)+ac/"
				],
				"note": [
					{
						"p": [
							{
								"seealso": {
									"marker": "#run/2",
									"c": "run/2,3"
								}
							},
							"The rest of this section is therefore deliberately not adapted for reading by the Erlang programmer, but the examples can help in understanding NAMES as they can be used by (*SKIP)."
						]
					},
					{
						"p": "The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved."
					},
					{
						"p": "The fact that (*THEN:NAME) remembers the name is useless to the Erlang programmer, as names cannot be retrieved."
					}
				],
				"list": [
					{
						"type": "bulleted",
						"item": [
							{
								"p": "(*THEN) is the weakest, carrying on the match at the next alternative."
							},
							{
								"p": "(*PRUNE) comes next, fails the match at the current starting position, but allows an advance to the next character (for an unanchored pattern)."
							},
							{
								"p": "(*SKIP) is similar, except that the advance can be more than one character."
							},
							{
								"p": "(*COMMIT) is the strongest, causing the entire match to fail."
							}
						]
					},
					{
						"type": "bulleted",
						"item": [
							{
								"p": "(*FAIL) in a subpattern called as a subroutine has its normal effect: it forces an immediate backtrack."
							},
							{
								"p": "(*ACCEPT) in a subpattern called as a subroutine causes the subroutine match to succeed without any further processing. Matching then continues after the subroutine call."
							},
							{
								"p": "(*COMMIT), (*SKIP), and (*PRUNE) in a subpattern called as a subroutine cause the subroutine match to fail."
							},
							{
								"p": "(*THEN) skips to the next alternative in the innermost enclosing group within the subpattern that has alternatives. If there is no such group within the subpattern, (*THEN) causes the subroutine match to fail."
							}
						]
					}
				]
			}
		]
	}
}