{
	"chapter": {
		"header": {
			"copyright": {
				"year": [
					"1999",
					"2016"
				],
				"holder": "Ericsson AB. All Rights Reserved."
			},
			"legalnotice": "Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
			"title": "The Erlang I/O Protocol",
			"prepared": "Patrik Nyblom",
			"responsible": {},
			"docno": {},
			"approved": {},
			"checked": {},
			"date": "2009-02-25",
			"rev": "PA1",
			"file": "io_protocol.xml"
		},
		"p": [
			"The I/O protocol in Erlang enables bi-directional communication between clients and servers.",
			"The common I/O protocol has been present in OTP since the beginning, but has been undocumented and has also evolved over the years. In an addendum to Robert Virding's rationale, the original I/O protocol is described. This section describes the current I/O protocol.",
			"The original I/O protocol was simple and flexible. Demands for memory efficiency and execution time efficiency have triggered extensions to the protocol over the years, making the protocol larger and somewhat less easy to implement than the original. It can certainly be argued that the current protocol is too complex, but this section describes how it looks today, not how it should have looked.",
			"The basic ideas from the original protocol still hold. The I/O server and client communicate with one single, rather simplistic protocol and no server state is ever present in the client. Any I/O server can be used together with any client code, and the client code does not need to be aware of the I/O device that the I/O server communicates with."
		],
		"list": {
			"type": "bulleted",
			"item": [
				{
					"p": "The I/O server is a process that handles the requests and performs the requested task on, for example, an I/O device."
				},
				{
					"p": "The client is any Erlang process wishing to read or write data from/to the I/O device."
				}
			]
		},
		"section": [
			{
				"title": "Protocol Basics",
				"p": [
					{
						"c": [
							"io_request",
							"io_reply"
						]
					},
					{
						"c": [
							"io_request",
							"io_reply"
						]
					},
					{
						"c": [
							"io_request",
							"Request",
							"io_reply",
							"Reply"
						]
					}
				],
				"pre": "{io_request, From, ReplyAs, Request}{io_reply, ReplyAs, Reply}",
				"list": {
					"type": "bulleted",
					"item": [
						{
							"p": {
								"c": [
									"From",
									"pid()"
								]
							}
						},
						{
							"p": [
								{
									"c": [
										"ReplyAs",
										"io_reply",
										"ReplyAs",
										"ReplyAs"
									],
									"seealso": {
										"marker": "stdlib:io",
										"c": "io"
									}
								},
								{
									"c": [
										"pid()",
										"io_reply"
									]
								}
							]
						},
						{
							"p": {
								"c": [
									"Request",
									"Reply"
								]
							}
						}
					]
				}
			},
			{
				"title": "Output Requests",
				"p": [
					{
						"c": "Request"
					},
					{
						"c": [
							"io_reply",
							"Reply"
						]
					},
					{
						"c": "Request"
					},
					{
						"c": [
							"{put_chars, latin1, Characters}",
							"{put_chars, latin1, Module, Function, Args}"
						]
					}
				],
				"pre": [
					"{put_chars, Encoding, Characters}{put_chars, Encoding, Module, Function, Args}",
					"ok{error, Error}",
					"{put_chars, Characters}{put_chars, Module, Function, Args}"
				],
				"list": [
					{
						"type": "bulleted",
						"item": [
							{
								"p": [
									{
										"c": [
											"Encoding",
											"unicode",
											"latin1",
											"Encoding",
											"latin1"
										]
									},
									{
										"c": [
											"Module",
											"Function",
											"Args",
											"Encoding"
										]
									},
									"Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding."
								]
							},
							{
								"p": {
									"c": [
										"Characters",
										"Encoding",
										"latin1",
										"iolist()",
										"Encoding",
										"unicode"
									]
								}
							},
							{
								"p": [
									{
										"c": [
											"Module",
											"Function",
											"Args"
										],
										"seealso": {
											"marker": "stdlib:io_lib#format/2",
											"c": "io_lib:format/2"
										}
									},
									{
										"c": [
											"Args",
											"Encoding",
											"apply(Mod, Func, Args)",
											"{put_chars, Encoding, Characters}"
										]
									}
								]
							}
						]
					},
					{
						"type": "bulleted",
						"item": {
							"c": "Error",
							"seealso": {
								"marker": "stdlib:io",
								"c": "io"
							}
						}
					}
				]
			},
			{
				"title": "Input Requests",
				"p": [
					{
						"c": "Request"
					},
					{
						"c": "Request"
					},
					{
						"c": "Request"
					},
					{
						"c": [
							"get_chars",
							"get_line",
							"get_until"
						]
					},
					{
						"c": [
							"io_reply",
							"Reply"
						]
					},
					{
						"c": "Request"
					},
					{
						"c": [
							"{get_until, latin1, Prompt, Module, Function, ExtraArgs}",
							"{get_chars, latin1, Prompt, N}",
							"{get_line, latin1, Prompt}"
						]
					}
				],
				"pre": [
					"{get_until, Encoding, Prompt, Module, Function, ExtraArgs}",
					"{get_chars, Encoding, Prompt, N}",
					"{get_line, Encoding, Prompt}",
					"Dataeof{error, Error}",
					"{get_until, Prompt, Module, Function, ExtraArgs}{get_chars, Prompt, N}{get_line, Prompt}"
				],
				"list": [
					{
						"type": "bulleted",
						"item": [
							{
								"p": [
									{
										"c": [
											"Encoding",
											"Module",
											"Function",
											"ExtraArgs"
										]
									},
									{
										"c": [
											"Encoding",
											"latin1",
											"0..255",
											"Encoding",
											"unicode",
											"Encoding",
											"unicode"
										]
									}
								]
							},
							{
								"p": {
									"c": [
										"Prompt",
										"Prompt",
										"''"
									]
								}
							},
							{
								"p": [
									{
										"c": [
											"Module",
											"Function",
											"ExtraArgs"
										]
									},
									{
										"c": [
											"Result",
											"list()",
											"binary()"
										]
									},
									"The function is called with the data the I/O server finds on its I/O device, returning one of:",
									{
										"c": [
											"Continuation",
											"{done, eof, Rest}",
											"eof"
										]
									},
									{
										"c": "get_line"
									},
									{
										"c": [
											"Request",
											"[$\\n]",
											"apply(Module, Function, [ State, Data | ExtraArgs ])"
										]
									}
								],
								"pre": "{done, Result, RestChars}{more, Continuation}",
								"list": {
									"type": "bulleted",
									"item": [
										{
											"p": {
												"c": [
													"{done, Result, RestChars}",
													"Result",
													"RestChars"
												]
											}
										},
										{
											"p": {
												"c": "{more, Continuation}"
											}
										}
									]
								},
								"code": "-module(demo).-export([until_newline/3, get_line/1]).until_newline(_ThisFar,eof,_MyStopCharacter) -> {done,eof,[]};until_newline(ThisFar,CharList,MyStopCharacter) -> case lists:splitwith(fun(X) -> X =/= MyStopCharacter end, CharList) of {L,[]} -> {more,ThisFar++L};	{L2,[MyStopCharacter|Rest]} -> {done,ThisFar++L2++[MyStopCharacter],Rest} end.get_line(IoServer) -> IoServer ! {io_request, self(), IoServer, {get_until, unicode, '', ?MODULE, until_newline, [$\n]}}, receive {io_reply, IoServer, Data} -> Data end."
							}
						]
					},
					{
						"type": "bulleted",
						"item": [
							{
								"p": {
									"c": [
										"Encoding",
										"Prompt",
										"get_until"
									]
								}
							},
							{
								"p": {
									"c": "N"
								}
							}
						]
					},
					{
						"type": "bulleted",
						"item": {
							"c": [
								"Encoding",
								"Prompt",
								"get_until"
							]
						}
					},
					{
						"type": "bulleted",
						"item": [
							{
								"p": {
									"c": "Data"
								}
							},
							{
								"p": {
									"c": "eof"
								}
							},
							{
								"p": {
									"c": "Error",
									"seealso": {
										"marker": "stdlib:io",
										"c": "io"
									}
								}
							}
						]
					}
				]
			},
			{
				"title": "I/O Server Modes",
				"p": [
					{
						"c": [
							"get_line",
							"get_chars",
							"binary",
							"Data",
							"io_reply",
							"get_until"
						],
						"em": "when possible"
					},
					{
						"c": [
							"get_until",
							"get_until"
						],
						"seealso": [
							{
								"marker": "stdlib:io#fread/2",
								"c": "io:fread/2,3"
							},
							{
								"marker": "#example_io_server",
								"$t": "An Annotated and Working Example I/O Server"
							}
						]
					},
					"An I/O server in binary mode affects the data sent to the client, so that it must be able to handle binary data. For convenience, the modes of an I/O server can be set and retrieved using the following I/O requests:",
					{
						"c": "group.erl"
					},
					{
						"c": [
							"binary",
							"encoding",
							"echo",
							"expand",
							"unicode"
						]
					},
					{
						"c": "Reply"
					},
					{
						"c": [
							"enotsup",
							"echo",
							"setopts"
						]
					},
					"To retrieve options, the following request is used:",
					"This request asks for a complete list of all options supported by the I/O server as well as their current values.",
					"The I/O server replies:"
				],
				"pre": [
					"{setopts, Opts}",
					"{binary, boolean()} (or binary/list){echo, boolean()}{expand_fun, fun()}{encoding, unicode/latin1} (or unicode/latin1)",
					"ok{error, Error}",
					"getopts",
					"OptList{error, Error}"
				],
				"list": [
					{
						"type": "bulleted",
						"item": {
							"c": "Opts",
							"seealso": {
								"marker": "stdlib:proplists",
								"c": "proplists"
							}
						}
					},
					{
						"type": "bulleted",
						"item": {
							"c": [
								"OptList",
								"{Option, Value}",
								"Option"
							]
						}
					}
				]
			},
			{
				"title": "Multiple I/O Requests",
				"p": [
					{
						"c": [
							"Request",
							"Request"
						]
					},
					"The I/O server can, for a list of requests, send any of the following valid results in the reply, depending on the requests in the list:"
				],
				"pre": [
					"{requests, Requests}",
					"ok{ok, Data}{ok, Options}{error, Error}"
				],
				"list": {
					"type": "bulleted",
					"item": {
						"c": [
							"Requests",
							"io_request"
						]
					}
				}
			},
			{
				"title": "Optional I/O Request",
				"p": [
					"The following I/O request is optional to implement and a client is to be prepared for an error return:",
					{
						"c": "Reply"
					}
				],
				"pre": [
					"{get_geometry, Geometry}",
					"{ok, N}{error, Error}"
				],
				"list": [
					{
						"type": "bulleted",
						"item": {
							"c": [
								"Geometry",
								"rows",
								"columns"
							]
						}
					},
					{
						"type": "bulleted",
						"item": {
							"c": [
								"N",
								"{error, enotsup}"
							]
						}
					}
				]
			},
			{
				"title": "Unimplemented Request Types",
				"p": [
					{
						"c": [
							"io_request",
							"Request"
						]
					},
					"This makes it possible to extend the protocol with optional requests and for the clients to be somewhat backward compatible."
				],
				"pre": "{error, request}"
			},
			{
				"title": "An Annotated and Working Example I/O Server",
				"marker": {
					"id": "example_io_server"
				},
				"p": [
					"An I/O server is any process capable of handling the I/O protocol. There is no generic I/O server behavior, but could well be. The framework is simple, a process handling incoming requests, usually both I/O-requests and other I/O device-specific requests (positioning, closing, and so on).",
					"The example I/O server stores characters in an ETS table, making up a fairly crude RAM file.",
					"The module begins with the usual directives, a function to start the I/O server and a main loop handling the requests:",
					{
						"seealso": {
							"marker": "stdlib:io",
							"c": "io"
						},
						"c": [
							"request/2",
							"reply/3"
						]
					},
					{
						"c": [
							"{From, rewind}",
							"0",
							"io_request"
						]
					},
					"First, we examine the reply function:",
					{
						"c": [
							"io_reply",
							"ReplyAs"
						]
					},
					"We need to handle some requests. First the requests for writing characters:",
					{
						"c": [
							"Encoding",
							"unicode",
							"latin1",
							"Encoding"
						],
						"seealso": {
							"marker": "stdlib:unicode#characters_to_list/2",
							"c": "unicode:characters_to_list/2"
						}
					},
					{
						"c": [
							"Module",
							"Function",
							"Arguments"
						]
					},
					"We handle the requests for retrieving data:",
					{
						"c": [
							"get_until",
							"get_chars",
							"get_line",
							"put_chars/2",
							"get_until/5"
						]
					},
					{
						"c": [
							"get_geometry",
							"{error, enotsup}",
							"binary",
							"list"
						]
					},
					{
						"c": "requests"
					},
					{
						"seealso": {
							"marker": "kernel:file",
							"c": "file"
						},
						"c": "file:write/2"
					},
					{
						"c": "{error, request}"
					},
					"Next we handle the different requests, first the fairly generic multi-request type:",
					{
						"c": "io_reply"
					},
					{
						"c": [
							"getopts",
							"setopts"
						]
					},
					{
						"c": [
							"{setopts, [binary]}",
							"{setopts, [list]}",
							"{setopts,[{binary, boolean()}]}",
							"proplists:substitute_negations/2",
							"proplists:unfold/1",
							"{error, enotsup}"
						]
					},
					{
						"c": [
							"getopts",
							"{Option, Value}"
						]
					},
					{
						"c": "rewind"
					},
					{
						"c": "put_chars/3"
					},
					{
						"c": [
							"split_data/3",
							"apply_update/2"
						]
					},
					{
						"c": "get_until/5"
					},
					{
						"c": [
							"binary",
							"list",
							"setopts",
							"binary",
							"get_until",
							"get_chars",
							"get_line"
						]
					},
					{
						"em": "if possible",
						"c": [
							"get_until",
							"unicode",
							"latin1",
							"0..255",
							"check/2",
							"latin1"
						]
					},
					"To manipulate the table we implement the following utility functions:",
					{
						"c": "latin1"
					},
					{
						"c": [
							"until_newline/3",
							"until_enough/3",
							"get_until/5",
							"get_chars",
							"get_line"
						]
					},
					{
						"c": "get_until"
					},
					"To complete the I/O server, we only need to read and write the table in an appropriate way:",
					{
						"c": "?CHARS_PER_REC"
					},
					{
						"seealso": [
							{
								"marker": "stdlib:io",
								"c": "io"
							},
							{
								"marker": "kernel:file",
								"c": "file"
							}
						]
					}
				],
				"code": [
					"-module(ets_io_server).-export([start_link/0, init/0, loop/1, until_newline/3, until_enough/3]).-define(CHARS_PER_REC, 10).-record(state, { table, position, % absolute mode % binary | list }).start_link() -> spawn_link(?MODULE,init,[]).init() -> Table = ets:new(noname,[ordered_set]), ?MODULE:loop(#state{table = Table, position = 0, mode=list}).loop(State) -> receive {io_request, From, ReplyAs, Request} -> case request(Request,State) of {Tag, Reply, NewState} when Tag =:= ok; Tag =:= error -> reply(From, ReplyAs, Reply), ?MODULE:loop(NewState); {stop, Reply, _NewState} -> reply(From, ReplyAs, Reply), exit(Reply) end;	%% Private message {From, rewind} -> From ! {self(), ok}, ?MODULE:loop(State#state{position = 0}); _Unknown -> ?MODULE:loop(State) end.",
					"reply(From, ReplyAs, Reply) -> From ! {io_reply, ReplyAs, Reply}.",
					"request({put_chars, Encoding, Chars}, State) -> put_chars(unicode:characters_to_list(Chars,Encoding),State);request({put_chars, Encoding, Module, Function, Args}, State) -> try\trequest({put_chars, Encoding, apply(Module, Function, Args)}, State) catch\t_:_ -> {error, {error,Function}, State} end;",
					"request({get_until, Encoding, _Prompt, M, F, As}, State) -> get_until(Encoding, M, F, As, State);request({get_chars, Encoding, _Prompt, N}, State) -> %% To simplify the code, get_chars is implemented using get_until get_until(Encoding, ?MODULE, until_enough, [N], State);request({get_line, Encoding, _Prompt}, State) -> %% To simplify the code, get_line is implemented using get_until get_until(Encoding, ?MODULE, until_newline, [$\\n], State);",
					"request({get_geometry,_}, State) -> {error, {error,enotsup}, State};request({setopts, Opts}, State) -> setopts(Opts, State);request(getopts, State) -> getopts(State);request({requests, Reqs}, State) -> multi_request(Reqs, {ok, ok, State});",
					"request({put_chars,Chars}, State) -> request({put_chars,latin1,Chars}, State);request({put_chars,M,F,As}, State) -> request({put_chars,latin1,M,F,As}, State);request({get_chars,Prompt,N}, State) -> request({get_chars,latin1,Prompt,N}, State);request({get_line,Prompt}, State) -> request({get_line,latin1,Prompt}, State);request({get_until, Prompt,M,F,As}, State) -> request({get_until,latin1,Prompt,M,F,As}, State);",
					"request(_Other, State) -> {error, {error, request}, State}.",
					"multi_request([R|Rs], {ok, _Res, State}) -> multi_request(Rs, request(R, State));multi_request([_|_], Error) -> Error;multi_request([], Result) -> Result.",
					"setopts(Opts0,State) -> Opts = proplists:unfold( proplists:substitute_negations( [{list,binary}], Opts0)), case check_valid_opts(Opts) of\ttrue -> case proplists:get_value(binary, Opts) of true -> {ok,ok,State#state{mode=binary}}; false -> {ok,ok,State#state{mode=binary}}; _ -> {ok,ok,State} end;\tfalse -> {error,{error,enotsup},State} end.check_valid_opts([]) -> true;check_valid_opts([{binary,Bool}|T]) when is_boolean(Bool) -> check_valid_opts(T);check_valid_opts(_) -> false.getopts(#state{mode=M} = S) -> {ok,[{binary, case M of binary -> true; _ -> false end}],S}.",
					"put_chars(Chars, #state{table = T, position = P} = State) -> R = P div ?CHARS_PER_REC, C = P rem ?CHARS_PER_REC, [ apply_update(T,U) || U <- split_data(Chars, R, C) ], {ok, ok, State#state{position = (P + length(Chars))}}.",
					"get_until(Encoding, Mod, Func, As, #state{position = P, mode = M, table = T} = State) -> case get_loop(Mod,Func,As,T,P,[]) of {done,Data,_,NewP} when is_binary(Data); is_list(Data) -> if M =:= binary -> {ok, unicode:characters_to_binary(Data, unicode, Encoding), State#state{position = NewP}}; true -> case check(Encoding, unicode:characters_to_list(Data, unicode)) of {error, _} = E -> {error, E, State}; List -> {ok, List, State#state{position = NewP}} end end;	{done,Data,_,NewP} -> {ok, Data, State#state{position = NewP}}; Error -> {error, Error, State} end.get_loop(M,F,A,T,P,C) -> {NewP,L} = get(P,T), case catch apply(M,F,[C,L|A]) of {done, List, Rest} -> {done, List, [], NewP - length(Rest)};	{more, NewC} -> get_loop(M,F,A,T,NewP,NewC); _ -> {error,F} end.",
					"check(unicode, List) -> List;check(latin1, List) -> try [ throw(not_unicode) || X <- List, X > 255 ], List catch throw:_ -> {error,{cannot_convert, unicode, latin1}} end.",
					"until_newline([],eof,_MyStopCharacter) -> {done,eof,[]};until_newline(ThisFar,eof,_MyStopCharacter) -> {done,ThisFar,[]};until_newline(ThisFar,CharList,MyStopCharacter) -> case lists:splitwith(fun(X) -> X =/= MyStopCharacter end, CharList) of\t{L,[]} -> {more,ThisFar++L};\t{L2,[MyStopCharacter|Rest]} -> {done,ThisFar++L2++[MyStopCharacter],Rest} end.until_enough([],eof,_N) -> {done,eof,[]};until_enough(ThisFar,eof,_N) -> {done,ThisFar,[]};until_enough(ThisFar,CharList,N) when length(ThisFar) + length(CharList) >= N -> {Res,Rest} = my_split(N,ThisFar ++ CharList, []), {done,Res,Rest};until_enough(ThisFar,CharList,_N) -> {more,ThisFar++CharList}.",
					"get(P,Tab) -> R = P div ?CHARS_PER_REC, C = P rem ?CHARS_PER_REC, case ets:lookup(Tab,R) of [] -> {P,eof};	[{R,List}] -> case my_split(C,List,[]) of {_,[]} -> {P+length(List),eof}; {_,Data} -> {P+length(Data),Data} end end.my_split(0,Left,Acc) -> {lists:reverse(Acc),Left};my_split(_,[],Acc) -> {lists:reverse(Acc),[]};my_split(N,[H|T],Acc) -> my_split(N-1,T,[H|Acc]).split_data([],_,_) -> [];split_data(Chars, Row, Col) -> {This,Left} = my_split(?CHARS_PER_REC - Col, Chars, []), [ {Row, Col, This} | split_data(Left, Row + 1, 0) ].apply_update(Table, {Row, Col, List}) -> case ets:lookup(Table,Row) of [] -> ets:insert(Table,{Row, lists:duplicate(Col,0) ++ List});	[{Row, OldData}] -> {Part1,_} = my_split(Col,OldData,[]), {_,Part2} = my_split(Col+length(List),OldData,[]), ets:insert(Table,{Row, Part1 ++ List ++ Part2}) end."
				]
			}
		]
	}
}