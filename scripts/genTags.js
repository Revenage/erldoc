const fs = require("fs");
const path = require("path");
const request = require("request");
const cheerio = require("cheerio");

const defaultLanguage = "en";
const languages = ["en", "ru", "uk"];

const source = name => `http://erlang.org/doc/man/${name}.html`;

const modulesList = [
  "alarm_handler",
  "app",
  "application",
  "appup",
  "array",
  "asn1ct",
  "assert.hrl",
  "atomics",
  "auth",
  "base64",
  "beam_lib",
  "binary",
  "c",
  "calendar",
  "cdv",
  "cerl",
  "cerl_clauses",
  "cerl_trees",
  "code",
  "common_test",
  "compile",
  "config",
  "counters",
  "cover",
  "cprof",
  "cpu_sup",
  "crashdump_viewer",
  "crypto",
  "crypto_app",
  "ct",
  "ct_cover",
  "ct_ftp",
  "ct_hooks",
  "ct_master",
  "ct_netconfc",
  "ct_property_test",
  "ct_rpc",
  "ct_run",
  "ct_slave",
  "ct_snmp",
  "ct_ssh",
  "ct_telnet",
  "ct_testspec",
  "dbg",
  "debugger",
  "dets",
  "dialyzer",
  "diameter",
  "diameter_app",
  "diameter_codec",
  "diameter_dict",
  "diameter_make",
  "diameter_sctp",
  "diameter_tcp",
  "diameter_transport",
  "diameterc",
  "dict",
  "digraph",
  "digraph_utils",
  "disk_log",
  "disksup",
  "driver_entry",
  "dyntrace",
  "edoc",
  "edoc_doclet",
  "edoc_extract",
  "edoc_layout",
  "edoc_lib",
  "edoc_run",
  "ei",
  "ei_connect",
  "eldap",
  "epmd",
  "epp",
  "epp_dodger",
  "eprof",
  "erl",
  "erl_anno",
  "erl_boot_server",
  "erl_call",
  "erl_comment_scan",
  "erl_connect",
  "erl_ddll",
  "erl_docgen_app",
  "erl_driver",
  "erl_epmd",
  "erl_error",
  "erl_eterm",
  "erl_eval",
  "erl_expand_records",
  "erl_format",
  "erl_global",
  "erl_id_trans",
  "erl_internal",
  "erl_lint",
  "erl_malloc",
  "erl_marshal",
  "erl_nif",
  "erl_parse",
  "erl_pp",
  "erl_prettypr",
  "erl_prim_loader",
  "erl_prim_loader",
  "erl_recomment",
  "erl_scan",
  "erl_syntax",
  "erl_syntax_lib",
  "erl_tar",
  "erl_tidy",
  "erl_tracer",
  "erlang",
  "erlang",
  "erlang.el",
  "erlc",
  "erlsrv",
  "error_handler",
  "error_logger",
  "erts_alloc",
  "erts_alloc_config",
  "escript",
  "et",
  "et_collector",
  "et_selector",
  "et_viewer",
  "etop",
  "ets",
  "eunit",
  "eunit_surefire",
  "file",
  "file_sorter",
  "filelib",
  "filename",
  "fprof",
  "ftp",
  "gb_sets",
  "gb_trees",
  "gen_event",
  "gen_fsm",
  "gen_sctp",
  "gen_server",
  "gen_statem",
  "gen_tcp",
  "gen_udp",
  "gl",
  "global",
  "global_group",
  "glu",
  "heart",
  "HiPE_app",
  "http_uri",
  "httpc",
  "httpd",
  "httpd_custom_api",
  "httpd_socket",
  "httpd_util",
  "i",
  "igor",
  "inet",
  "inet_res",
  "inets",
  "init",
  "init",
  "instrument",
  "int",
  "io",
  "io_lib",
  "jinterface",
  "kernel_app",
  "lcnt",
  "leex",
  "lists",
  "log_mf_h",
  "logger",
  "logger_disk_log_h",
  "logger_filters",
  "logger_formatter",
  "logger_std_h",
  "make",
  "maps",
  "math",
  "megaco",
  "megaco_codec_meas",
  "megaco_codec_mstone1",
  "megaco_codec_mstone2",
  "megaco_codec_transform",
  "megaco_edist_compress",
  "megaco_encoder",
  "megaco_flex_scanner",
  "megaco_tcp",
  "megaco_transport",
  "megaco_udp",
  "megaco_user",
  "memsup",
  "merl",
  "merl_transform",
  "mnesia",
  "mnesia_frag_hash",
  "mnesia_registry",
  "mod_alias",
  "mod_auth",
  "mod_esi",
  "mod_security",
  "ms_transform",
  "msacc",
  "net",
  "net_adm",
  "net_kernel",
  "nteventlog",
  "observer",
  "Observer_app",
  "odbc",
  "orddict",
  "ordsets",
  "os",
  "os_mon_app",
  "os_sup",
  "persistent_term",
  "pg2",
  "pool",
  "prettypr",
  "proc_lib",
  "proplists",
  "public_key",
  "public_key_app",
  "qlc",
  "queue",
  "rand",
  "random",
  "rb",
  "re",
  "registry",
  "rel",
  "release_handler",
  "reltool",
  "relup",
  "rpc",
  "run_erl",
  "runtime_tools_app",
  "sasl_app",
  "scheduler",
  "script",
  "seq_trace",
  "sets",
  "shell",
  "shell_default",
  "slave",
  "snmp",
  "snmp_app",
  "snmp_community_mib",
  "snmp_framework_mib",
  "snmp_generic",
  "snmp_index",
  "snmp_notification_mib",
  "snmp_pdus",
  "snmp_standard_mib",
  "snmp_target_mib",
  "snmp_user_based_sm_mib",
  "snmp_view_based_acm_mib",
  "snmpa",
  "snmpa_conf",
  "snmpa_discovery_handler",
  "snmpa_error",
  "snmpa_error_io",
  "snmpa_error_logger",
  "snmpa_error_report",
  "snmpa_local_db",
  "snmpa_mib_data",
  "snmpa_mib_storage",
  "snmpa_mpd",
  "snmpa_network_interface",
  "snmpa_network_interface_filter",
  "snmpa_notification_delivery_info_receiver",
  "snmpa_notification_filter",
  "snmpa_supervisor",
  "snmpc",
  "snmpc(command)",
  "snmpm",
  "snmpm_conf",
  "snmpm_mpd",
  "snmpm_network_interface",
  "snmpm_network_interface_filter",
  "snmpm_user",
  "socket",
  "sofs",
  "ssh",
  "SSH_app",
  "ssh_client_channel",
  "ssh_client_key_api",
  "ssh_connection",
  "ssh_file",
  "ssh_server_channel",
  "ssh_server_key_api",
  "ssh_sftp",
  "ssh_sftpd",
  "ssl",
  "ssl_app",
  "ssl_crl_cache",
  "ssl_crl_cache_api",
  "ssl_session_cache_api",
  "start",
  "start_erl",
  "STDLIB_app",
  "string",
  "supervisor",
  "supervisor_bridge",
  "sys",
  "system_information",
  "systools",
  "tags",
  "tftp",
  "timer",
  "ttb",
  "typer",
  "unicode",
  "unix_telnet",
  "uri_string",
  "user",
  "werl",
  "win32reg",
  "wrap_log_reader",
  "wx",
  "wx_misc",
  "wx_object",
  "xmerl",
  "xmerl_eventp",
  "xmerl_sax_parser",
  "xmerl_scan",
  "xmerl_xpath",
  "xmerl_xs",
  "xmerl_xsd",
  "xref",
  "yecc",
  "zip",
  "zlib",
  "zlib"
];

const dist = path.resolve(__dirname, `../static/content`);
const escaping = str =>
  !str ? "" : str.replace(/\s\s+/g, " ").replace(/\n/g, "");

function pageParser(moduleName, body) {
  const $ = cheerio.load(body);
  const funcs = escaping($(".func-head").text());
  const titles = escaping($(".exports-body .title_link").text());
  return [moduleName, funcs, titles].filter(Boolean);
}

if (!fs.existsSync(dist)) {
  fs.mkdirSync(dist);
}
// languages.forEach(lang => {
//   const langFolder = path.resolve(dist, lang);
//   if (!fs.existsSync(langFolder)) {
//     fs.mkdirSync(langFolder);
//   }

// const lang = "en";
// const langFolder = path.resolve(dist, lang);

setInterval(() => {
  const preparedTags = JSON.parse(
    fs.readFileSync(path.resolve(__dirname, "../static/content", "tags.json"))
  );

  const preparedTagsNames = preparedTags.map(([name]) => name);
  console.log("%j", "names", preparedTagsNames);
  const undefinedTags = modulesList.filter(n => !preparedTagsNames.includes(n));
  const names = undefinedTags.slice(0, 10);
  console.log("%j", "nextnames", names);
  let result = names.map(moduleName => {
    return new Promise((res, rej) => {
      request(
        {
          uri: source(moduleName)
        },
        function(error, response, body) {
          if (error) {
            rej("%j", `File ${moduleName}.json ERRoR`, error);
            return;
          }

          res(pageParser(moduleName, body));
        }
      );
    });
  });

  Promise.all(result).then(result => {
    fs.writeFile(
      path.resolve(dist, `tags.json`),
      JSON.stringify([...preparedTags, ...result]),
      function(err) {
        if (err) throw err;
        console.log(`File tags.json.json created successfully.`);
      }
    );
  });
}, 100000);
